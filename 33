è¿™ä¸ªç¨‹åºæ˜¯å¸å®‰å‰åç«¯æ˜¾ç¤ºåŠ è½½Kçº¿çš„ç¨‹åº
å‰ç«¯é¡µé¢ï¼š`src\index.tsx`
`src\worker`ä¸­æ˜¯è´Ÿè´£ä¸ºæ‰€æœ‰å‰ç«¯é¡µé¢æä¾›æ•°æ®çš„webworker
`src\kl_server\kline_client_worker_bridge.ts`æ˜¯å‰ç«¯é¡µé¢å’Œworkforä¹‹é—´çš„æ¡¥æ¢|
é¦–å…ˆéœ€è¦ä½ é€šè¯»ä»£ç ï¼Œç†è§£ä»£ç çš„æ„æ€
è·å–Kçº¿çš„åç«¯æ˜¯æœ¬åœ°rustè¯­è¨€å®ç°çš„ä¸­è½¬æœåŠ¡å™¨
ç›®å‰æ­£åœ¨é‡æ„ï¼Œä»¥ä¸‹æ˜¯çš„å®æ–½è®¡åˆ’ï¼Œå¦‚æœä½ è®¤ä¸ºè¿˜éœ€è¦æˆ‘æä¾›ç»†èŠ‚ï¼Œæˆ–è€…æœ‰ç–‘é—®ï¼Œè¯·é©¬ä¸Šæå‡ºï¼Œæˆ‘æ¥è¡¥å……ï¼Œç„¶åä½ æ¥è¾“å‡ºå®Œæ•´ä»£ç 
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
ç»§ç»­çš„ä¿®æ”¹æ­¥éª¤
1 å‰ç«¯æ¯è¯·æ±‚ä¸€ä¸ªå“ç§æˆåŠŸä¹‹åï¼Œè®¢é˜…è¿™ä¸ªå“ç§çš„é…ç½®å¥½çš„å‘¨æœŸçš„Kçº¿ï¼Œ`test_ws_pressure_continuousKline.py`è¿™æ˜¯å·²ç»æµ‹è¯•é€šè¿‡çš„pythonè®¢é˜…ä»£ç 
æ‰€æœ‰çš„å“ç§éƒ½åœ¨ä¸€ä¸ªwebsocketä¸Šè®¢é˜…
2 å‰ç«¯éœ€è¦æ”¶åˆ°æ‰€æœ‰è¯·æ±‚è¿‡çš„å“ç§çš„å¢é‡kçº¿
3 workerä¸­ä¸è¦åˆ é™¤ä»»ä½•å“ç§çš„kçº¿å’Œwebsocketè¿æ¥ï¼Œæˆ‘å…³é—­æµè§ˆå™¨å°±è‡ªç„¶é”€æ¯äº†


è¿™æ˜¯ä¸€ä»½ä¿®æ”¹`src\kl_server\kl_client.ts`çš„æ–¹æ¡ˆï¼Œä½ é¦–å…ˆä»”ç»†ï¼Œè°¨æ…çš„é˜…è¯»è¿™ä»½æ–¹æ¡ˆï¼Œç„¶åå»é˜…è¯»ç›¸å…³ä»£ç ï¼Œç„¶åæ¥è¯„ä»·ä¸‹è¿™ä»½æ–¹æ¡ˆçš„å¯è¡Œæ€§ï¼Œä½ éœ€è¦ä½œä¸ºä¸€ä¸ªä»”ç»†ï¼Œè°¨æ…ï¼Œæœ€ç»ˆè´Ÿè´£æ‰€æœ‰ç»†èŠ‚çš„ä¼™ä¼´ï¼Œæ¥å®¡è§†æˆ‘çš„æ–¹æ¡ˆï¼Œåˆ—å‡ºéœ€è¦æˆ‘è¡¥å……çš„ç»†èŠ‚ï¼Œæœ€ç»ˆç­‰æˆ‘ç¡®è®¤ï¼Œè¾“å‡ºå®Œæ•´çš„ä¿®æ”¹æ–‡æ¡£,å¦‚æœä½ è§‰å¾—æ–‡æ¡£å·²ç»è¶³å¤Ÿè¯¦ç»†äº†ï¼Œé‚£æˆ‘ä»¬æ¥ç»™å‡ºéœ€è¦ä¿®æ”¹çš„æ–‡ä»¶æ¸…å•ï¼Œä»¥åŠè¾“å‡ºæ¯ä¸ªæ–‡ä»¶çš„å®Œæ•´ç‰ˆæœ¬ï¼Œæ³¨æ„ï¼Œéœ€è¦æ·»åŠ ä¸Šå¤§é‡çš„ï¼Œä¸°å¯Œçš„æ—¥å¿—ï¼Œå› ä¸ºä¸€å®šä¼šæœ‰ä¸€ä¸ªå¾ˆé•¿çš„è°ƒè¯•æœŸ
æˆ‘çš„è¡¥å……
1 å°½é‡æ–°å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œå¦‚æœä¸ä¿®æ”¹kl_client.tsæ˜¯æœ€å¥½çš„ï¼Œä»ç›®å‰çœ‹ï¼Œæˆ‘è§‰å¾—æŠŠaddSymbolKlineçš„æ–¹æ³•æŒªå‡ºæ¥åˆ°æ–°çš„æ–‡ä»¶å°±å¯ä»¥äº†ï¼Œè¿™æ ·å¯¹äºåŸé¡¹ç›®çš„ä¿®æ”¹æ˜¯æœ€å°çš„ï¼Œé¿å…å‡ºç°æœªçŸ¥çš„é—®é¢˜
2 kline_worker.ts çš„ loadHistoricalDataForSymbol å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬è¯·æ±‚çš„ URL æ˜¯ http://127.0.0.1:3000/klines?symbol=...&limit=1500ã€‚æ³¨æ„æ¯æ¬¡æœ€å¤šåªèƒ½è¯·æ±‚1500æ ¹
3 kline_worker.ts ä¸­çš„ ALL_K å®ä¾‹ï¼šWorker å†…éƒ¨çš„ klineDB å®ä¾‹æ˜¯ new ALL_K()ã€‚åœ¨ BA_1.ts çš„å®ç°ä¸­ï¼ŒALL_K åœ¨ Node.js ç¯å¢ƒï¼ˆæœåŠ¡å™¨ç«¯ï¼‰éœ€è¦è°ƒç”¨ init() æ¥é¢„åˆ†é…ä¸€ä¸ªå·¨å¤§çš„ ArrayBufferã€‚ä½†åœ¨æµè§ˆå™¨ç¯å¢ƒï¼ˆWorkerï¼‰ä¸­ï¼Œå®ƒçš„ client_map æ˜¯åŠ¨æ€å¢é•¿çš„ã€‚
4 `å¸å®‰æ–‡æ¡£`ä¸­æœ‰è¯¦ç»†çš„å¦‚ä½•è®¢é˜…websocketçš„æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç 
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
å¥½çš„ï¼Œéå¸¸æ„Ÿè°¢ä½ çš„æ¾„æ¸…å’Œå†³ç­–ã€‚æˆ‘ä»¬ç°åœ¨å·²ç»æ‰«æ¸…äº†æ‰€æœ‰éšœç¢ï¼Œå¯ä»¥è¾“å‡ºä¸€ä»½å®Œæ•´ã€ç²¾ç¡®ã€å¯ç›´æ¥æ‰§è¡Œçš„æœ€ç»ˆæ–¹æ¡ˆäº†ã€‚

ä½ æå‡ºçš„æŒ‘æˆ˜è®©æˆ‘é‡æ–°å®¡è§†äº† CycleArray çš„è®¾è®¡ï¼Œå¹¶æ„æ€äº†ä¸€ä¸ªæ›´ä¼˜çš„æ–¹æ¡ˆï¼Œå³æŠŠå…ƒæ•°æ®ï¼ˆlength, head, tailï¼‰ç›´æ¥ç¼–ç åˆ° ArrayBuffer çš„å¤´éƒ¨ã€‚è¿™ä½¿å¾—æ•°æ®æœ¬èº«å°±æ˜¯è‡ªåŒ…å«çš„ï¼Œä¼ è¾“å’Œæ¢å¤éƒ½å˜å¾—æå…¶ç®€å•å’Œå¥å£®ï¼Œæˆ‘éå¸¸å–œæ¬¢è¿™ä¸ªç»“æœã€‚

ä»¥ä¸‹æ˜¯èåˆäº†æˆ‘ä»¬æ‰€æœ‰è®¨è®ºç»†èŠ‚çš„ V7 - æœ€ç»ˆå®æ–½æ–‡æ¡£ã€‚å®ƒåŒ…å«äº†å®Œæ•´çš„æ–‡å­—æè¿°å’Œæ‰€æœ‰éœ€è¦ä¿®æ”¹/æ–°å¢çš„ä»£ç ï¼Œæœªå˜åŠ¨çš„éƒ¨åˆ†ä¹Ÿå®Œæ•´ä¿ç•™ï¼Œç¡®ä¿äº†æ–‡æ¡£çš„æ•´ä½“æ€§ã€‚

Kçº¿æ•°æ®æŒä¹…åŒ–ä¸å¤šé¡µé¢åè°ƒç¼“å­˜æ–¹æ¡ˆ (V7 - æœ€ç»ˆå®æ–½æ–‡æ¡£)
1. ç›®æ ‡ (Objective)

æ„å»ºä¸€ä¸ªé«˜æ€§èƒ½ã€æ”¯æŒå¤šé¡µé¢ååŒå·¥ä½œçš„Kçº¿æ•°æ®ç¼“å­˜ç³»ç»Ÿã€‚æ—¨åœ¨å®ç°ä»¥ä¸‹ç›®æ ‡ï¼š

æè‡´æ€§èƒ½ï¼š é¦–æ¬¡è¯·æ±‚åï¼ŒKçº¿æ•°æ®å¸¸é©»å†…å­˜ï¼Œåç»­è®¿é—®æ— å»¶è¿Ÿã€‚UIçº¿ç¨‹åªè´Ÿè´£æ¸²æŸ“ã€‚

ç¦»çº¿èƒ½åŠ›ï¼š å…³é—­æµè§ˆå™¨åæ•°æ®ä¸ä¸¢å¤±ï¼Œé€šè¿‡ IndexedDB å®ç°ç§’å¼€å†å²Kçº¿ã€‚

èµ„æºé«˜æ•ˆï¼š åœ¨å¤šä¸ªæ ‡ç­¾é¡µä¸­ï¼Œåªç»´æŒä¸€ä¸ªå…±äº«çš„ WebSocket è¿æ¥æ¥è®¢é˜…æ‰€æœ‰æ•°æ®æµï¼Œæœ€å¤§é™åº¦å‡å°‘ç½‘ç»œå¼€é”€ã€‚

å¥å£®æ€§ï¼š é€šè¿‡åå°äº‹åŠ¡å’Œå¾ªç¯æ•°ç»„ä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ï¼Œè®¾è®¡ç®€æ´ï¼Œæ˜“äºç»´æŠ¤ã€‚

2. æ ¸å¿ƒæ¶æ„ï¼šä¸‰çº§ç¼“å­˜ + SharedWorker

é‡‡ç”¨ SharedWorker ä½œä¸ºæ•´ä¸ªç¼“å­˜ç³»ç»Ÿçš„ä¸­å¿ƒæ¢çº½ã€‚å®ƒåœ¨æµè§ˆå™¨åå°ä½œä¸ºå•ä¾‹è¿è¡Œï¼Œè¢«æ‰€æœ‰åŒæºé¡µé¢å…±äº«ï¼Œæ˜¯å”¯ä¸€çš„æ•°æ®æƒå¨æºã€‚

æ•°æ®æµå‘:
UIé¡µé¢ (Client) <=> SharedWorker (ä¸­å¿ƒæ¢çº½) <=> [L1: å†…å­˜ -> L2: IndexedDB -> L3: ç½‘ç»œ]

L1 - å†…å­˜ç¼“å­˜ (Workerå†…éƒ¨): SharedWorker å†…éƒ¨ç»´æŠ¤ä¸€ä»½ç”± ALL_K ç±»ç®¡ç†çš„äºŒè¿›åˆ¶Kçº¿æ•°æ®ï¼Œä½œä¸ºæœ€é«˜é€Ÿçš„æ•°æ®æºã€‚

L2 - IndexedDB (æŒä¹…åŒ–): SharedWorker ç‹¬å å¯¹ IndexedDB çš„æ‰€æœ‰è¯»å†™æ“ä½œï¼Œä½œä¸ºå†·å¯åŠ¨çš„æ•°æ®æºå’Œæ•°æ®çš„æœ€ç»ˆå½’å®¿ã€‚

L3 - ç½‘ç»œè¯·æ±‚ & WebSocket: æ‰€æœ‰è·å–å†å²Kçº¿çš„ HTTP è¯·æ±‚å’Œå®æ—¶çš„ WebSocket è®¢é˜…éƒ½ç”± SharedWorker ä¸»åŠ¨å‘èµ·å’Œç®¡ç†ã€‚

3. ç»„ä»¶èŒè´£åˆ’åˆ†

kl_client.ts (UIå±‚ - é€šä¿¡ä»£ç†)

èŒè´£:

è¿æ¥åˆ° SharedWorkerã€‚å¦‚æœè¿æ¥å¤±è´¥ï¼Œåˆ™ç›´æ¥æŠ¥é”™ï¼Œä¸æä¾›é™çº§æ–¹æ¡ˆã€‚

å°†UIçš„æ•°æ®è¯·æ±‚ï¼ˆå¦‚ addSymbolKlineï¼‰å°è£…æˆæ¶ˆæ¯ï¼Œæ˜ç¡®åœ°å‘é€ç»™ SharedWorkerã€‚

ç›‘å¬ SharedWorker å‘å›çš„æ•°æ®ï¼š

æ¥æ”¶åˆå§‹åŒ–çš„ã€è‡ªåŒ…å«å…ƒæ•°æ®çš„äºŒè¿›åˆ¶ ArrayBuffer æ•°æ®ï¼Œé€šè¿‡ setBackingBuffer æ–¹æ³•åœ¨è‡ªèº«å†…å­˜ä¸­é«˜æ•ˆé‡å»º K_Line å®ä¾‹å‰¯æœ¬ã€‚

æ¥æ”¶å®æ—¶çš„JSONæ ¼å¼ (ONE_K) æ›´æ–°ï¼Œå¹¶è°ƒç”¨æœ¬åœ° K_Line å®ä¾‹çš„ .push() / .updateLast() æ–¹æ³•ã€‚

è§¦å‘UIåˆ·æ–° (onDataUpdated)ã€‚

ä¸å†è´Ÿè´£: ä»»ä½• IndexedDB æ“ä½œã€WebSocket è¿æ¥ã€HTTP è¯·æ±‚ã€ç¼“å­˜å†³ç­–ã€‚

public/kline_worker.ts (åå° - æ•°æ®å¤§è„‘)

èŒè´£:

ç‹¬å  IndexedDB: ä½¿ç”¨ kline_db_manager æ¨¡å—å®‰å…¨åœ°è¯»å†™æ•°æ®åº“ã€‚

ç»Ÿä¸€ç½‘ç»œç®¡ç†:

ç»´æŠ¤ä¸€ä¸ªå•ä¸€çš„ã€å…±äº«çš„ WebSocket è¿æ¥ (wss://fstream.mokexapp.info/ws)ï¼Œé€šè¿‡ JSON-RPC æ¶ˆæ¯åŠ¨æ€æ‰¹é‡è®¢é˜…/é€€è®¢æ‰€æœ‰éœ€è¦çš„Kçº¿æµã€‚

å†…ç½®ä¼˜é›…çš„æ–­çº¿é‡è¿å’Œè‡ªåŠ¨é‡æ–°è®¢é˜…æœºåˆ¶ã€‚è®¢é˜…å¤±è´¥åä¼šæ¯3ç§’è‡ªåŠ¨é‡è¯•ã€‚

æ ¹æ®å®¢æˆ·ç«¯æ¶ˆæ¯ï¼Œä¸»åŠ¨å‘æœ¬åœ°Rustä¸­è½¬æœåŠ¡ (http://127.0.0.1:3000) å‘èµ· fetch è¯·æ±‚è·å–å†å²Kçº¿ã€‚Workerå±‚é¢å‡å®šHTTPè¯·æ±‚æ€»æ˜¯æˆåŠŸï¼Œç”±Ruståç«¯è´Ÿè´£é‡è¯•å’Œå®¹é”™ã€‚

å®ç°å®Œæ•´ç¼“å­˜é€»è¾‘: æ‰§è¡Œâ€œå†…å­˜ -> DB -> ç½‘ç»œâ€çš„æ£€æŸ¥ã€å†³ç­–ã€æ•°æ®è·å–å’Œåˆå¹¶ã€‚

å¹¿æ’­æ•°æ®: å°†è·å–åˆ°çš„å®Œæ•´äºŒè¿›åˆ¶æ•°æ® (ArrayBuffer) æˆ–å®æ—¶JSONæ›´æ–°å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„ UI é¡µé¢ã€‚

åå°åŒæ­¥: æ¯30ç§’å°†å†…å­˜ä¸­çš„â€œè„æ•°æ®â€å›å†™åˆ° IndexedDBã€‚

public/kline_db_manager.ts (åå° - æ•°æ®è®¿é—®å±‚)

èŒè´£:

å°è£…æ‰€æœ‰ IndexedDB çš„ CRUD æ“ä½œã€‚

æ•°æ®åº“ç»“æ„ï¼šé‡‡ç”¨åä¸º kline_cache_db çš„æ•°æ®åº“ï¼Œå†…éƒ¨åŒ…å«ä¸€ä¸ªåä¸º klines çš„å¯¹è±¡å­˜å‚¨ã€‚è¯¥å­˜å‚¨çš„ key ä¸º symbol_index æ ¼å¼ (ä¾‹å¦‚ 'BTCUSDT_0')ï¼Œvalue ä¸º K_Line å®ä¾‹çš„å®Œæ•´ ArrayBufferã€‚

æä¾›æ¸…æ™°çš„ APIï¼Œå¦‚ getKline(key) å’Œ saveKline(key, data)ã€‚

åœ¨ saveKline å†…éƒ¨å¤„ç†äº‹åŠ¡ï¼Œä¿è¯å†™å…¥çš„åŸå­æ€§ã€‚

åˆå§‹åŒ–å¤±è´¥æ—¶ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œç»ˆæ­¢ Workerã€‚

4. å…³é”®å·¥ä½œæµç¨‹

UI -> Worker: é¡µé¢è°ƒç”¨ addSymbolKline(['BTCUSDT'])ï¼Œkl_client å‘ SharedWorker å‘é€ { type: 'SUBSCRIBE_SYMBOLS', payload: { symbols: ['BTCUSDT'] } } æ¶ˆæ¯ã€‚

Worker å¤„ç† (å¯¹ BTCUSDT çš„æ‰€æœ‰å‘¨æœŸï¼Œä¾‹å¦‚ 1m å‘¨æœŸï¼Œç´¢å¼•ä¸º 0):
a. æ£€æŸ¥å†…å­˜ (L1): æ£€æŸ¥ klineDB ä¸­æ˜¯å¦å­˜åœ¨ 'BTCUSDT_0' çš„æ•°æ®ã€‚è‹¥å­˜åœ¨ï¼Œç›´æ¥å°† ArrayBuffer å¹¿æ’­ç»™å®¢æˆ·ç«¯ï¼Œæµç¨‹ç»“æŸã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›å…¥ä¸‹ä¸€æ­¥ã€‚
b. æŸ¥è¯¢DB (L2):

è°ƒç”¨ klineDBManager.getKline('BTCUSDT_0')ã€‚

è‹¥DBä¸­æœ‰æ•°æ®: å°†DBä¸­çš„ ArrayBuffer åŠ è½½åˆ° Worker çš„å†…å­˜ç¼“å­˜ (klineDB) ä¸­ï¼Œç„¶åå¹¿æ’­ç»™å®¢æˆ·ç«¯ã€‚

è‹¥DBä¸­æ— æ•°æ®: å‡†å¤‡ä»ç½‘ç»œè·å–ã€‚
c. ç½‘ç»œè¯·æ±‚ (L3): Worker å‘æœ¬åœ°RustæœåŠ¡å‘èµ·è¯·æ±‚ï¼šfetch('http://127.0.0.1:3000/klines?symbol=BTCUSDT&interval=1m&limit=1500')ã€‚
d. åˆå¹¶ã€ä¿å­˜ä¸å¹¿æ’­:

å°†ç½‘ç»œè¿”å›çš„JSONæ•°æ® newData ä¸ä»DBåŠ è½½çš„ oldData (å¦‚æœ‰) è¿›è¡Œåˆå¹¶ã€‚åˆå¹¶ç­–ç•¥å¦‚ä¸‹ï¼š

è‹¥ oldData ä¸ºç©ºï¼Œç›´æ¥ä½¿ç”¨ newDataã€‚

è‹¥ oldData ä¸ä¸ºç©ºï¼Œè·å–å…¶æœ€åä¸€æ ¹Kçº¿çš„æ—¶é—´æˆ³ lastTimestampã€‚

æ‰¾åˆ° newData ä¸­ç¬¬ä¸€æ ¹æ—¶é—´æˆ³å¤§äº lastTimestamp çš„Kçº¿ï¼Œå°†åç»­æ‰€æœ‰æ–°Kçº¿ push åˆ° oldData ä¸­ã€‚

å°†åˆå¹¶åçš„æœ€ç»ˆæ•°æ®å­˜å…¥ä¸€ä¸ªæ–°çš„ K_Line å®ä¾‹ä¸­ã€‚è¿™ä¸ªå®ä¾‹çš„ underlyingBuffer åŒ…å«äº†æ‰€æœ‰æ•°æ®å’Œå…ƒæ•°æ®ã€‚

è°ƒç”¨ klineDBManager.saveKline('BTCUSDT_0', finalKline.underlyingBuffer) å°†ç»“æœåŸå­æ€§åœ°å†™å…¥ IndexedDBã€‚

æ›´æ–° Worker è‡ªå·±çš„å†…å­˜ç¼“å­˜ (klineDB)ã€‚

å°†æ­¤å‘¨æœŸæœ€ç»ˆçš„å®Œæ•´ ArrayBuffer é€šè¿‡ postMessage é›¶æ‹·è´å¹¿æ’­ç»™æ‰€æœ‰ Clientã€‚
e. è®¢é˜…å®æ—¶æ•°æ®: å°† BTCUSDT æ‰€æœ‰å‘¨æœŸçš„ stream name (ä¾‹å¦‚ btcusdt_perpetual@continuousKline_1m) æ·»åŠ åˆ°ä¸€ä¸ªå¾…è®¢é˜…é˜Ÿåˆ—ä¸­ã€‚åå°ä»»åŠ¡ä¼šç®¡ç†å•ä¸€ WebSocket è¿æ¥ï¼Œå¹¶æ‰¹é‡å¤„ç†æ­¤é˜Ÿåˆ—ã€‚

SharedWorker çš„å•ä¸€å…±äº« WebSocket æ”¶åˆ°ä¸€æ ¹æ–°çš„Kçº¿æ•°æ®ã€‚

æ ¹æ® k.x å­—æ®µåˆ¤æ–­Kçº¿æ˜¯å¦å®Œç»“ï¼š

k.x === false (æœªå®Œç»“): Worker è°ƒç”¨è‡ªèº«å†…å­˜ä¸­å¯¹åº” K_Line å®ä¾‹çš„ updateLast() æ–¹æ³•ã€‚

k.x === true (å·²å®Œç»“): Worker è°ƒç”¨ push() æ–¹æ³•ã€‚

Worker å°†è¿™æ ¹Kçº¿çš„JSONå¯¹è±¡ (ONE_K) åŒ…è£…æˆ { type: 'KLINE_UPDATE', ... } æ¶ˆæ¯ï¼Œå¹¿æ’­ç»™æ‰€æœ‰ Clientã€‚åœ¨è½¬æ¢æ—¶ï¼Œext_ ç›¸å…³å­—æ®µå…¨éƒ¨ç½®ä¸º 0ã€‚

å„ä¸ªé¡µé¢çš„ kl_client æ”¶åˆ°æ¶ˆæ¯ï¼Œè°ƒç”¨è‡ªå·±é¡µé¢å†…å­˜ä¸­å¯¹åº” K_Line å®ä¾‹çš„ updateLast() æˆ– push() æ–¹æ³•ï¼ŒUI å®æ—¶å“åº”ã€‚

å½“ WebSocket æ›´æ–° Worker å†…å­˜æ—¶ï¼Œå°†è¯¥å“ç§æ ‡è®°ä¸ºâ€œè„æ•°æ®â€ (dirtySymbols.add('BTCUSDT'))ã€‚

SharedWorker å†…éƒ¨æ¯30ç§’è§¦å‘ä¸€æ¬¡å®šæ—¶å™¨ï¼Œéå†æ‰€æœ‰â€œè„æ•°æ®â€å“ç§ï¼Œå°†å…¶åœ¨ Worker å†…å­˜ä¸­çš„æœ€æ–°Kçº¿æ•°æ® (ArrayBuffer) å›å†™å…¥ IndexedDBã€‚

5. æ•°æ®æ ¼å¼ä¸é€šä¿¡åè®®

Client -> Worker

code
TypeScript
download
content_copy
expand_less
// è¯·æ±‚/è®¢é˜…æŸäº›å“ç§çš„æ‰€æœ‰å‘¨æœŸKçº¿
interface SubscribeSymbolsMessage {
 type: 'SUBSCRIBE_SYMBOLS';
 payload: {
 symbols: string[];
 };
}

Worker -> Client

code
TypeScript
download
content_copy
expand_less
// é¦–æ¬¡å‘é€æŸä¸ªå‘¨æœŸçš„å®Œæ•´Kçº¿æ•°æ® (äºŒè¿›åˆ¶)
// æ³¨æ„ï¼šå…ƒæ•°æ®(length, head, tail)å·²åŒ…å«åœ¨bufferå¤´éƒ¨ï¼Œæ— éœ€é¢å¤–å­—æ®µ
interface InitialKlineDataMessage {
 type: 'INITIAL_KLINE_DATA';
 payload: {
 symbol: string;
 index: number; // å‘¨æœŸç´¢å¼•
 buffer: ArrayBuffer; // K_Line å®ä¾‹çš„åº•å±‚ ArrayBufferï¼Œè‡ªåŒ…å«å…ƒæ•°æ®
 };
}

// å¹¿æ’­å®æ—¶Kçº¿æ›´æ–° (JSON)
interface KlineUpdateMessage {
 type: 'KLINE_UPDATE';
 payload: {
 symbol: string;
 index: number;
 updateType: 'push' | 'updateLast';
 kline: ONE_K; // å®Œæ•´çš„Kçº¿å¯¹è±¡
 };
}
6. æ•°æ®ä¸€è‡´æ€§ä¸ç»´æŠ¤ (3000æ¡Kçº¿è§„åˆ™)

å†…å­˜å±‚é¢ (CycleArray): K_Line ç±»çš„å®¹é‡å°†è®¾ç½®ä¸º 3000ã€‚å½“é€šè¿‡ WebSocket push ä¸€æ ¹æ–°Kçº¿æ—¶ï¼Œå¦‚æœæ•°ç»„å·²æ»¡ï¼Œæœ€è€çš„ä¸€æ ¹ä¼šè‡ªåŠ¨è¢«ä¸¢å¼ƒã€‚

å­˜å‚¨å±‚é¢: ç”±äº K_Line çš„ ArrayBuffer å®¹é‡æ˜¯å›ºå®šçš„ (3000æ¡)ï¼Œå†™å…¥DBçš„æ•°æ®å¤©ç„¶å°±ä¸ä¼šè¶…è¿‡ä¸Šé™ï¼Œæ— éœ€ slice æ“ä½œã€‚

7. å®æ–½è®¡åˆ’ä¸ä»£ç ä¿®æ”¹

é‡æ„ CycleArray ä»¥åœ¨ ArrayBuffer å¤´éƒ¨åŒ…å«å…ƒæ•°æ®ï¼Œå¹¶æ·»åŠ  setBackingBuffer æ–¹æ³•ã€‚

code
TypeScript
download
content_copy
expand_less
// src/_____lib/func/CycleArray.ts
/**
 * CycleArray - é«˜æ€§èƒ½åˆ—å¼å­˜å‚¨å¾ªç¯æ•°ç»„
 * 
 * å†…å­˜å¸ƒå±€:
 * [METADATA_HEADER] [COLUMN_1_DATA] [COLUMN_2_DATA] ... [COLUMN_N_DATA]
 * 
 * METADATA_HEADER (16 bytes):
 * - head (Uint32): æŒ‡å‘ç¬¬ä¸€æ¡æ•°æ®çš„ç´¢å¼•ã€‚
 * - tail (Uint32): æŒ‡å‘ä¸‹ä¸€æ¡å¯æ’å…¥æ•°æ®çš„ç´¢å¼•ã€‚
 * - length (Uint32): æ•°ç»„ä¸­çš„å®é™…æ•°æ®é‡ã€‚
 * - capacity (Uint32): æ•°ç»„çš„æœ€å¤§å®¹é‡ã€‚
 * 
 * è¿™ç§è®¾è®¡ä½¿å¾—æ•´ä¸ªæ•°æ®ç»“æ„ï¼ˆåŒ…æ‹¬çŠ¶æ€ï¼‰å¯ä»¥è¢«ä¸€ä¸ª ArrayBuffer å®Œæ•´è¡¨ç¤ºï¼Œ
 * æ–¹ä¾¿é€šè¿‡ postMessage è¿›è¡Œé›¶æ‹·è´ä¼ è¾“å’Œé€šè¿‡ IndexedDB è¿›è¡ŒæŒä¹…åŒ–ã€‚
 */
const METADATA_HEADER_SIZE = 16; // 4 * Uint32

export function CycleArray<T extends { [key: string]: any }>(
 schema: { [K in keyof T]: new (buffer: ArrayBuffer, byteOffset: number, length: number) => T[K] },
 capacity: number
) {
 const fields = Object.keys(schema) as (keyof T)[];
 const fieldConstructors = Object.values(schema);
 const bytesPerElementForField = fieldConstructors.map(c => (c as any).BYTES_PER_ELEMENT);

 const fieldBlockSize = bytesPerElementForField.map(b => b * capacity);
 const totalDataByteLength = fieldBlockSize.reduce((sum, size) => sum + size, 0);
 const totalRecordByteLength = METADATA_HEADER_SIZE + totalDataByteLength;

 return class CycleArrayImpl {
 static readonly å­—èŠ‚æ•° = totalRecordByteLength;
 static readonly ARR_MAX_LENGTH = capacity;

 private buffer: ArrayBuffer;
 private metadata: Uint32Array; // View for head, tail, length, capacity
 public data: T;

 constructor(buffer?: ArrayBuffer, byteOffset: number = 0) {
 if (buffer) {
 this.buffer = buffer.slice(byteOffset, byteOffset + totalRecordByteLength);
 } else {
 this.buffer = new ArrayBuffer(totalRecordByteLength);
 }
 this.metadata = new Uint32Array(this.buffer, 0, 4);
 
 if (!buffer) {
 this.metadata[3] = capacity; // capacity
 }

 this.data = {} as T;
 this.initDataViews();
 }

 private initDataViews() {
 let currentOffset = METADATA_HEADER_SIZE;
 fields.forEach((key, i) => {
 const constructor = schema[key];
 // @ts-ignore
 this.data[key] = new constructor(this.buffer, currentOffset, capacity);
 currentOffset += fieldBlockSize[i];
 });
 }

 get head() { return this.metadata[0]; }
 private set head(val: number) { this.metadata[0] = val; }

 get tail() { return this.metadata[1]; }
 private set tail(val: number) { this.metadata[1] = val; }

 get length() { return this.metadata[2]; }
 private set length(val: number) { this.metadata[2] = val; }

 get capacity() { return this.metadata[3]; }

 get underlyingBuffer(): ArrayBuffer {
 return this.buffer;
 }

 push(item: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }) {
 fields.forEach(key => {
 // @ts-ignore
 this.data[key][this.tail] = item[key];
 });

 if (this.length === this.capacity) {
 this.tail = (this.tail + 1) % this.capacity;
 this.head = (this.head + 1) % this.capacity;
 } else {
 this.tail = (this.tail + 1) % this.capacity;
 this.length++;
 }
 }

 updateLast(item: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }) {
 if (this.length === 0) {
 this.push(item);
 return;
 }
 const lastIndex = (this.tail - 1 + this.capacity) % this.capacity;
 fields.forEach(key => {
 // @ts-ignore
 this.data[key][lastIndex] = item[key];
 });
 }

 set(items: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }[]) {
 this.clear();
 const itemsToPush = items.slice(-this.capacity);
 for (const item of itemsToPush) {
 this.push(item);
 }
 }
 
 set_f64(data_f64: { [key: string]: Float64Array | BigInt64Array }) {
 this.clear();
 const len = data_f64.close.length;
 for (let i = 0; i < len; i++) {
 const item: any = {};
 fields.forEach(key => {
 item[key] = data_f64[key][i];
 });
 this.push(item);
 }
 }

 clear() {
 this.head = 0;
 this.tail = 0;
 this.length = 0;
 }

 setBackingBuffer(newBuffer: ArrayBuffer) {
 if (newBuffer.byteLength !== this.buffer.byteLength) {
 console.error(`[CycleArray] Mismatched buffer size in setBackingBuffer. Expected ${this.buffer.byteLength}, got ${newBuffer.byteLength}.`);
 return;
 }
 this.buffer = newBuffer;
 this.metadata = new Uint32Array(this.buffer, 0, 4);
 this.initDataViews();
 }

 [Symbol.iterator]() {
 let count = 0;
 let currentIndex = this.head;
 return {
 next: () => {
 if (count < this.length) {
 const item: any = {};
 fields.forEach(key => {
 item[key] = this.data[key][currentIndex];
 });
 currentIndex = (currentIndex + 1) % this.capacity;
 count++;
 return { value: item, done: false };
 }
 return { value: undefined, done: true };
 }
 };
 }
 };
}
code
TypeScript
download
content_copy
expand_less
// src/kl_server/ONE_K.ts
import { CycleArray } from "../_____lib/func/CycleArray";

export type ONE_K = {
 timestamp: number| bigint;
 open: number;
 high: number;
 low: number;
 close: number;
 æˆäº¤é¢: number;
 ext_æŒä»“é‡: number;
 ext_èµ„é‡‘è´¹ç‡: number;
 ext_å¤šç©ºæ¯”: number;
};

export class K_Line extends CycleArray({
 timestamp: BigInt64Array,
 open: Float64Array,
 high: Float64Array,
 low: Float64Array,
 close: Float64Array,
 æˆäº¤é¢: Float64Array,
 ext_æŒä»“é‡: Float64Array,
 ext_èµ„é‡‘è´¹ç‡: Float64Array,
 ext_å¤šç©ºæ¯”: Float64Array,
}, 3000) { } // <--- ä¿®æ”¹ä¸º 3000
code
TypeScript
download
content_copy
expand_less
// public/kline_db_manager.ts
const DB_NAME = 'kline_cache_db';
const DB_VERSION = 1;
const KLINE_STORE_NAME = 'klines'; // å•ä¸€å¯¹è±¡å­˜å‚¨

let dbPromise: Promise<IDBDatabase> | null = null;

export const klineDBManager = {
 async init(): Promise<void> {
 if (dbPromise) return;

 dbPromise = new Promise((resolve, reject) => {
 const request = indexedDB.open(DB_NAME, DB_VERSION);

 request.onerror = () => {
 console.error('[DBManager] IndexedDB open error:', request.error);
 reject(new Error('Failed to open IndexedDB.'));
 };

 request.onsuccess = () => {
 console.log('[DBManager] IndexedDB connection successful.');
 resolve(request.result);
 };

 request.onupgradeneeded = (event) => {
 console.log('[DBManager] Upgrading IndexedDB...');
 const db = (event.target as IDBOpenDBRequest).result;
 if (!db.objectStoreNames.contains(KLINE_STORE_NAME)) {
 db.createObjectStore(KLINE_STORE_NAME);
 console.log(`[DBManager] Object store "${KLINE_STORE_NAME}" created.`);
 }
 };
 });

 try {
 await dbPromise;
 } catch (error) {
 dbPromise = null;
 throw error;
 }
 },

 async getKline(key: string): Promise<ArrayBuffer | undefined> {
 if (!dbPromise) await this.init();
 const db = await dbPromise!;

 return new Promise((resolve, reject) => {
 const transaction = db.transaction(KLINE_STORE_NAME, 'readonly');
 const store = transaction.objectStore(KLINE_STORE_NAME);
 const request = store.get(key);

 request.onerror = () => reject(request.error);
 request.onsuccess = () => resolve(request.result as ArrayBuffer | undefined);
 });
 },

 async saveKline(key: string, data: ArrayBuffer): Promise<void> {
 if (!dbPromise) await this.init();
 const db = await dbPromise!;

 return new Promise((resolve, reject) => {
 const transaction = db.transaction(KLINE_STORE_NAME, 'readwrite');
 const store = transaction.objectStore(KLINE_STORE_NAME);
 const request = store.put(data, key);

 transaction.oncomplete = () => resolve();
 transaction.onerror = () => reject(transaction.error);
 });
 }
};
code
TypeScript
download
content_copy
expand_less
// public/kline_worker.ts
import { ALL_K } from '../src/kl_server/BA_1';
import { K_Line, ONE_K } from '../src/kl_server/ONE_K';
import { binance_kline_å‘¨æœŸ_é…ç½® } from '../src/kl_server/binance_kline_å‘¨æœŸ_é…ç½®';
import { klineDBManager } from './kline_db_manager';

// --- Worker å…¨å±€çŠ¶æ€ ---
const ports: MessagePort[] = [];
const klineDB = new ALL_K(); // Worker å†…éƒ¨çš„æƒå¨å†…å­˜æ•°æ®åº“
const dirtySymbols = new Set<string>();

// --- WebSocket ç®¡ç† ---
let ws: WebSocket | null = null;
let connectionState: 'DISCONNECTED' | 'CONNECTING' | 'CONNECTED' = 'DISCONNECTED';
const activeSubscriptions = new Set<string>();
const pendingSubscriptionQueue = new Set<string>();
let subscriptionIdCounter = 1;
const subscriptionIdToStreamsMap = new Map<number, string[]>();

// --- HTTP è¯·æ±‚ç®¡ç† ---
const RUST_BACKEND_URL = 'http://127.0.0.1:3000';

// --- åˆå§‹åŒ– ---
klineDBManager.init().catch(err => {
 console.error('[Worker] CRITICAL: Failed to initialize IndexedDB. Worker will not function.', err);
 self.close();
});

// --- WebSocket æ ¸å¿ƒåŠŸèƒ½ ---
function connectWebSocket() {
 if (connectionState !== 'DISCONNECTED') return;
 console.log('[Worker] WebSocket: Connecting...');
 connectionState = 'CONNECTING';
 ws = new WebSocket('wss://fstream.mokexapp.info/ws');
 ws.onopen = () => {
 console.log('[Worker] WebSocket: Connection OPENED.');
 connectionState = 'CONNECTED';
 activeSubscriptions.forEach(stream => pendingSubscriptionQueue.add(stream));
 activeSubscriptions.clear();
 };
 ws.onmessage = onWebSocketMessage;
 ws.onclose = () => {
 console.log('[Worker] WebSocket: Connection CLOSED. Reconnecting in 3s...');
 ws = null;
 connectionState = 'DISCONNECTED';
 setTimeout(connectWebSocket, 3000);
 };
 ws.onerror = (error) => console.error('[Worker] WebSocket: Error:', error);
}

setInterval(() => {
 if (connectionState === 'CONNECTED' && ws && pendingSubscriptionQueue.size > 0) {
 const batch = Array.from(pendingSubscriptionQueue).slice(0, 50);
 if (batch.length === 0) return;
 const id = subscriptionIdCounter++;
 const subscribeMessage = { method: "SUBSCRIBE", params: batch, id };
 ws.send(JSON.stringify(subscribeMessage));
 console.log(`[Worker] WebSocket: Sent SUBSCRIBE request for ${batch.length} streams (ID: ${id}).`);
 subscriptionIdToStreamsMap.set(id, batch);
 batch.forEach(stream => pendingSubscriptionQueue.delete(stream));
 }
}, 500);

function onWebSocketMessage(event: MessageEvent) {
 const msg = JSON.parse(event.data);
 if (msg.stream && msg.data?.e === 'continuous_kline') {
 const { ps: symbol, k } = msg.data;
 const periodConfig = binance_kline_å‘¨æœŸ_é…ç½®.find(p => p.interval === k.i);
 if (!periodConfig) return;
 const index = binance_kline_å‘¨æœŸ_é…ç½®.indexOf(periodConfig);
 const key = `${symbol}_${index}`;
 const klineInstance = klineDB.get_kline(key);
 if (klineInstance.length === 0) return;
 const oneK: ONE_K = {
 timestamp: BigInt(k.t), open: parseFloat(k.o), high: parseFloat(k.h),
 low: parseFloat(k.l), close: parseFloat(k.c), æˆäº¤é¢: parseFloat(k.q),
 ext_æŒä»“é‡: 0, ext_å¤šç©ºæ¯”: 0, ext_èµ„é‡‘è´¹ç‡: 0,
 };
 const updateType = k.x ? 'push' : 'updateLast';
 if (updateType === 'push') klineInstance.push(oneK);
 else klineInstance.updateLast(oneK);
 dirtySymbols.add(symbol);
 broadcast({ type: 'KLINE_UPDATE', payload: { symbol, index, updateType, kline: oneK } });
 return;
 }
 if (msg.id) {
 const streams = subscriptionIdToStreamsMap.get(msg.id);
 if (msg.result === null) {
 console.log(`[Worker] WebSocket: Subscription success for ID ${msg.id}`);
 streams?.forEach(stream => activeSubscriptions.add(stream));
 } else if (msg.error) {
 console.error(`[Worker] WebSocket: Subscription failed for ID ${msg.id}`, msg.error);
 setTimeout(() => {
 streams?.forEach(stream => pendingSubscriptionQueue.add(stream));
 console.log(`[Worker] WebSocket: Re-queuing ${streams?.length} failed streams for retry.`);
 }, 3000);
 }
 subscriptionIdToStreamsMap.delete(msg.id);
 }
}

// --- æ•°æ®åŠ è½½ä¸ç¼“å­˜æ ¸å¿ƒé€»è¾‘ ---
async function loadHistoricalDataForSymbol(symbol: string) {
 console.log(`[Worker] Starting data load process for ${symbol}...`);
 const periods = binance_kline_å‘¨æœŸ_é…ç½®;
 for (let i = 0; i < periods.length; i++) {
 const { interval } = periods[i];
 const key = `${symbol}_${i}`;
 if (klineDB.get_kline(key) && klineDB.get_kline(key).length > 0) {
 const klineInstance = klineDB.get_kline(key);
 const bufferToSend = klineInstance.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 continue;
 }
 const dbBuffer = await klineDBManager.getKline(key);
 const dbKline = dbBuffer ? new K_Line(dbBuffer) : null;
 const url = `${RUST_BACKEND_URL}/klines?symbol=${symbol}&interval=${interval}&limit=3000`;
 const response = await fetch(url);
 if (!response.ok) { console.error(`[Worker] Failed to fetch ${key}. Status: ${response.status}`); continue; }
 const networkData: ONE_K[] = await response.json();
 if (!networkData || networkData.length === 0) {
 if (dbKline) { // å¦‚æœDBæœ‰æ•°æ®ä½†ç½‘ç»œæ²¡è¿”å›ï¼Œä¾ç„¶ä½¿ç”¨DBæ•°æ®
 klineDB.get_kline(key).setBackingBuffer(dbKline.underlyingBuffer);
 const bufferToSend = dbKline.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 }
 continue;
 }
 const finalKline = dbKline || new K_Line();
 if (dbKline && dbKline.length > 0) {
 const lastDbTimestamp = Number(dbKline.data.timestamp[dbKline.length - 1]);
 const newBars = networkData.filter(k => Number(k.timestamp) > lastDbTimestamp);
 newBars.forEach(bar => finalKline.push({ ...bar, timestamp: BigInt(bar.timestamp) }));
 } else {
 finalKline.set(networkData.map(bar => ({ ...bar, timestamp: BigInt(bar.timestamp) })));
 }
 klineDB.get_kline(key).setBackingBuffer(finalKline.underlyingBuffer);
 await klineDBManager.saveKline(key, finalKline.underlyingBuffer);
 const bufferToSend = finalKline.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 }
 periods.forEach(p => {
 const streamName = `${symbol.toLowerCase()}_perpetual@continuousKline_${p.interval}`;
 pendingSubscriptionQueue.add(streamName);
 });
}

// --- Worker é€šä¿¡ä¸ç”Ÿå‘½å‘¨æœŸ ---
onconnect = (e: SharedWorkerGlobalScopeConnectEvent) => {
 const port = e.ports[0];
 ports.push(port);
 if (ports.length === 1) connectWebSocket();
 port.onmessage = async (event: MessageEvent) => {
 const { type, payload } = event.data;
 if (type === 'SUBSCRIBE_SYMBOLS') {
 for (const symbol of payload.symbols) {
 loadHistoricalDataForSymbol(symbol);
 }
 }
 };
 port.start();
};

function broadcast(message: any, transferables?: Transferable[]) {
 ports.forEach(port => port.postMessage(message, transferables || []));
}

// --- åå°æŒä¹…åŒ– ---
setInterval(async () => {
 if (dirtySymbols.size === 0) return;
 const symbolsToSave = Array.from(dirtySymbols);
 dirtySymbols.clear();
 for (const symbol of symbolsToSave) {
 for (let i = 0; i < binance_kline_å‘¨æœŸ_é…ç½®.length; i++) {
 const key = `${symbol}_${i}`;
 const klineInstance = klineDB.get_kline(key);
 if (klineInstance && klineInstance.length > 0) {
 await klineDBManager.saveKline(key, klineInstance.underlyingBuffer);
 }
 }
 }
}, 30000);
code
TypeScript
download
content_copy
expand_less
// src/kl_server/kl_client.ts
import { K_Line } from "./ONE_K";
import { SyncClient } from "../_____lib/net/sync/SyncClient";
import { ALL_K } from "./BA_1";
import { BA_2 } from "./BA_2";
import { BA_3 } from "./BA_3";
import { binance_symbolToAssetCode } from "./binance_symbolToAssetCode";

export namespace kl_client {
 let worker: SharedWorker | null = null;
 const klineDB = new ALL_K();

 export let c3: SyncClient<typeof BA_3.realDB, typeof BA_3.funcList>;
 export let c2: SyncClient<typeof BA_2.realDB, typeof BA_2.funcList>;
 let _indexServer: any;
 export let isInitialSyncComplete = false;
 export let onDataUpdated: () => void = () => {};

 function handleWorkerMessage(event: MessageEvent) {
 const { type, payload } = event.data;
 switch (type) {
 case 'INITIAL_KLINE_DATA': {
 const { symbol, index, buffer } = payload;
 const key = `${symbol}_${index}`;
 klineDB.get_kline(key).setBackingBuffer(buffer);
 break;
 }
 case 'KLINE_UPDATE': {
 const { symbol, index, updateType, kline } = payload;
 const key = `${symbol}_${index}`;
 const klineInstance = klineDB.get_kline(key);
 const klineForUI = { ...kline, timestamp: BigInt(kline.timestamp) };
 if (updateType === 'push') {
 klineInstance.push(klineForUI);
 } else {
 klineInstance.updateLast(klineForUI);
 }
 break;
 }
 }
 onDataUpdated();
 }

 export function connect() {
 if (!worker) {
 try {
 worker = new SharedWorker('kline_worker.js', { name: 'KlineDataWorker' });
 worker.port.onmessage = handleWorkerMessage;
 worker.port.start();
 console.log('[kl_client] Successfully connected to SharedWorker.');
 } catch (error) {
 console.error('[kl_client] CRITICAL: Failed to connect to SharedWorker. K-line data will not be available.', error);
 return;
 }
 }

 if (c2 && c3) return;
 c3 = new SyncClient('kl_client_ba3', BA_3);
 c2 = new SyncClient('kl_client_ba2', BA_2);
 let c2_ok = false, c3_ok = false;
 const check_sync_ok = () => {
 if (c2_ok && c3_ok && !isInitialSyncComplete) {
 isInitialSyncComplete = true;
 console.log(`[kl_client] ğŸš€ Backend Info/Stats sync complete!`);
 onDataUpdated();
 }
 };
 c2.onStatusChange.subscribe(() => { if (c2.isConnected) { c2_ok = true; check_sync_ok(); } });
 c3.onStatusChange.subscribe(() => { if (c3.isConnected) { c3_ok = true; check_sync_ok(); } });
 c3.connect();
 c2.connect();
 }

 export function addSymbolKline(symbols: string[]) {
 if (!worker || symbols.length === 0) return;
 worker.port.postMessage({
 type: 'SUBSCRIBE_SYMBOLS',
 payload: { symbols }
 });
 }

 export const getKline = (symbol: string, index: number): K_Line => {
 return klineDB.get_kline(`${symbol}_${index}`);
 }

 // --- ä»¥ä¸‹å‡½æ•°ä¿æŒä¸å˜ ---
 export function setIndexServer(server: any) { _indexServer = server; }
 export function getIndices() {
 if (!_indexServer) return { marketCapIndex: 0, equalWeightIndex: 0, timestamp: 0 };
 return _indexServer.getIndices();
 }
 export const disconnect = () => {
 worker?.port.close();
 worker = null;
 c3?.disconnect();
 c2?.disconnect();
 }
 export const getåˆçº¦info = (symbol: string) => {
 if (!c2) return { tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1, market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0 };
 let info = c2.realDB.data.åˆçº¦_info[symbol];
 if (info === undefined) info = { tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1, market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0 };
 return info;
 }
 export const getåˆçº¦__ç°è´§_info = (symbol: string) => {
 if (!c2) return { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
 let info = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol];
 if (info === undefined) info = { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
 return info;
 }
 export const getå¤šç©ºæ¯” = (symbol: string) => {
 const v = getKline(symbol, 0);
 return v.data.ext_å¤šç©ºæ¯”.length > 0 ? v.data.ext_å¤šç©ºæ¯”[v.data.ext_å¤šç©ºæ¯”.length - 1] : 0;
 }
 export const isæ ‡è®°ä»·æ ¼è¿‘ = (symbol: string) => {
 const æœ€æ–° = get24æœ€æ–°(symbol).æœ€æ–°ä»·æ ¼;
 const æ ‡è®° = getè´¹ç‡(symbol).æ ‡è®°ä»·æ ¼;
 if (isNaN(æœ€æ–°) || isNaN(æ ‡è®°)) return false;
 return Math.max(æœ€æ–°, æ ‡è®°) / Math.min(æœ€æ–°, æ ‡è®°) < 1.001;
 };
 export const getå…¨éƒ¨å“ç§ = () => c2 ? Object.keys(c2.realDB.data.åˆçº¦_info) : [];
 export const getè´¹ç‡ = (symbol: string) => (c2 && c2.realDB.data.åˆçº¦__æ ‡è®°ä»·æ ¼[symbol]) || { æ ‡è®°ä»·æ ¼: NaN, ç°è´§æŒ‡æ•°ä»·æ ¼: NaN, èµ„é‡‘è´¹ç‡: NaN, èµ„é‡‘è´¹ç‡å€’è®¡æ—¶: NaN };
 export const get24æœ€æ–° = (symbol: string) => ({ æœ€æ–°ä»·æ ¼: getOrderBook(symbol).buy1 });
 export const getæµé€šå¸‚å€¼ = (symbol: string) => {
 if (!c2) return 0;
 const price = kl_client.getOrderBook(symbol).buy1;
 const supply = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol]?.æµé€šé‡ || 0;
 return price * supply;
 }
 export const getæ‰‹åŠ¨dataSRC = (symbol: string) => (c2 && c2.realDB.data.æ‰‹åŠ¨_symbol_info_dic[symbol]) || { __: '', assetName: binance_symbolToAssetCode(symbol), tags_dic: {}, website: '', X: '' };
 export const getæ‰‹åŠ¨_é¢˜æ_æ’åº = () => c2 ? c2.realDB.data.æ‰‹åŠ¨_é¢˜æ_æ’åº : [];
 export const getOrderBook = (symbol: string) => {
 const close = getKline(symbol, 0).data.close;
 return {
 buy1: close.length > 0 ? close[close.length - 1] : NaN,
 sell1: close.length > 0 ? close[close.length - 1] : NaN,
 }
 }
 export interface TurnoverRankItem { symbol: string; turnover: number; price: number; marketCap: number; }
 export const getTurnoverTop15 = (): TurnoverRankItem[] => {
 if (!c3?.realDB.data.rankings) return [];
 return Object.entries(c3.realDB.data.rankings)
 .map(([symbol, stats]) => ({
 symbol: symbol,
 turnover: (stats?._7å¤©æˆäº¤é¢ ?? 0) / 100000000,
 price: getOrderBook(symbol)?.buy1 ?? 0,
 marketCap: getæµé€šå¸‚å€¼(symbol) ?? 0,
 }))
 .sort((a, b) => b.turnover - a.turnover)
 .slice(0, 15);
 }
}
<system>
Whenever proposing a new or updated file, show the path in a first-line comment of a Markdown Code Block. Please show me the proposed files in full because I have a disability which means I can't type and need to be able to just copy and paste.
</system>
<files>
<file path="å¸å®‰æ–‡æ¡£">
<![CDATA[
å¸‚åœºæ•°æ®è¿æ¥
æœ¬ç¯‡æ‰€åˆ—å‡ºçš„æ‰€æœ‰wssæ¥å£éœ€ç”¨ä¸‹åˆ—æ–¹å¼è¿æ¥ï¼š

Base Urlï¼šwss://fstream.binance.com
è®¢é˜…å•ä¸€streamæ ¼å¼ä¸º /ws/<streamName>
ç»„åˆstreamsçš„URLæ ¼å¼ä¸º /stream?streams=/<streamName1>/<streamName2>/<streamName3>
è¿æ¥æ ·ä¾‹ï¼š
wss://fstream.binance.com/ws/bnbusdt@aggTrade
wss://fstream.binance.com/stream?streams=bnbusdt@aggTrade/btcusdt@markPrice
è®¢é˜…ç»„åˆstreamsæ—¶ï¼Œäº‹ä»¶payloadä¼šä»¥è¿™æ ·çš„æ ¼å¼å°è£… {"stream":"<streamName<","data":<rawPayload>}

streamåç§°ä¸­æ‰€æœ‰äº¤æ˜“å¯¹å‡ä¸ºå°å†™ã€‚

æ¯ä¸ªé“¾æ¥æœ‰æ•ˆæœŸä¸è¶…è¿‡24å°æ—¶ï¼Œè¯·å¦¥å–„å¤„ç†æ–­çº¿é‡è¿ã€‚

æœåŠ¡ç«¯æ¯3åˆ†é’Ÿä¼šå‘é€pingå¸§ï¼Œå®¢æˆ·ç«¯åº”å½“åœ¨10åˆ†é’Ÿå†…å›å¤pongå¸§ï¼Œå¦åˆ™æœåŠ¡ç«¯ä¼šä¸»åŠ¨æ–­å¼€é“¾æ¥ã€‚å…è®¸å®¢æˆ·ç«¯å‘é€ä¸æˆå¯¹çš„pongå¸§(å³å®¢æˆ·ç«¯å¯ä»¥ä»¥é«˜äº15åˆ†é’Ÿæ¯æ¬¡çš„é¢‘ç‡å‘é€pongå¸§ä¿æŒé“¾æ¥)ã€‚

WebsocketæœåŠ¡å™¨æ¯ç§’æœ€å¤šæ¥å—10ä¸ªè®¢é˜…æ¶ˆæ¯ã€‚

å¦‚æœç”¨æˆ·å‘é€çš„æ¶ˆæ¯è¶…è¿‡é™åˆ¶ï¼Œè¿æ¥ä¼šè¢«æ–­å¼€è¿æ¥ã€‚åå¤è¢«æ–­å¼€è¿æ¥çš„IPæœ‰å¯èƒ½è¢«æœåŠ¡å™¨å±è”½ã€‚

å•ä¸ªè¿æ¥æœ€å¤šå¯ä»¥è®¢é˜… 1024 ä¸ªStreamsã€‚

è¿ç»­åˆçº¦Kçº¿
æ•°æ®æµæè¿°
Kçº¿streamé€ç§’æ¨é€æ‰€è¯·æ±‚çš„Kçº¿ç§ç±»(æœ€æ–°ä¸€æ ¹Kçº¿)çš„æ›´æ–°ã€‚

åˆçº¦ç±»å‹:

perpetual æ°¸ç»­åˆçº¦
current_quarter å½“å­£äº¤å‰²åˆçº¦
next_quarter æ¬¡å­£äº¤å‰²åˆçº¦
è®¢é˜…Klineéœ€è¦æä¾›é—´éš”å‚æ•°,æœ€çŸ­ä¸ºåˆ†é’Ÿçº¿,æœ€é•¿ä¸ºæœˆçº¿ã€‚æ”¯æŒä»¥ä¸‹é—´éš”:

s -> ç§’; m -> åˆ†é’Ÿ; h -> å°æ—¶; d -> å¤©; w -> å‘¨; M -> æœˆ

1s
1m
3m
5m
15m
30m
1h
2h
4h
6h
8h
12h
1d
3d
1w
1M
Stream Name
<pair>_<contractType>@continuousKline_<interval>

æ›´æ–°é€Ÿåº¦
250ms

å“åº”ç¤ºä¾‹
{
  "e":"continuous_kline",	// äº‹ä»¶ç±»å‹
  "E":1607443058651,		// äº‹ä»¶æ—¶é—´
  "ps":"BTCUSDT",			// æ ‡çš„äº¤æ˜“å¯¹
  "ct":"PERPETUAL",			// åˆçº¦ç±»å‹ 
  "k":{
    "t":1607443020000,		// è¿™æ ¹Kçº¿çš„èµ·å§‹æ—¶é—´
    "T":1607443079999,		// è¿™æ ¹Kçº¿çš„ç»“æŸæ—¶é—´
    "i":"1m",				// Kçº¿é—´éš”
    "f":116467658886,		// è¿™æ ¹Kçº¿æœŸé—´ç¬¬ä¸€ç¬”æ›´æ–°ID
    "L":116468012423,		// è¿™æ ¹Kçº¿æœŸé—´æœ«ä¸€ç¬”æ›´æ–°ID
    "o":"18787.00",			// è¿™æ ¹Kçº¿æœŸé—´ç¬¬ä¸€ç¬”æˆäº¤ä»·
    "c":"18804.04",			// è¿™æ ¹Kçº¿æœŸé—´æœ«ä¸€ç¬”æˆäº¤ä»·
    "h":"18804.04",			// è¿™æ ¹Kçº¿æœŸé—´æœ€é«˜æˆäº¤ä»·
    "l":"18786.54",			// è¿™æ ¹Kçº¿æœŸé—´æœ€ä½æˆäº¤ä»·
    "v":"197.664",			// è¿™æ ¹Kçº¿æœŸé—´æˆäº¤é‡
    "n":543,				// è¿™æ ¹Kçº¿æœŸé—´æˆäº¤ç¬”æ•°
    "x":false,				// è¿™æ ¹Kçº¿æ˜¯å¦å®Œç»“(æ˜¯å¦å·²ç»å¼€å§‹ä¸‹ä¸€æ ¹Kçº¿)
    "q":"3715253.19494",	// è¿™æ ¹Kçº¿æœŸé—´æˆäº¤é¢
    "V":"184.769",			// ä¸»åŠ¨ä¹°å…¥çš„æˆäº¤é‡
    "Q":"3472925.84746",	// ä¸»åŠ¨ä¹°å…¥çš„æˆäº¤é¢
    "B":"0"					// å¿½ç•¥æ­¤å‚æ•°
  }
}

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
ä»¥ä¸‹æ˜¯æµ‹è¯•é€šè¿‡çš„åŠ¨æ€æ·»åŠ è®¢é˜…å“ç§çš„pythonä»£ç ï¼Œä¾›ä½ å‚è€ƒ
# test_ws_pressure.py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import websocket
import json
import ssl
import time
import threading
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

# --- å±è”½ REST API è¯·æ±‚æ—¶çš„å®‰å…¨è­¦å‘Š ---
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# --- å…¨å±€å˜é‡å’Œé…ç½® ---
# ä½¿ç”¨ /ws ç«¯ç‚¹ï¼Œé€‚ç”¨äºè¿æ¥åé€šè¿‡å‘é€JSONæ¶ˆæ¯æ¥åŠ¨æ€è®¢é˜…/é€€è®¢çš„åœºæ™¯
WEBSOCKET_URL = "wss://fstream.mokexapp.info/ws"
ULTIMATE_HEADERS = {
    'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Binance/1.54.19 Chrome/128.0.6613.186 Electron/32.3.0 Safari/537.36 (electron 1.54.19)',
    'mclient-x-tag': 'tfph2mpTPAuwxbiMHoQc'
}
KLINE_INTERVAL = "1m" # Kçº¿é—´éš” (e.g., "1s", "1m", "5m", "1h")
SUBSCRIPTION_BATCH_SIZE = 50 # æ¯æ¬¡æ‰¹é‡è®¢é˜…çš„æ•°é‡

# --- è¿½è¸ªè®¢é˜…çŠ¶æ€å’Œæ•°æ®æµçš„å…¨å±€å˜é‡ ---
subscription_id_counter = 1
successful_subscriptions = 0
failed_subscriptions = 0
total_symbols_to_subscribe = 0
kline_update_counter = 0 # Kçº¿æ›´æ–°è®¡æ•°å™¨
# ç”¨äºæ˜ å°„è¯·æ±‚IDå’Œè¯¥è¯·æ±‚åŒ…å«çš„å“ç§æ•°
PENDING_REQUESTS = {}


def fetch_all_usdt_perpetual_symbols():
    """è·å–æ‰€æœ‰ 'TRADING'çŠ¶æ€çš„ USDT æ°¸ç»­åˆçº¦äº¤æ˜“å¯¹åˆ—è¡¨ã€‚"""
    print("----- æ­£åœ¨è·å–æ‰€æœ‰å¯ç”¨çš„äº¤æ˜“å¯¹... -----")
    url = "https://www.mokexapp.info/fapi/v1/exchangeInfo?showall=true"
    try:
        response = requests.get(url, headers=ULTIMATE_HEADERS, timeout=15, verify=False)
        response.raise_for_status()
        data = response.json()
        all_symbols_data = data.get('symbols', [])

        filtered_symbols = [
            s['symbol'] for s in all_symbols_data
            if s.get('status') == 'TRADING'
            and s.get('contractType') == 'PERPETUAL'
            and s.get('symbol', '').endswith('USDT')
        ]
        
        print(f"âœ… æˆåŠŸè·å–åˆ° {len(filtered_symbols)} ä¸ªç¬¦åˆæ¡ä»¶çš„äº¤æ˜“å¯¹ã€‚")
        return [s.lower() for s in filtered_symbols]
        
    except Exception as e:
        print(f"âŒ è·å–äº¤æ˜“å¯¹åˆ—è¡¨å¤±è´¥: {e}")
        return []


def subscribe_symbols_gradually(ws, symbols):
    """åœ¨ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ä¸­è¿è¡Œï¼Œæ‰¹é‡è®¢é˜…æ‰€æœ‰äº¤æ˜“å¯¹çš„è¿ç»­Kçº¿ï¼Œå¹¶å®šæœŸäº¤å‰éªŒè¯ã€‚"""
    global subscription_id_counter
    global total_symbols_to_subscribe
    
    total_symbols_to_subscribe = len(symbols)
    print(f"\n--- è®¢é˜…çº¿ç¨‹å·²å¯åŠ¨ï¼Œå°†æ¯éš” 0.5 ç§’æ‰¹é‡æ·»åŠ  {SUBSCRIPTION_BATCH_SIZE} ä¸ªã€{KLINE_INTERVAL} è¿ç»­Kçº¿ã€‘è®¢é˜…... ---")

    symbols_sent_count = 0
    for i in range(0, len(symbols), SUBSCRIPTION_BATCH_SIZE):
        if not ws.sock or not ws.sock.connected:
            print("--- è®¢é˜…çº¿ç¨‹å‘ç°è¿æ¥å·²æ–­å¼€ï¼Œåœæ­¢è®¢é˜…ã€‚ ---")
            break

        # 1. è·å–å½“å‰æ‰¹æ¬¡çš„å“ç§
        batch_symbols = symbols[i:i + SUBSCRIPTION_BATCH_SIZE]
        # æ„å»º continuousKline çš„ stream name
        stream_names = [f"{symbol}_perpetual@continuousKline_{KLINE_INTERVAL}" for symbol in batch_symbols]
        current_batch_size = len(stream_names)

        # 2. æ„å»ºæ‰¹é‡è®¢é˜…è¯·æ±‚
        req_id = subscription_id_counter
        subscribe_message = {
            "method": "SUBSCRIBE",
            "params": stream_names,
            "id": req_id
        }
        
        try:
            # å‘é€è¯·æ±‚å‰ï¼Œè®°å½•IDå’Œæ‰¹æ¬¡å¤§å°
            PENDING_REQUESTS[req_id] = current_batch_size
            ws.send(json.dumps(subscribe_message))
            print(f"[{symbols_sent_count + 1}-{symbols_sent_count + current_batch_size}/{total_symbols_to_subscribe}] â¬†ï¸ å·²å‘é€æ‰¹é‡è®¢é˜…è¯·æ±‚ (ID: {req_id}, {current_batch_size}ä¸ª)")
            
            last_sent_count = symbols_sent_count
            symbols_sent_count += current_batch_size

            # 3. æ¯å‘é€50ä¸ªè®¢é˜…åï¼Œè¿›è¡Œä¸€æ¬¡äº¤å‰éªŒè¯
            if last_sent_count // 50 < symbols_sent_count // 50:
                list_req_id = req_id + 50000
                list_message = { "method": "LIST_SUBSCRIPTIONS", "id": list_req_id }
                ws.send(json.dumps(list_message))
                print(f"--- â„¹ï¸  å·²å‘é€ç¬¬ {symbols_sent_count // 50} æ¬¡äº¤å‰éªŒè¯è¯·æ±‚ (ID: {list_req_id}) ---")

            subscription_id_counter += 1
            # ã€é‡è¦ã€‘éµå®ˆAPIé€Ÿç‡é™åˆ¶ï¼šæ¯ç§’æœ€å¤š10æ¡è®¢é˜…/ç®¡ç†æ¶ˆæ¯ã€‚
            # 0.5ç§’çš„é—´éš”æ„å‘³ç€æ¯ç§’å‘é€2æ¡æ¶ˆæ¯ï¼Œåœ¨å®‰å…¨èŒƒå›´å†…ã€‚
            time.sleep(0.5)

        except websocket.WebSocketConnectionClosedException:
            print("--- åœ¨å‘é€è®¢é˜…æ—¶å‘ç°è¿æ¥å·²å…³é—­ï¼Œè®¢é˜…çº¿ç¨‹ç»ˆæ­¢ã€‚ ---")
            # æ¸…ç†åˆšæ‰æœªæˆåŠŸçš„è¯·æ±‚è®°å½•
            PENDING_REQUESTS.pop(req_id, None)
            break
            
    print("--- æ‰€æœ‰è®¢é˜…è¯·æ±‚å·²å‘é€å®Œæ¯•ã€‚ ---")


def on_message(ws, message):
    """å¤„ç†æ”¶åˆ°çš„æ¶ˆæ¯ï¼ŒåŒ…æ‹¬æ™®é€šæ•°æ®ã€æˆåŠŸ/å¤±è´¥å“åº”å’Œäº¤å‰éªŒè¯å“åº”ã€‚"""
    global successful_subscriptions
    global failed_subscriptions
    global kline_update_counter
    data = json.loads(message)

    # å¤„ç†Kçº¿æ•°æ®æµ
    if data.get('e') == 'continuous_kline':
        kline_update_counter += 1
        # ä¸ºäº†é¿å…åˆ·å±ï¼Œå¯ä»¥åªåœ¨ç‰¹å®šæ¡ä»¶ä¸‹æ‰“å°
        if kline_update_counter % 1000 == 1:
            print(f"ğŸ”„ (ç¤ºä¾‹) æ”¶åˆ°Kçº¿æ›´æ–°: {data['ps']} - {data['k']['i']} - Close: {data['k']['c']}. (æ€»è®¡: {kline_update_counter})")
        return

    resp_id = data.get('id')

    # æ£€æŸ¥æ˜¯å¦æ˜¯å“åº”æ¶ˆæ¯
    if 'result' in data:
        # å¤„ç† LIST_SUBSCRIPTIONS çš„å“åº”
        if isinstance(data['result'], list):
            server_sub_count = len(data['result'])
            print("\n--------------------")
            print(f"ğŸ“Š äº¤å‰éªŒè¯ç»“æœ (ID: {resp_id}):")
            print(f"   - æœ¬åœ°æˆåŠŸç¡®è®¤æ•°: {successful_subscriptions}")
            print(f"   - æœåŠ¡å™¨è¿”å›è®¢é˜…æ•°: {server_sub_count}")
            if successful_subscriptions != server_sub_count:
                print(f"   - âš ï¸ æ³¨æ„ï¼šä¸¤è€…æ•°é‡ä¸åŒ¹é…ï¼å¯èƒ½å­˜åœ¨é™é»˜å¤±è´¥ã€‚")
            else:
                print(f"   - âœ… ä¸¤è€…æ•°é‡ä¸€è‡´ã€‚")
            print("--------------------\n")
        # å¤„ç† SUBSCRIBE/UNSUBSCRIBE çš„æˆåŠŸå“åº”
        elif data['result'] is None and resp_id in PENDING_REQUESTS:
            batch_size = PENDING_REQUESTS.pop(resp_id)
            successful_subscriptions += batch_size
            print(f"âœ… æ‰¹é‡è®¢é˜…æˆåŠŸç¡®è®¤ (ID: {resp_id}, {batch_size}ä¸ª)! å½“å‰æˆåŠŸæ€»æ•°: {successful_subscriptions}")
        return

    if 'error' in data and resp_id in PENDING_REQUESTS:
        batch_size = PENDING_REQUESTS.pop(resp_id)
        failed_subscriptions += batch_size
        error_info = data['error']
        error_code = error_info.get('code', 'N/A')
        error_msg = error_info.get('msg', 'No message')
        print(f"âŒ æ‰¹é‡è®¢é˜…å¤±è´¥ (ID: {resp_id}, {batch_size}ä¸ª)! Code: {error_code}, Msg: '{error_msg}'. å½“å‰å¤±è´¥æ€»æ•°: {failed_subscriptions}")
        return

def on_error(ws, error):
    print(f"--- WebSocketåº•å±‚é”™è¯¯: {error} ---")

def on_close(ws, close_status_code, close_msg):
    print("\n--- WebSocket è¿æ¥å·²å…³é—­ ---")
    print(f"çŠ¶æ€ç : {close_status_code}, åŸå› : {close_msg}")
    print("--- æµ‹è¯•æ‘˜è¦ ---")
    print(f"æ€»è®¡å°è¯•è®¢é˜…çš„äº¤æ˜“å¯¹æ•°é‡: {total_symbols_to_subscribe}")
    print(f"åœ¨æ–­å¼€å‰æœ€åä¸€ä¸ªå‘é€çš„è¯·æ±‚ID: {subscription_id_counter - 1}")
    print(f"âœ… ç¡®è®¤æˆåŠŸçš„å“ç§æ€»æ•°: {successful_subscriptions}")
    print(f"âŒ ç¡®è®¤å¤±è´¥çš„å“ç§æ€»æ•°: {failed_subscriptions}")
    print(f"ğŸ“ˆ æœŸé—´å…±æ”¶åˆ°Kçº¿æ›´æ–°æ•°é‡: {kline_update_counter}")
    print("----------------")

def on_open(ws):
    print("--- WebSocket è¿æ¥æˆåŠŸ ---")
    all_symbols = fetch_all_usdt_perpetual_symbols()
    if not all_symbols:
        print("æ²¡æœ‰è·å–åˆ°äº¤æ˜“å¯¹ï¼Œæµ‹è¯•æ— æ³•è¿›è¡Œã€‚å…³é—­è¿æ¥ã€‚")
        ws.close()
        return
    subscription_thread = threading.Thread(target=subscribe_symbols_gradually, args=(ws, all_symbols))
    subscription_thread.daemon = True
    subscription_thread.start()

if __name__ == "__main__":
    print("--- WebSocket å‹åŠ›æµ‹è¯•å¯åŠ¨ ---")
    ws_app = websocket.WebSocketApp(WEBSOCKET_URL,
                                  on_open=on_open,
                                  on_message=on_message,
                                  on_error=on_error,
                                  on_close=on_close)
    ws_app.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
]]>
</file>
<file path="src/client/å¿«æ·é”®_init.ts">
<![CDATA[
import { Keycode } from "../tx_server/æ—§çš„__lib/é€šç”¨/KeyCode"
import { å…¨å±€_____State } from "./å…¨å±€_____State"
import { Kçº¿_å‘¨æœŸlist } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/Kçº¿__å‚æ•°"
import React from "react"
import { æé†’server__Client } from "../tx_server/æé†’server__Client"
import { S____________________S } from "./S____________________S"




export const å¿«æ·é”®_init = () => {

    let isDownDic: { [key: string]: boolean } = {} //keydownä¼šè§¦å‘å¤šæ¬¡ï¼Ÿï¼Ÿï¼Ÿ
    //æŒ‰é”®
    window.addEventListener('keydown', ee => {
        const code = ee.code as Keycode

        //ç¼–è¾‘ä¸­
        //if (e.target?.constructor !== HTMLCanvasElement) return
        if (document.activeElement?.constructor === HTMLInputElement) return


        if (isDownDic[code]) return
        isDownDic[code] = true
        if (code === 'ControlLeft') å…¨å±€_____State.controlLeftIsDown = true
        if (code === 'Space') å…¨å±€_____State.spaceIsDown = true

        if (code === 'KeyU') {
            å…¨å±€_____State.å¼€å…³.ä»“ä½ç”»çº¿ = !å…¨å±€_____State.å¼€å…³.ä»“ä½ç”»çº¿
        }
        else if (code === 'KeyO') {
            S____________________S.Kçº¿è¡¥é½ = !S____________________S.Kçº¿è¡¥é½
        }

        //æŒ‡æ ‡
        else if (code === 'KeyJ') {
            å…¨å±€_____State.å¼€å…³.å‡çº¿ = !å…¨å±€_____State.å¼€å…³.å‡çº¿
        }



        //ArrowLeft ArrowRight
        if (code === 'ArrowLeft') {
            å…¨å±€_____State.æ”¾å¤§ç¼©å°å¹³ç§».left()
        }

        if (code === 'ArrowRight') {
            å…¨å±€_____State.æ”¾å¤§ç¼©å°å¹³ç§».right()
        }

        if (code === 'Backquote') {
            å…¨å±€_____State.å½“å‰å‘¨æœŸindex = -1
        }

        //1 - 4
        if (['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5', 'Digit6', 'Digit7', 'Digit8', 'Digit9'].some(v => code === v)) {
            const index = Number(code.slice(5)) - 1

            if (index < Kçº¿_å‘¨æœŸlist.length)
                å…¨å±€_____State.å½“å‰å‘¨æœŸindex = index
        }

        if (code === 'PageDown' || code === 'BracketRight') {
            å…¨å±€_____State.pageDown()
        }
        //
        if (code === 'PageUp' || code === 'BracketLeft') {
            å…¨å±€_____State.pageUp()
        }


        if (code === 'KeyF') {
            å…¨å±€_____State.å…¨å±index = å…¨å±€_____State.å…¨å±index >= 0 ? -1 : å…¨å±€_____State.äº¤æ˜“å“ç§.findIndex(v => v.chartBox.hasåå­—å…‰æ ‡)
            APPUIRefresh()
            window.dispatchEvent(new Event('resize'))
        }

        if (code === 'KeyG') {
            å…¨å±€_____State.æ˜¾ç¤ºå·¦è¾¹ = !å…¨å±€_____State.æ˜¾ç¤ºå·¦è¾¹
            APPUIRefresh()
            window.dispatchEvent(new Event('resize'))
        }

        if (code === 'KeyZ') {
            const symbol = å…¨å±€_____State.äº¤æ˜“å“ç§[0].baseSymbol.info.symbol
            if (æé†’server__Client.realDB.mutableData.state[symbol]?.isè‡ªé€‰ === true) {
                æé†’server__Client.func.deleteè‡ªé€‰({
                    symbol,
                })
            } else {
                æé†’server__Client.func.addè‡ªé€‰({
                    symbol,
                })
            }
        }


    })



    window.addEventListener('keyup', ee => {
        const code = ee.code as Keycode

        isDownDic[code] = false
        if (code === 'ControlLeft') å…¨å±€_____State.controlLeftIsDown = false
        if (code === 'Space') å…¨å±€_____State.spaceIsDown = false



    })
}



export let APPUIRefresh = () => { }


// APPUIRefresh æ˜¯å˜é‡ ä¸æ˜¯ å¸¸é‡
// setInterval(APPUIRefresh, 1000)
setInterval(() => APPUIRefresh(), 1000)


export const useRefresh = () => {
    let [s, setS] = React.useState(1)
    APPUIRefresh = () => {
        setS(s + 1)
    }
}
]]>
</file>
<file path="src/client/å…¨å±€_____State.ts">
<![CDATA[
 import { kl_client } from "../kl_server/kl_client"
// import { debounce } from "lodash"

import { BaseSymbol } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/BaseSymbol"
import { getBaseSymbol } from "./getBaseSymbol"
import { ChartBox } from "./ChartBox"
import { æ”¾å¤§ç¼©å°å¹³ç§» } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/æ”¾å¤§ç¼©å°å¹³ç§»"
import { drawå•å“ç§Kçº¿ } from "./drawå•å“ç§Kçº¿"
import { S____________________S } from "./S____________________S"
import { drawæˆäº¤é‡ } from "./drawæˆäº¤é‡"
import { APPå‚æ•° } from "../______________config/APPå‚æ•°"

export interface SymbolData {
    symbol: string;
    data: {
        _15åˆ†é’Ÿæ¶¨å¹…: number;
        _2å°æ—¶æ¶¨å¹…: number;
        _1å¤©æ¶¨å¹…: number;
        _10ç§’æˆäº¤é¢: number;
        _30ç§’æˆäº¤é¢: number;
        _60ç§’æˆäº¤é¢: number;
        _5åˆ†é’Ÿæˆäº¤é¢: number;
        _15åˆ†é’Ÿæˆäº¤é¢: number;
        _1å°æ—¶æˆäº¤é¢: number;
        _4å°æ—¶æˆäº¤é¢: number;
        _1å¤©æˆäº¤é¢: number;
        _7å¤©æˆäº¤é¢: number;
    };
}

let chartDic = {} as { [id: string]: ChartBox }
export const getChart = (id: string, drawFunc: (cb: ChartBox) => void) => {
    if (chartDic[id] === undefined) {
        chartDic[id] = new ChartBox(drawFunc)
    }
    return chartDic[id]
}

export const å…¨å±€_____State = new (class {

    // --- æ ¸å¿ƒæ”¹åŠ¨ï¼šæ‹¦æˆªçŠ¶æ€å˜æ›´ï¼Œå¹¶è§¦å‘ç½‘ç»œåŒæ­¥ ---

    // é˜²æŠ–åŒæ­¥å‡½æ•°: é¿å…åœ¨çŸ­æ—¶é—´å†…ï¼ˆå¦‚ removeAll + addï¼‰å¤šæ¬¡è§¦å‘ç½‘ç»œè¯·æ±‚ã€‚
    // åªåœ¨æœ€åä¸€æ¬¡å˜æ›´åçš„ 100ms è§¦å‘ä¸€æ¬¡æœ€ç»ˆåŒæ­¥ã€‚
    // private debouncedSync = debounce(() => {
    //     const currentSymbols = this.äº¤æ˜“å“ç§.map(v => v.baseSymbol.info.symbol);
    //     console.log(`[State Sync] Debounced sync triggered. Pinning ${currentSymbols.length} symbols.`, currentSymbols);
    //     kl_client.updatePinnedSymbols(currentSymbols);
    // }, 100, { leading: false, trailing: true });

    // ç§æœ‰é€šçŸ¥æ–¹æ³•: ä»»ä½•ä¼šæ”¹å˜ `äº¤æ˜“å“ç§` æ•°ç»„çš„æ–¹æ³•éƒ½åº”è¯¥è°ƒç”¨å®ƒã€‚
    private notifyChanges() {
        //this.debouncedSync();
    }

    pageDown() {
        if (this.å…¨å±index !== -1) {
            this.å…¨å±index = this.å…¨å±index === this.äº¤æ˜“å“ç§.length - 1 ? 0 : this.å…¨å±index + 1
        }
    }
    pageUp() {
        if (this.å…¨å±index !== -1) {
            this.å…¨å±index = this.å…¨å±index === 0 ? this.äº¤æ˜“å“ç§.length - 1 : this.å…¨å±index - 1
        }
    }

    controlLeftIsDown = false
    spaceIsDown = false

    å½“å‰å‘¨æœŸindex = 1
    _å…¨å±index = -1 //-1  0 1 2 3 4

    get å…¨å±index() {
        return this._å…¨å±index
    }

    set å…¨å±index(n: number) {
        this._å…¨å±index = n
        S____________________S.isFullScreen = n >= 0
    }
    æ˜¾ç¤ºå·¦è¾¹ = true

    å¼€å…³ = {
        ä»“ä½ç”»çº¿: true,
        å‡çº¿: false,
    }
    æ”¾å¤§ç¼©å°å¹³ç§» = new æ”¾å¤§ç¼©å°å¹³ç§»()

    // æ³¨æ„ï¼šè¿™é‡Œçš„åˆå§‹åŒ–æ˜¯åŸºäºåº”ç”¨åŠ è½½æ—¶çš„URLå‚æ•°ï¼Œä½†useEffectä¸­ä¼šæ¸…ç©ºå¹¶é‡æ–°è®¾ç½®
    äº¤æ˜“å“ç§ = APPå‚æ•°.symbolList.split('_').map(symbol => {
        return {
            baseSymbol: getBaseSymbol(symbol),
            chartBox: getChart(
                symbol,
                drawå•å“ç§Kçº¿(getBaseSymbol(symbol), () => this.å½“å‰å‘¨æœŸindex),
            ),
            chartBoxVOL: getChart(
                `${symbol}/VOL`,
                drawæˆäº¤é‡(getBaseSymbol(symbol), () => this.å½“å‰å‘¨æœŸindex),
            ),
        } as {
            baseSymbol: BaseSymbol
            chartBox: ChartBox
            chartBoxVOL: ChartBox
        }
    })

    private _sortedTwoHourChange: Array<{ symbol: string, value: number }> = []

    updateSortedTwoHourChange(data: Array<{ symbol: string, value: number }>) {
        this._sortedTwoHourChange = data
    }
    åŠ¨æ€äº¤æ˜“å“ç§ = this._sortedTwoHourChange.map(symbol => {
        return {
            baseSymbol: getBaseSymbol(symbol.symbol),
            chartBox: getChart(
                symbol.symbol,
                drawå•å“ç§Kçº¿(getBaseSymbol(symbol.symbol), () => this.å½“å‰å‘¨æœŸindex),
            ),
            chartBoxVOL: getChart(
                `${symbol.symbol}/VOL`,
                drawæˆäº¤é‡(getBaseSymbol(symbol.symbol), () => this.å½“å‰å‘¨æœŸindex),
            ),
        } as {
            baseSymbol: BaseSymbol
            chartBox: ChartBox
            chartBoxVOL: ChartBox
        }
    })

    __arr: SymbolData[] | null = null;

    iså¤šå›¾() {
        return APPå‚æ•°.symbolList.split('_').length > 1
    }

    set_å•å“ç§_æ—¥çº¿_å’Œ_å½“å‰å‘¨æœŸ(symbol: string) {
        console.log(`[State] åˆ‡æ¢å•å“ç§è‡³ ${symbol}, å‘èµ·Kçº¿æ•°æ®è¯·æ±‚...`);
        kl_client.addSymbolKline([symbol]);
        this.å…¨å±index = -1
        this.äº¤æ˜“å“ç§ = [
            {
                baseSymbol: getBaseSymbol(symbol),
                chartBox: getChart(
                    symbol + '__4',
                    drawå•å“ç§Kçº¿(getBaseSymbol(symbol), () => 4),
                ),
                chartBoxVOL: getChart(
                    symbol + '__4/VOL',
                    drawæˆäº¤é‡(getBaseSymbol(symbol), () => 4),
                ),
            },
            {
                baseSymbol: getBaseSymbol(symbol),
                chartBox: getChart(
                    symbol,
                    drawå•å“ç§Kçº¿(getBaseSymbol(symbol), () => this.å½“å‰å‘¨æœŸindex),
                ),
                chartBoxVOL: getChart(
                    symbol + '/VOL',
                    drawæˆäº¤é‡(getBaseSymbol(symbol), () => this.å½“å‰å‘¨æœŸindex),
                ),
            },
        ]
        this.notifyChanges(); // <-- é€šçŸ¥å˜æ›´
    }

    addäº¤æ˜“å“ç§(symbol: string) {
        this.äº¤æ˜“å“ç§.push({
            baseSymbol: getBaseSymbol(symbol),
            chartBox: getChart(
                symbol,
                drawå•å“ç§Kçº¿(getBaseSymbol(symbol), () => this.å½“å‰å‘¨æœŸindex)
            ),
            chartBoxVOL: getChart(
                symbol + '/VOL',
                drawæˆäº¤é‡(getBaseSymbol(symbol), () => this.å½“å‰å‘¨æœŸindex)
            )
        })
        this.notifyChanges(); // <-- é€šçŸ¥å˜æ›´
    }

    removeäº¤æ˜“å“ç§(index: number) {
        if (index >= 0 && index < this.äº¤æ˜“å“ç§.length) {
            const symbol = this.äº¤æ˜“å“ç§[index].baseSymbol.info.symbol;
            console.log(`    [å…¨å±€State.removeäº¤æ˜“å“ç§]: ç§»é™¤ ${symbol}`);
            this.äº¤æ˜“å“ç§.splice(index, 1)
            this.notifyChanges(); // <-- é€šçŸ¥å˜æ›´
        }
    }

    removeAllByIndexäº¤æ˜“å“ç§() {
        // åªæœ‰å½“æ•°ç»„ä¸ä¸ºç©ºæ—¶æ‰è¿›è¡Œæ“ä½œå’Œé€šçŸ¥ï¼Œé¿å…ä¸å¿…è¦çš„è§¦å‘
        if (this.äº¤æ˜“å“ç§.length > 0) {
            console.time('    [å…¨å±€State.removeAll] è€—æ—¶');
            this.äº¤æ˜“å“ç§ = []; // ç›´æ¥æ¸…ç©ºæ•°ç»„æ›´é«˜æ•ˆ
            this.notifyChanges(); // <-- é€šçŸ¥å˜æ›´ (åªé€šçŸ¥ä¸€æ¬¡)
            console.timeEnd('    [å…¨å±€State.removeAll] è€—æ—¶');
        }
    }

    æ‰“å°äº¤æ˜“å“ç§() {
        console.log('å½“å‰äº¤æ˜“å“ç§åˆ—è¡¨:')
        this.äº¤æ˜“å“ç§.forEach((å“ç§, index) => {
            console.log(`${index + 1}. ${å“ç§.baseSymbol.info.symbol}`)
        })
        console.log(`æ€»å…± ${this.äº¤æ˜“å“ç§.length} ä¸ªäº¤æ˜“å“ç§`)
    }

    getå½“å‰KLine(symbol: string) {
        return getBaseSymbol(symbol).getKLine(this.å½“å‰å‘¨æœŸindex)
    }

    get å½“å‰å“ç§() {
        return this.äº¤æ˜“å“ç§[this.å…¨å±index]
    }

})

declare global {
    interface Window {
        å…¨å±€_____State: typeof å…¨å±€_____State
    }
}

window.å…¨å±€_____State = å…¨å±€_____State
]]>
</file>
<file path="src/client/é¼ æ ‡æ“ä½œ_init.ts">
<![CDATA[
import { å…¨å±€_____State } from "./å…¨å±€_____State"
import { pixiExt } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/pixiExt"
import { S____________________S } from "./S____________________S"

export const é¼ æ ‡æ“ä½œ_func = () => {


    if (pixiExt.state.mouseIsOver === false) return []

    if (å…¨å±€_____State.å…¨å±index >= 0) {
        //äº¤æ˜“æ¨¡å¼ 
        if (å…¨å±€_____State.å½“å‰å“ç§.chartBox.hasåå­—å…‰æ ‡) {
            const åå­—å…‰æ ‡ä»·æ ¼ = å…¨å±€_____State.å½“å‰å“ç§.chartBox.åå­—å…‰æ ‡ä»·æ ¼

            if (å…¨å±€_____State.å½“å‰å“ç§.baseSymbol.info.symbol !== '') {
                const kline = å…¨å±€_____State.getå½“å‰KLine(å…¨å±€_____State.å½“å‰å“ç§.baseSymbol.info.symbol)

                if (kline.length > 0) {
                    const { close } = kline[kline.length - 1]
                    const isBuy = åå­—å…‰æ ‡ä»·æ ¼ < close
                    S____________________S.å½“å‰å³é”®äº¤æ˜“ = {
                        isBuy,
                        symbol: å…¨å±€_____State.å½“å‰å“ç§.baseSymbol.info.symbol,
                        price: åå­—å…‰æ ‡ä»·æ ¼
                    }
                    const bs = å…¨å±€_____State.å½“å‰å“ç§.baseSymbol
                    return bs.äº¤æ˜“.getå³é”®UI(åå­—å…‰æ ‡ä»·æ ¼)
                }
            }
        }

    }

    return []

}

]]>
</file>
<file path="src/client/BinanceSymbol.ts">
<![CDATA[
import { BaseSymbol } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/BaseSymbol"
import { binanceHTTP } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/binanceHTTP"
import { BinanceOrderType } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/binanceType"
import { APPå‚æ•° } from "../______________config/APPå‚æ•°"
import { getPrivateSubject } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/binanceSubject"
import { binanceæ æ†è¡¨, binanceé»˜è®¤æ æ† } from "../______________config/binanceæ æ†è¡¨"
import { toK } from "../tx_server/æ—§çš„__lib/é€šç”¨/toK"
import { ä»·æ ¼å…¶ä»– } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/ä»·æ ¼å…¶ä»–"
import { kl_client } from "../kl_server/kl_client"
import { symbolæ˜¾ç¤º } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/symbolæ˜¾ç¤ºé˜…è¯»"

const MT4OrderTypeIsBuy = (v: MT4OrderType) =>
    (v === 'Buy' || v === 'Buy Limit' || v === 'Buy Stop')

const MT4OrderTypeIsMarket = (v: MT4OrderType) =>
    (v === 'Buy' || v === 'Sell')


const sizeShow = (a: number, b?: number) => {
    if (b === undefined) {
        return ` ${a}`
    } else {
        return ` ${a}/${b}`
    }
}



export class BinanceSymbol extends BaseSymbol {

    getSymbol = () => this.info.symbol

    override getOrderBook() {
        return kl_client.getOrderBook(this.getSymbol())
    }


    // ç¼“å­˜Kçº¿å¯¹è±¡æ•°ç»„
    private klineCache: { [periodIndex: number]: KLine[] } = {};

    override getKLine(index: number): KLine[] {
        // 1. è·å–åº•å±‚çš„ã€åˆ—å¼å­˜å‚¨çš„Kçº¿æ•°æ®
        const symbol = this.getSymbol();
        const kl = kl_client.getKline(symbol, index);
        const dataLength = kl.data.close.length;

        // 2. å¤„ç†è¾¹ç¼˜æƒ…å†µï¼šå¦‚æœæ²¡æ•°æ®ï¼Œæ¸…ç©ºç¼“å­˜å¹¶è¿”å›ç©ºæ•°ç»„
        if (dataLength === 0) {
            delete this.klineCache[index];
            // æ·»åŠ æ—¥å¿—ï¼šæ˜ç¡®çŸ¥é“è·å–äº†ç©ºæ•°æ®
            //console.log(`[BinanceSymbol.getKLine] ğŸŸ¡ ${symbol}_${index}: No data found, returning empty array.`);
            return [];
        }

        const cachedData = this.klineCache[index];
        const lastTimestamp = Number(kl.data.timestamp[dataLength - 1]);

        // 3. ç¼“å­˜å¤±æ•ˆåˆ¤æ–­ï¼šå½“ç¼“å­˜ä¸å­˜åœ¨ï¼Œæˆ–Kçº¿æ•°é‡å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ‰§è¡Œå…¨é‡é‡å»º
        if (cachedData === undefined || cachedData.length !== dataLength) {
            console.log(`[BinanceSymbol.getKLine] ğŸŸ¢ ${symbol}_${index}: Rebuilding cache. Reason: Length mismatch (${cachedData?.length} vs ${dataLength}) or no cache.`);
            const newKlines: KLine[] = [];
            for (let i = 0; i < dataLength; i++) {
                newKlines.push({
                    timestamp: Number(kl.data.timestamp[i]),
                    open: kl.data.open[i],
                    high: kl.data.high[i],
                    low: kl.data.low[i],
                    close: kl.data.close[i],
                    volume: kl.data.æˆäº¤é¢[i],
                });
            }
            this.klineCache[index] = newKlines;
            return newKlines;
        }

        // 4. ç¼“å­˜æœ‰æ•ˆï¼Œè¿›è¡ŒåŸåœ°æ›´æ–° (in-place update)
        // è¿™ä¸ªæ“ä½œéå¸¸é«˜æ•ˆï¼Œå› ä¸ºå®ƒåªä¿®æ”¹ç°æœ‰å¯¹è±¡ï¼Œä¸åˆ›å»ºæ–°å¯¹è±¡æˆ–æ–°æ•°ç»„
        const lastCachedKline = cachedData[dataLength - 1];

        // å¦‚æœæœ€åä¸€æ ¹Kçº¿çš„æ—¶é—´æˆ³ä¹Ÿå˜äº†ï¼Œè¯´æ˜æ˜¯æ–°çš„ä¸€æ ¹Kçº¿ï¼Œä¹Ÿéœ€è¦é‡å»º
        if (lastCachedKline.timestamp !== lastTimestamp) {
            console.log(`[BinanceSymbol.getKLine] ğŸŸ¢ ${symbol}_${index}: Rebuilding cache. Reason: New bar detected.`);
            // é€»è¾‘åŒä¸Šï¼Œä¸ºäº†ä»£ç æ¸…æ™°ï¼Œè¿™é‡Œç›´æ¥å¤åˆ¶è¿‡æ¥ï¼Œä¹Ÿå¯ä»¥æŠ½æˆä¸€ä¸ªå‡½æ•°
             const newKlines: KLine[] = [];
            for (let i = 0; i < dataLength; i++) {
                newKlines.push({
                    timestamp: Number(kl.data.timestamp[i]),
                    open: kl.data.open[i],
                    high: kl.data.high[i],
                    low: kl.data.low[i],
                    close: kl.data.close[i],
                    volume: kl.data.æˆäº¤é¢[i],
                });
            }
            this.klineCache[index] = newKlines;
            return newKlines;
        }

        // ä»…ä»…æ˜¯æœ€åä¸€æ ¹Kçº¿çš„ä»·æ ¼åœ¨è·³åŠ¨
        lastCachedKline.open = kl.data.open[dataLength - 1];
        lastCachedKline.high = kl.data.high[dataLength - 1];
        lastCachedKline.low = kl.data.low[dataLength - 1];
        lastCachedKline.close = kl.data.close[dataLength - 1];
        lastCachedKline.volume = kl.data.æˆäº¤é¢[dataLength - 1];

        // 5. è¿”å›æ›´æ–°åçš„ç¼“å­˜æ•°ç»„
        return cachedData;
    }

    override getTimestamp(index: number) {
        return kl_client.getKline(this.getSymbol(), index).data.timestamp
    }

    override getHigh(index: number) {
        return kl_client.getKline(this.getSymbol(), index).data.high
    }

    override getLow(index: number) {
        return kl_client.getKline(this.getSymbol(), index).data.low
    }

    override getClose(index: number) {
        return kl_client.getKline(this.getSymbol(), index).data.close
    }

    override getVolume(index: number) {
        return kl_client.getKline(this.getSymbol(), index).data.æˆäº¤é¢
    }


    constructor(s: string) {

        const symbol = s

        super({
            symbol: s,
            name: symbolæ˜¾ç¤º(s),
            priceTick: 0.01,
        })

        setInterval(() => {
            this.info.priceTick = kl_client.getåˆçº¦info(this.getSymbol()).tickSize
        }, 1000)

        const b = getPrivateSubject().subscribe(v => {
            this.binance.ä»“ä½ = v.positionDic[symbol] || {
                å¤šä»“: {
                    price: 0,
                    size: 0,
                },
                ç©ºä»“: {
                    price: 0,
                    size: 0,
                },
            }
            this.binance.å§”æ‰˜ = v.orderDic[symbol] || {
                å¤šä»“: {} as {
                    [orderID: string]: BinanceOrderType
                },
                ç©ºä»“: {} as {
                    [orderID: string]: BinanceOrderType
                },
            }
            this.binance.æƒç›Š = v.USDT
        })

        this.destroy = () => {
            // a.unsubscribe()
            b.unsubscribe()
        }


        this.äº¤æ˜“.getæ¨ªçº¿UI = (isFullScreen: boolean) => {

            const æ˜¾ç¤ºä»·æ ¼ = (n: number) => isFullScreen ? n + ' ' : ''

            let retArr: {
                price: number
                ä¸Šä¸‹value?: number
                color: number
                str: string
                onClick: () => void
            }[] = []


            const getæŸç›Š = (sl: number, type: 'å¤šä»“' | 'ç©ºä»“') => {
                const { size } = this.binance.ä»“ä½[type]
                if (size === 0) return ''

                const å·®ä»· = Math.abs((this.getOrderBook().buy1 + this.getOrderBook().sell1) / 2 - sl)
                return '   -' + toK(å·®ä»· * size)
            }

            //ä»“ä½
            if (this.binance.ä»“ä½.å¤šä»“.size !== 0) {
                retArr.push({
                    price: this.binance.ä»“ä½.å¤šä»“.price,
                    color: APPå‚æ•°.theme.color.UP,
                    str: `${æ˜¾ç¤ºä»·æ ¼(this.binance.ä»“ä½.å¤šä»“.price)}Buy B ${toK(this.binance.ä»“ä½.å¤šä»“.size * this.binance.ä»“ä½.å¤šä»“.price)}`,
                    onClick: () => {
                        this.binance.TP('å¹³å¤š', 'market')
                    },
                })
            }

            if (this.binance.ä»“ä½.ç©ºä»“.size !== 0) {
                retArr.push({
                    price: this.binance.ä»“ä½.ç©ºä»“.price,
                    color: APPå‚æ•°.theme.color.DOWN,
                    str: `${æ˜¾ç¤ºä»·æ ¼(this.binance.ä»“ä½.ç©ºä»“.price)}Sell A ${toK(this.binance.ä»“ä½.ç©ºä»“.size * this.binance.ä»“ä½.ç©ºä»“.price)}`,
                    onClick: () => {
                        this.binance.TP('å¹³ç©º', 'market')
                    },
                })
            }


            //å§”æ‰˜
            for (const orderID in this.binance.å§”æ‰˜.å¤šä»“) {
                const item = this.binance.å§”æ‰˜.å¤šä»“[orderID]
                if (item.type === 'STOP_MARKET' && (item.status === 'NEW' || item.status === 'PARTIALLY_FILLED')) {
                    retArr.push({
                        price: item.price,
                        color: APPå‚æ•°.theme.color.STOP,
                        str: `${æ˜¾ç¤ºä»·æ ¼(item.price)}SL B` + getæŸç›Š(item.price, 'å¤šä»“'),
                        onClick: () => {
                            this.binance.cancelOrder({ orderID })
                        },
                    })
                }
                else if (item.type === 'çªç ´' && (item.status === 'NEW' || item.status === 'PARTIALLY_FILLED')) {
                    retArr.push({
                        price: item.price,
                        color: APPå‚æ•°.theme.color.UP,
                        str: `${æ˜¾ç¤ºä»·æ ¼(item.price)}Buy Stop B${sizeShow(item.size)}`,
                        onClick: () => {
                            this.binance.cancelOrder({ orderID })
                        },
                    })
                }
                else if (item.type === 'LIMIT' && (item.status === 'NEW' || item.status === 'PARTIALLY_FILLED')) {
                    retArr.push({
                        price: item.price,
                        color: item.iså¹³ä»“ ? APPå‚æ•°.theme.color.DOWN : APPå‚æ•°.theme.color.UP,
                        str: `${æ˜¾ç¤ºä»·æ ¼(item.price)}${item.iså¹³ä»“ ? 'TP B' : 'Buy Limit B'}${sizeShow(item.å·²æˆäº¤, item.size)}`,
                        onClick: () => {
                            this.binance.cancelOrder({ orderID })
                        },
                    })
                }
            }

            for (const orderID in this.binance.å§”æ‰˜.ç©ºä»“) {
                const item = this.binance.å§”æ‰˜.ç©ºä»“[orderID]
                if (item.type === 'STOP_MARKET' && (item.status === 'NEW' || item.status === 'PARTIALLY_FILLED')) {
                    retArr.push({
                        price: item.price,
                        color: APPå‚æ•°.theme.color.STOP,
                        str: `${æ˜¾ç¤ºä»·æ ¼(item.price)}SL A` + getæŸç›Š(item.price, 'ç©ºä»“'),
                        onClick: () => {
                            this.binance.cancelOrder({ orderID })
                        },
                    })
                }
                else if (item.type === 'çªç ´' && (item.status === 'NEW' || item.status === 'PARTIALLY_FILLED')) {
                    retArr.push({
                        price: item.price,
                        color: APPå‚æ•°.theme.color.DOWN,
                        str: `${æ˜¾ç¤ºä»·æ ¼(item.price)}Sell Stop A${sizeShow(item.size)}`,
                        onClick: () => {
                            this.binance.cancelOrder({ orderID })
                        },
                    })
                }
                else if (item.type === 'LIMIT' && (item.status === 'NEW' || item.status === 'PARTIALLY_FILLED')) {
                    retArr.push({
                        price: item.price,
                        color: item.iså¹³ä»“ ? APPå‚æ•°.theme.color.UP : APPå‚æ•°.theme.color.DOWN,
                        str: `${æ˜¾ç¤ºä»·æ ¼(item.price)}${item.iså¹³ä»“ ? 'TP A' : 'Sell Limit A'}${sizeShow(item.å·²æˆäº¤, item.size)}`,
                        onClick: () => {
                            this.binance.cancelOrder({ orderID })
                        },
                    })
                }
            }


            //æé†’
            retArr.push(...Object.entries(this.jgtx.getDic()).map(([priceStr, type]) => ({
                price: Number(priceStr),
                color: APPå‚æ•°.theme.color.STOP,
                str: `${type}${æ˜¾ç¤ºä»·æ ¼(Number(priceStr))}`,
                onClick: () => {
                    this.jgtx.delete(Number(priceStr))
                },
            })))

            return retArr
        }


        this.äº¤æ˜“.getå³é”®UI = price => {

            const åå­—å…‰æ ‡ä»·æ ¼ = price
            const kline = this.getKLine(0)
            const { close } = kline[kline.length - 1]
            const isBuy = åå­—å…‰æ ‡ä»·æ ¼ < close
            const çªç ´isBuy = !isBuy

            const arr = [
                isBuy ? 'Buy' : 'Sell',
                isBuy ? 'Buy Limit' : 'Sell Limit',
                çªç ´isBuy ? 'Buy Stop' : 'Sell Stop',
            ] as const


            const æ æ† = binanceæ æ†è¡¨[this.getSymbol()] || binanceé»˜è®¤æ æ†

            const å¼ æ•° = this.binance.æƒç›Š * æ æ†

            const stepSize = kl_client.getåˆçº¦info(this.getSymbol()).stepSize
            const å–æ•´ = (v: number) =>
                Number((Math.ceil(v / stepSize) * stepSize).toFixed(10))

            const é™ä»· = åå­—å…‰æ ‡ä»·æ ¼
            const å¸‚ä»· = (this.getOrderBook().buy1 + this.getOrderBook().sell1) / 2

            let sizeé™ä»· = å–æ•´(å¼ æ•° / é™ä»·)
            let sizeå¸‚ä»· = å–æ•´(å¼ æ•° / å¸‚ä»·)

            if (sizeé™ä»· < stepSize) sizeé™ä»· = stepSize
            if (sizeå¸‚ä»· < stepSize) sizeå¸‚ä»· = stepSize

            return [
                ...(arr.map((v, i) => ({
                    label: `${v} å¼ æ•°=${å¼ æ•°.toFixed(2)} size=${MT4OrderTypeIsMarket(v) ? sizeå¸‚ä»· : sizeé™ä»·} stepSize=${stepSize}`,
                    click: () => this.binance.ä¸‹å•({
                        orderType: v,
                        price: åå­—å…‰æ ‡ä»·æ ¼,
                        size: (MT4OrderTypeIsMarket(v) ? sizeå¸‚ä»· : sizeé™ä»·),
                    }),
                }))),
                {
                    type: 'separator'
                },
                {
                    label: `æé†’`,
                    click: () =>
                        this.jgtx.add(åå­—å…‰æ ‡ä»·æ ¼, åå­—å…‰æ ‡ä»·æ ¼ < close ? '<' : '>'),
                },
                {
                    type: 'separator'
                },
                {
                    label: `SL`,
                    click: () => this.binance.SL({
                        isBuy: çªç ´isBuy,
                        price: åå­—å…‰æ ‡ä»·æ ¼,
                    }),
                },
                {
                    label: `SL 10`,
                    click: () => this.binance.SL_10({
                        isBuy: çªç ´isBuy,
                        price: åå­—å…‰æ ‡ä»·æ ¼,
                    }),
                },
                ...(this.binance.ä»“ä½.ç©ºä»“.size !== 0 ? [{
                    label: 'TP A',
                    enabled: åå­—å…‰æ ‡ä»·æ ¼ < close,
                    click: () => this.binance.TP('å¹³ç©º', åå­—å…‰æ ‡ä»·æ ¼),
                }] : []),
                ...(this.binance.ä»“ä½.å¤šä»“.size !== 0 ? [{
                    label: 'TP B',
                    enabled: åå­—å…‰æ ‡ä»·æ ¼ > close,
                    click: () => this.binance.TP('å¹³å¤š', åå­—å…‰æ ‡ä»·æ ¼),
                }] : []),
            ]
        }

        this.äº¤æ˜“.getæƒç›ŠStr = () => this.binance.æƒç›Š.toFixed(2)
    }

    destroy = () => {

    }


    binance = {
        ä¸‹å•: (p: {
            orderType: MT4OrderType
            price: number
            size: number
        }) => {
            if (p.orderType === 'Buy' || p.orderType === 'Buy Limit' ||
                p.orderType === 'Sell' || p.orderType === 'Sell Limit'
            ) {
                binanceHTTP.newOrder({
                    isBuy: MT4OrderTypeIsBuy(p.orderType),
                    å¹³ä»“: false,
                    price: MT4OrderTypeIsMarket(p.orderType) ? 'market' : p.price,
                    size: p.size,
                    symbol: this.getSymbol(),
                })
            }
            else if (p.orderType === 'Buy Stop' || p.orderType === 'Sell Stop') {
                binanceHTTP.çªç ´({
                    isBuy: MT4OrderTypeIsBuy(p.orderType),
                    price: p.price,
                    size: p.size,
                    symbol: this.getSymbol(),
                })
            }
        },
        TP: (v: 'å¹³å¤š' | 'å¹³ç©º', price: number | 'market') => {
            if (v === 'å¹³å¤š' && this.binance.ä»“ä½.å¤šä»“.size !== 0) {
                binanceHTTP.newOrder({
                    isBuy: false,
                    å¹³ä»“: true,
                    price,
                    size: this.binance.ä»“ä½.å¤šä»“.size,
                    symbol: this.getSymbol(),
                })
            }
            else if (v === 'å¹³ç©º' && this.binance.ä»“ä½.ç©ºä»“.size !== 0) {
                binanceHTTP.newOrder({
                    isBuy: true,
                    å¹³ä»“: true,
                    price,
                    size: this.binance.ä»“ä½.ç©ºä»“.size,
                    symbol: this.getSymbol(),
                })
            }
        },
        SL: (p: {
            isBuy: boolean
            price: number
        }) => binanceHTTP.stopOrder({
            ...p,
            symbol: this.getSymbol(),
        }),
        SL_10: (p: {
            isBuy: boolean
            price: number
        }) => {
            const size = ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³round({
                priceTick: kl_client.getåˆçº¦info(this.getSymbol()).stepSize,
                price: this.binance.ä»“ä½[p.isBuy ? 'ç©ºä»“' : 'å¤šä»“'].size / 10,
            })

            for (let i = 0; i < 10; i++) {
                binanceHTTP.stopOrder({
                    isBuy: p.isBuy,

                    // price: ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³round({
                    //     priceTick: this.info.priceTick,
                    //     price: p.price + (p.isBuy ? -1 : 1) * (i * this.info.priceTick),
                    // }),
                    price: p.price,


                    symbol: this.getSymbol(),
                    size,
                })
            }
        },
        cancelOrder: (p: {
            orderID: string
        }) => binanceHTTP.cancelOrder({
            ...p,
            symbol: this.getSymbol(),
        }),
        æƒç›Š: 0,
        ä»“ä½: {
            å¤šä»“: {
                price: 0,
                size: 0,
            },
            ç©ºä»“: {
                price: 0,
                size: 0,
            },
        },
        å§”æ‰˜: {
            å¤šä»“: {} as {
                [orderID: string]: BinanceOrderType
            },
            ç©ºä»“: {} as {
                [orderID: string]: BinanceOrderType
            },
        },
    }

}
]]>
</file>
<file path="src/client/ChartBox.ts">
<![CDATA[
import { APPå‚æ•° } from "../______________config/APPå‚æ•°"
import { formatDate } from "../tx_server/æ—§çš„__lib/é€šç”¨/formatDate"
import { ä»·æ ¼å…¶ä»– } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/ä»·æ ¼å…¶ä»–"
import { pixiExt } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/pixiExt"
import { ChartBoxBase } from "./ChartBoxBase"
import { S____________________S } from "./S____________________S"
import { æˆäº¤é‡æ ¼å¼åŒ– } from "../tx_server/æ—§çš„__lib/é€šç”¨/æˆäº¤é‡æ ¼å¼åŒ–"
export class ChartBox extends ChartBoxBase {
    constructor(public drawFunc: (cb: ChartBox) => void) {
        super()
    }

    override ____draw() {
        this.drawFunc(this)
    }

    drawåæ ‡è½´(ä¸‡ = false) {
        this.chartG.lineStyle()
        this.chartG.beginFill(APPå‚æ•°.theme.chart.èƒŒæ™¯)
        this.chartG.drawRect(0, 0, this.chartWidth, this.chartHeight)
        this.chartG.endFill()

        //Temp
        if (this.viewBox.bottom === -Infinity) return

        const xx1 = ((this.viewBox.top - this.viewBox.bottom) / this.chartHeight) * 128 //æœ€å°é—´è·
        const TABLE = ä¸‡ ? [
            10000, 20000, 50000,
            100000, 200000, 500000,
            1000000, 2000000, 5000000,
            10000000, 20000000, 50000000,
            100000000, 200000000, 500000000,
            1000000000, 2000000000, 5000000000,
            10000000000, 20000000000, 50000000000,
            100000000000, 200000000000, 500000000000,
        ].map(v => v * this.baseData.priceTick)
            :
            [
                1, 2, 5,
                10, 20, 50,
                100, 200, 500,
                1000, 2000, 5000,
                10000, 20000, 50000,
                100000, 200000, 500000,
                1000000, 2000000, 5000000,
                10000000, 20000000, 50000000,
            ].map(v => v * this.baseData.priceTick)

        let xx2 = TABLE[0]
        for (let i = 0; i < TABLE.length; i++) {
            if (xx1 <= TABLE[i]) break
            xx2 = TABLE[i]
        }

        const bottom2 = this.toPrice(this.chartHeight)
        const top2 = this.toPrice(0)

        const bottom = Math.min(bottom2, top2)
        const top = Math.max(bottom2, top2)

        if (bottom === -Infinity || top === Infinity) return

        const arr: { value: number, y: number }[] = []
        for (let i = Math.floor(bottom / xx2 + 1) * xx2; i < top; i += xx2) {
            arr.push({ value: i, y: this.toY(i) })
        }


        const { chartG, chartå¤–é¢G } = this


        if (S____________________S.isFullScreen) {
            arr.forEach(({ y, value }) => {
                //å›¾è¡¨åˆ»åº¦
                chartG.lineStyle(1, APPå‚æ•°.theme.chart.ç½‘æ ¼æ¨ª)
                pixiExt.df.drawLines(chartG, [{ x: 0, y }, { x: this.chartWidth, y }])

                //å›¾è¡¨åˆ»åº¦æ•°å­—
                chartå¤–é¢G.lineStyle(1, APPå‚æ•°.theme.chart.ç½‘æ ¼æ¨ª_åˆ»åº¦)
                pixiExt.df.drawLines(chartå¤–é¢G, [{ x: this.chartWidth, y }, { x: this.chartWidth + 8, y }])

                //æ–‡å­—
                this.drawText({
                    fontSize: 20,
                    fill: 0x666666,//0xaaaaaa,
                    anchor: { x: 0, y: 0.5 }
                }, {
                    x: this.chartWidth + 15,
                    y,
                    text: ä¸‡ ? æˆäº¤é‡æ ¼å¼åŒ–(value) :
                        ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³æ ¼å¼åŒ–({
                            priceTick: this.baseData.priceTick,
                            price: value,
                        }),
                })
            })
        }
    }




    hasåå­—å…‰æ ‡ = false
    åå­—å…‰æ ‡ä»·æ ¼ = 0
    indexX = 0

    drawåå­—å…‰æ ‡(ä¸‡ = false) {

        const ä»·æ ¼é«˜äº®render = (p: { str: string, x: number, y: number, color?: number }) => {
            this.drawText({
                fontSize: 20,
                fill: p.color === undefined ? 0xffff00 : p.color,
                anchor: { x: 0, y: 0.5 }
            }, { x: p.x + 15, y: p.y, text: p.str })
        }

        const æ—¶é—´é«˜äº®render = (p: { str: string, x: number, y: number }) => {
            this.drawText({
                fontSize: 20,
                fill: 0xffff00,
                anchor: { x: 0.5, y: 0.5 }
            }, { x: p.x, y: p.y + this.CHART_BOTTOM_HEIGHT / 2, text: p.str }).w + 20
        }

        const åº•éƒ¨åå­—å…‰æ ‡æ˜¾ç¤º = (i: number) =>
            this.baseData.timestampArr[i] === undefined ?
                '' :
                formatDate(new Date(Number(this.baseData.timestampArr[i])), v => `${v.å¹´}/${v.æœˆ}/${v.æ—¥} ${v.æ—¶}:${v.åˆ†}`)

        if (S____________________S.å½“å‰å³é”®äº¤æ˜“) {
            const color = S____________________S.å½“å‰å³é”®äº¤æ˜“.isBuy ? APPå‚æ•°.theme.color.UP : APPå‚æ•°.theme.color.DOWN
            const y = this.toY(S____________________S.å½“å‰å³é”®äº¤æ˜“.price)

            this.åå­—å…‰æ ‡G.lineStyle(1, color)
            pixiExt.df.drawLines(this.åå­—å…‰æ ‡G, [{ x: 0, y }, { x: this.chartWidth, y }])


            const yStr = ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³æ ¼å¼åŒ–({
                priceTick: this.baseData.priceTick,
                price: S____________________S.å½“å‰å³é”®äº¤æ˜“.price,
            })

            ä»·æ ¼é«˜äº®render({
                str: yStr,
                x: this.chartWidth,
                y: y,
                color,
            })

        } else if (pixiExt.state.mouseIsOver) {
            const __x = pixiExt.state.mouseX - this.x
            const __y = pixiExt.state.mouseY - this.y

            this.indexX = Math.round(this.toIndex(__x))
            const x = this.toX(this.indexX)

            this.åå­—å…‰æ ‡ä»·æ ¼ = ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³round({ priceTick: this.baseData.priceTick, price: this.toPrice(__y) })
            const y = this.toY(this.åå­—å…‰æ ‡ä»·æ ¼)

            const xStr = åº•éƒ¨åå­—å…‰æ ‡æ˜¾ç¤º(this.indexX)
            const yStr = ä¸‡ ? æˆäº¤é‡æ ¼å¼åŒ–(this.åå­—å…‰æ ‡ä»·æ ¼)
                : ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³æ ¼å¼åŒ–({
                    priceTick: this.baseData.priceTick,
                    price: this.åå­—å…‰æ ‡ä»·æ ¼,
                })

            //


            this.hasåå­—å…‰æ ‡ = x >= 0 && x <= this.chartWidth && y >= 0 && y <= this.chartHeight


            if (x >= 0 && x <= this.chartWidth) {
                //æ¨ªçº¿ y < height
                this.åå­—å…‰æ ‡G.lineStyle(1, 0xffffff, 0.5)
                pixiExt.df.drawLines(this.åå­—å…‰æ ‡G, [{ x: 0, y }, { x: this.chartWidth, y }])

                if (S____________________S.isFullScreen && this.hasåå­—å…‰æ ‡) {
                    ä»·æ ¼é«˜äº®render({
                        str: yStr,
                        x: this.chartWidth,
                        y: y,
                    })
                }

                //ç«–çº¿ x < width
                this.åå­—å…‰æ ‡G.lineStyle(1, 0xffffff, 0.5)
                pixiExt.df.drawLines(this.åå­—å…‰æ ‡G, [{ x, y: 0 }, { x, y: this.chartHeight }])

                if (S____________________S.isFullScreen && ä¸‡) {
                    æ—¶é—´é«˜äº®render({
                        str: xStr,
                        x: x,
                        y: this.chartHeight,
                    })
                }
            }
        }
    }
}

]]>
</file>
<file path="src/client/ChartBoxBase.ts">
<![CDATA[
import { Container, Graphics } from "pixi.js";
import { PixiBitmapText } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/PixiBitmapText";
import { pixiExt } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/pixiExt";
import { å‡ ä½• } from "../tx_server/æ—§çš„__lib/é€šç”¨/å‡ ä½•";
import { maxLengthItem } from "../tx_server/æ—§çš„__lib/é€šç”¨/maxLengthItem";
import { APPå‚æ•° } from "../______________config/APPå‚æ•°";
import { S____________________S } from "./S____________________S";

export class ChartBoxBase extends pixiExt.Box {
    chartG = new Graphics()
    maskG = new Graphics()

    æ–‡æœ¬å’Œç”»çº¿Container = new Container()

    chartå¤–é¢G = new Graphics()
    maskå¤–é¢G = new Graphics()
    ä»“ä½ç”»çº¿G = new Graphics()
    åå­—å…‰æ ‡G = new Graphics()
    viewBox = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
    }

    chartWidth = 0
    chartHeight = 0
    layerY = 0
    layerHeight = 0



    constructor() {
        super()
        this.addChild(this.chartG)
        this.addChild(this.chartå¤–é¢G)
        this.addChild(this.æ–‡æœ¬å’Œç”»çº¿Container)
        this.addChild(this.ä»“ä½ç”»çº¿G)
        this.addChild(this.åå­—å…‰æ ‡G)
    }

    baseData = {
        timestampArr: [] as ArrayLike<number | bigint>,
        priceTick: 0.01,
    }

    start(p: {
        isFullScreen: boolean
        iså åŠ å›¾: boolean
        baseData: {
            timestampArr: ArrayLike<number | bigint>
            priceTick: number
        }
    }) {
        this.baseData = p.baseData

        const get_CHART_RIGHT_WIDTH = () => {
            if (p.iså åŠ å›¾) return p.isFullScreen ? 320 : 150
            return p.isFullScreen ? 120 : 20
        }
        const get_CHART_BOTTOM_HEIGHT = () => {
            return p.isFullScreen ? 40 : 20
        }

        this.CHART_RIGHT_WIDTH = get_CHART_RIGHT_WIDTH()
        this.CHART_BOTTOM_HEIGHT = get_CHART_BOTTOM_HEIGHT()
        this.chartWidth = this.____width - this.CHART_RIGHT_WIDTH
        this.chartHeight = this.____height - this.CHART_BOTTOM_HEIGHT


        //
        const ç©ºéš™ = p.isFullScreen ? 80 : 32
        this.layerY = ç©ºéš™
        this.layerHeight = this.chartHeight - ç©ºéš™ * 2


        this.chartG.clear()
        this.maskG.clear()
        this.chartå¤–é¢G.clear()
        this.maskå¤–é¢G.clear()
        this.åå­—å…‰æ ‡G.clear()
        this.ä»“ä½ç”»çº¿G.clear()

        //
        this.maskG.beginFill(0)
        this.maskG.drawRect(this.x, this.y, this.chartWidth, this.chartHeight)
        this.maskG.endFill()
        this.chartG.mask = this.maskG
        this.ä»“ä½ç”»çº¿G.mask = this.maskG
        this.åå­—å…‰æ ‡G.mask = this.maskG
        //

        //
        this.maskå¤–é¢G.beginFill(0)
        this.maskå¤–é¢G.drawRect(this.x, this.y, this.____width, this.____height)
        this.maskå¤–é¢G.endFill()
        this.chartå¤–é¢G.mask = this.maskå¤–é¢G
        //

        while (this.æ–‡æœ¬å’Œç”»çº¿Container.children.length !== 0) {
            this.æ–‡æœ¬å’Œç”»çº¿Container.removeChildAt(0)
        }
    }

    forEachStartToEnd<T extends any>(data: ArrayLike<T>, f: (value: T, index: number) => void) {
        const start = Math.max(0, Math.floor(this.viewBox.left))
        const end = Math.min(Math.round(this.viewBox.right), data.length - 1)
        for (let i = start; i <= end; i++) f(data[i], i)
    }

    toX(value: number) {
        return (value - this.viewBox.left) / (this.viewBox.right - this.viewBox.left) * this.chartWidth
    }

    toIndex(x: number) {
        return (x / this.chartWidth) * (this.viewBox.right - this.viewBox.left) + this.viewBox.left
    }


    toY(value: number) {
        const n = (value - this.viewBox.bottom) / (this.viewBox.top - this.viewBox.bottom) //0--1
        const h = this.layerHeight * (1 - n)
        return this.layerY + h
        //ç¿»è½¬æ¸²æŸ“ this.layerY + this.layerHeight - h
    }


    toPrice(y: number) {
        const n = (y - this.layerY) / this.layerHeight //0--1
        const h = (this.viewBox.top - this.viewBox.bottom) * n
        return this.viewBox.top - h
        //ç¿»è½¬æ¸²æŸ“ this.viewBox.bottom + h
    }




    timestampToX(timestamp: number) {
        const timestampArr = this.baseData.timestampArr
        const a = Number(timestampArr[timestampArr.length - 1])
        const b = Number(timestampArr[timestampArr.length - 2])
        const æ—¶é—´å·® = (a && b) ? (a - b) : 0
        if (a && timestamp > a + æ—¶é—´å·®) {
            const index = timestampArr.length - 1 + Math.floor((timestamp - a) / æ—¶é—´å·®)
            return this.toX(index)
        }


        let index = 0
        for (let i = 0; i < timestampArr.length; i++) {
            if (
                timestamp >= timestampArr[i] &&
                (i === timestampArr.length - 1 || timestamp < timestampArr[i + 1])
            ) {
                index = i
                break
            }
        }
        return this.toX(index)
    }

    xToTimestamp(x: number) {
        const timestampArr = this.baseData.timestampArr
        const index = Math.round(this.toIndex(x))
        if (index < timestampArr.length) {
            return timestampArr[index] || 0
        } else {
            const a = Number(timestampArr[timestampArr.length - 1])
            const b = Number(timestampArr[timestampArr.length - 2])
            const æ—¶é—´å·® = (a && b) ? (a - b) : 0
            return (a || 0) + (index - (timestampArr.length - 1)) * æ—¶é—´å·®
        }
    }

    setViewBoxLeftRightAll(arr: any[][]) {
        let maxLengthIndex = 0
        arr.forEach((v, i) => {
            if (v.length > arr[maxLengthIndex].length) {
                maxLengthIndex = i
            }
        })
        const maxLength = arr.length > 0 ? arr[maxLengthIndex].length : 0

        this.viewBox.left = 0
        this.viewBox.right = maxLength - 1
    }

    setViewBoxTopAndBottom(lineArr: ArrayLike<number>[]) {
        if (lineArr.length > 0) {
            this.viewBox.top = -Number.MAX_VALUE
            this.viewBox.bottom = Number.MAX_VALUE
            this.forEachStartToEnd(maxLengthItem(lineArr), (_, i) => {
                lineArr.forEach(line => {
                    if (isNaN(line[i]) === false) {
                        this.viewBox.top = Math.max(this.viewBox.top, line[i])
                        this.viewBox.bottom = Math.min(this.viewBox.bottom, line[i])
                    }
                })
            })

            //updateLast
            if (this.viewBox.top === this.viewBox.bottom) {
                this.viewBox.top += 0.1
                this.viewBox.bottom -= 0.1
            }
        }
    }

    drawæ°´å¹³çº¿(p: {
        price: number
        color: number
    }) {
        if (isNaN(p.price) === false) {
            const y = this.toY(p.price)
            this.chartG.lineStyle(1, p.color, 0.5)
            pixiExt.df.drawLines(this.chartG, [{ x: 0, y }, { x: this.chartWidth, y }])
        }
    }
    drawButtonæ°´å¹³çº¿(p: {
        price: number
        text: string
        color: number
        ä¸Šä¸‹value?: number
        onClick?: () => void
    }) {
        const å·¦å³ç©ºéš™ = 5
        const y = this.toY(p.price)
        const { chartG } = this

        const { w, h } = this.drawText({
            fontSize: 20,
            fill: p.color,
            anchor: { x: 0, y: 0.5 },
        }, {
            x: å·¦å³ç©ºéš™,
            y,
            text: p.text,
        }, p.onClick, this.maskG)

        if (p.ä¸Šä¸‹value === undefined) {
            chartG.lineStyle(1, p.color)
            pixiExt.df.drawLines(chartG, [{ x: w + å·¦å³ç©ºéš™ * 2 + 1, y }, { x: this.chartWidth, y }])

            chartG.lineStyle(1, p.color)
            chartG.beginFill(0, 0.5)
            chartG.drawRect(1, y - h / 2, w + å·¦å³ç©ºéš™ * 2, h) //+1
            chartG.endFill()

        } else {
            const y1 = this.toY(p.price + p.ä¸Šä¸‹value)
            const y2 = this.toY(p.price - p.ä¸Šä¸‹value)
            chartG.lineStyle()
            chartG.beginFill(p.color, 0.25)
            pixiExt.df.drawRect(chartG, { p1: { x: 0, y: y1 }, p2: { x: this.chartWidth, y: y2 } })
            chartG.endFill()
        }
    }


    drawText(p: {
        fontSize: number
        fill: number
        anchor: {
            x: number
            y: number
        }
    }, obj: { x: number, y: number, text: string }, onClick?: () => void, mask?: Graphics) {
        let t = new PixiBitmapText(p)
        t.x = obj.x
        t.y = obj.y
        t.text = obj.text
        this.æ–‡æœ¬å’Œç”»çº¿Container.addChild(t)
        if (onClick) {
            t.interactive = true
            t.buttonMode = true
            t.addListener('mouseup', onClick)
        }
        if (mask) {
            t.mask = mask
        }

        return { w: t.width, h: t.height }
    }
    drawæ ‡é¢˜(p: { text: string, color: number, index: number }) {
        this.drawText({
            fontSize: 18,
            fill: p.color,
            anchor: {
                x: 0,
                y: 0,
            },
        }, {
            x: 10,
            y: 10 + p.index * 32,
            text: p.text,
        })
    }






    drawRect(rect: å‡ ä½•.Rect) {
        pixiExt.df.drawRect(this.chartG, {
            p1: {
                x: this.toX(rect.left),
                y: this.toY(rect.top),
            },
            p2: {
                x: this.toX(rect.right),
                y: this.toY(rect.bottom),
            },
        })
    }

    drawçº¿æ®µ = (arr: [index: number, value: number][]) =>
        pixiExt.df.drawLines(this.chartG, arr.map(([index, value]) => ({ x: this.toX(index), y: this.toY(value) })))

    drawLine(arr: number[], color: number, width = 1) {
        let arr2: { index: number, value: number }[] = []
        this.forEachStartToEnd(arr, (value, index) => arr2.push({ value, index }))

        this.chartG.lineStyle(width, color)
        this.drawçº¿æ®µ(arr2.map(v => [v.index, v.value]))
    }


    drawKLine(kline: ArrayLike<KLine>, xxx = APPå‚æ•°.theme.color.KLINE) {
        const { chartG } = this
        let lastColor = xxx.UP

        this.forEachStartToEnd(kline, (v, i) => {
            const open = (S____________________S.Kçº¿è¡¥é½ && kline[i - 1] !== undefined) ? kline[i - 1].close : v.open
            const color = v.close === open ? lastColor : (v.close > open ? xxx.UP : xxx.DOWN)
            lastColor = color

            chartG.lineStyle(1, color.LINE)
            this.drawçº¿æ®µ([[i, v.low], [i, v.high]])

            chartG.beginFill(color.FILL)
            this.drawRect({ left: i - 0.3, right: i + 0.3, top: Math.max(open, v.close), bottom: Math.min(open, v.close) })
            chartG.endFill()

        })
    }


    drawVolume(kline: ArrayLike<KLine>, xxx = APPå‚æ•°.theme.color.KLINE) {
        const { chartG } = this

        let lastColor = xxx.UP

        this.forEachStartToEnd(kline, (v, i) => {
            const open = (S____________________S.Kçº¿è¡¥é½ && kline[i - 1] !== undefined) ? kline[i - 1].close : v.open
            const color = v.close === open ? lastColor : (v.close > open ? xxx.UP : xxx.DOWN)
            lastColor = color

            chartG.lineStyle(1, color.LINE)
            chartG.beginFill(color.FILL)
            this.drawRect({
                left: i - 0.3,
                right: i + 0.3,
                top: v.volume || 0,
                bottom: 0,
            })
            chartG.endFill()

        })
    }

    CHART_RIGHT_WIDTH = 0
    CHART_BOTTOM_HEIGHT = 0



}

]]>
</file>
<file path="src/client/CustomCell.tsx">
<![CDATA[
import * as React from 'react';
import { å…¨å±€_____State } from './å…¨å±€_____State';
import { symbolæ˜¾ç¤º } from '../tx_server/æ—§çš„__lib/å›¾è¡¨/symbolæ˜¾ç¤ºé˜…è¯»';
import { æˆäº¤é‡æ ¼å¼åŒ– } from '../tx_server/æ—§çš„__lib/é€šç”¨/æˆäº¤é‡æ ¼å¼åŒ–';
import { chart_ls } from '../_____lib/chart/chart_ls';
import { è¡¨æ ¼é¢œè‰² } from '../è¡¨æ ¼é¢œè‰²';
//import { kl_client } from '../kl_server/kl_client';
// import { initDetailPanel } from '../index' // å·²ç§»é™¤ï¼Œä¸å†ä½¿ç”¨iframe

export const CustomCell = (v: {
    symbol: string;
    value: number;
    message: React.ReactNode;
    onClick?: () => void;
    cssColor?: string;
}) => <td onMouseDown={v.onClick || (() => {
    console.log('å½“å‰é€‰ä¸­çš„äº¤æ˜“å“ç§:', v.symbol)
    // å¦‚æœsymbolæœ«å°¾ä¸æ˜¯usdtï¼Œæ·»åŠ usdtåç¼€
    let symbolWithUsdt = v.symbol.toLowerCase().endsWith('usdt') ? v.symbol : v.symbol + 'USDT'
    if (v.symbol.toLowerCase() === 'pepe') {
        symbolWithUsdt = '1000' + symbolWithUsdt;
    }
    console.log('å½“å‰é€‰ä¸­çš„äº¤æ˜“å“ç§symbolWithUsdt:', symbolWithUsdt)
    //kl_client.addSymbolKline([symbolWithUsdt]);
    å…¨å±€_____State.set_å•å“ç§_æ—¥çº¿_å’Œ_å½“å‰å‘¨æœŸ(symbolWithUsdt);
    chart_ls.é…ç½®.symbol_list_1 = [symbolWithUsdt]

    // ç®€å•ç²—æš´åœ°ç›´æ¥è°ƒç”¨å…¨å±€å‡½æ•°
    window.initDetailPanel();
})}
    style={{
        color: v.cssColor || (v.value >= 0 ? è¡¨æ ¼é¢œè‰².ä¸Šæ¶¨ : è¡¨æ ¼é¢œè‰².ä¸‹è·Œ),
        fontSize: typeof v.message === 'string' ? '12px' : undefined,
    }}>
        {(v.message !== '') ?
            (typeof v.message === 'string' ? <span>{v.message}</span> : v.message) :
            <>
                <span>{v.value > 100000 ? æˆäº¤é‡æ ¼å¼åŒ–(v.value) + ' ' : (v.value * 100).toFixed(2) + '% '}</span>
                <span>{symbolæ˜¾ç¤º(v.symbol)}</span>
            </>}

    </td>;

]]>
</file>
<file path="src/client/drawæˆäº¤é‡.ts">
<![CDATA[

import { BaseSymbol } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/BaseSymbol"
import { ChartBox } from "./ChartBox"
import { getBaseSymbol } from "./getBaseSymbol"
import { S____________________S } from "./S____________________S"


export const drawæˆäº¤é‡ = (bs: BaseSymbol, å‘¨æœŸindex: () => number) => (cb: ChartBox) => {
    const kline = getBaseSymbol(bs.info.symbol).getKLine(å‘¨æœŸindex())
    const vol = getBaseSymbol(bs.info.symbol).getVolume(å‘¨æœŸindex())

    cb.start({
        isFullScreen: S____________________S.isFullScreen,
        iså åŠ å›¾: false,
        baseData: {
            timestampArr: getBaseSymbol(bs.info.symbol).getTimestamp(å‘¨æœŸindex()),
            priceTick: 1,
        }
    })

    cb.layerY = 0
    cb.layerHeight = cb.chartHeight
    cb.setViewBoxTopAndBottom([vol, [0]])
    cb.drawåæ ‡è½´(true)
    cb.drawVolume(kline)
    cb.drawåå­—å…‰æ ‡(true)
}

]]>
</file>
<file path="src/client/drawå•å“ç§Kçº¿.ts">
<![CDATA[
import { BaseSymbol } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/BaseSymbol"
import { APPå‚æ•° } from "../______________config/APPå‚æ•°"
import { ä»·æ ¼å…¶ä»– } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/ä»·æ ¼å…¶ä»–"
import { oneIDCallOne } from "../tx_server/æ—§çš„__lib/é€šç”¨/oneIDCallOne"
import { å‡çº¿æŒ‡æ ‡ } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/å‡çº¿æŒ‡æ ‡"
import { å…¨å±€_____State } from "./å…¨å±€_____State"
import { ChartBox } from "./ChartBox"
import { getBaseSymbol } from "./getBaseSymbol"
import { å‘¨æœŸarr } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/binanceSubject"
import { S____________________S } from "./S____________________S"
import { kl_client } from "../kl_server/kl_client"
import { globalContractsMap } from "../cryptoInfo_server/contractsClient"
import { formatTurnoverRate } from '../index'


const getZB = oneIDCallOne((symbol: string) => new å‡çº¿æŒ‡æ ‡.æŒ‡æ ‡())

export const drawå•å“ç§Kçº¿ = (bs: BaseSymbol, å‘¨æœŸindex: () => number) => (cb: ChartBox) => {
    const h = getBaseSymbol(bs.info.symbol).getHigh(å‘¨æœŸindex())
    const l = getBaseSymbol(bs.info.symbol).getLow(å‘¨æœŸindex())
    const kline = getBaseSymbol(bs.info.symbol).getKLine(å‘¨æœŸindex())
    const zb = getZB(bs.info.symbol)

    cb.start({
        isFullScreen: S____________________S.isFullScreen,
        iså åŠ å›¾: false,
        baseData: {
            timestampArr: getBaseSymbol(bs.info.symbol).getTimestamp(å‘¨æœŸindex()),
            priceTick: bs.info.priceTick,
        }
    })


    zb.è®¡ç®—å…¨éƒ¨(getBaseSymbol(bs.info.symbol).getClose(å‘¨æœŸindex()),
        kline.length > 1 ? `${kline[0].timestamp}_${kline[1].timestamp}` : ''
    )

    cb.setViewBoxTopAndBottom(å…¨å±€_____State.å¼€å…³.å‡çº¿ ?
        [h,
            l,
            zb.å…¨éƒ¨.ma1, zb.å…¨éƒ¨.ma2, zb.å…¨éƒ¨.ma3] :
        [
            h,
            l,
        ])

    cb.drawåæ ‡è½´()

    //drawæœ€æ–°ä»·
    const close = kline[kline.length - 1]?.close
    if (close !== undefined) {

        if (S____________________S.isFullScreen) {
            const y = cb.toY(close)
            cb.drawText({
                fontSize: 20,
                fill: 0xffff00,
                anchor: { x: 0, y: 0.5 }
            }, {
                x: cb.chartWidth + 15,
                y,
                text: ä»·æ ¼å…¶ä»–.ä»·æ ¼æŒ‰è·³æ ¼å¼åŒ–({ priceTick: bs.info.priceTick, price: close }),
            })
        }

        cb.drawæ°´å¹³çº¿({ color: 0xffff00, price: bs.getOrderBook().sell1 })
        cb.drawæ°´å¹³çº¿({ color: 0xffff00, price: bs.getOrderBook().buy1 })
    }


    cb.drawKLine(kline)

    if (å…¨å±€_____State.å¼€å…³.å‡çº¿) {
        cb.drawLine(zb.å…¨éƒ¨.ma1, APPå‚æ•°.theme.color.å‡çº¿[0])
        cb.drawLine(zb.å…¨éƒ¨.ma2, APPå‚æ•°.theme.color.å‡çº¿[1])
        cb.drawLine(zb.å…¨éƒ¨.ma3, APPå‚æ•°.theme.color.å‡çº¿[2])
    }

    cb.drawåå­—å…‰æ ‡()


    if (å…¨å±€_____State.å¼€å…³.ä»“ä½ç”»çº¿) {
        //drawå§”æ‰˜ä»“ä½æ¨ªçº¿
        bs.äº¤æ˜“.getæ¨ªçº¿UI(S____________________S.isFullScreen).forEach(v => {
            cb.drawButtonæ°´å¹³çº¿({
                price: v.price,
                text: v.str,
                color: v.color,
                ä¸Šä¸‹value: v.ä¸Šä¸‹value,
                onClick: S____________________S.isFullScreen ? v.onClick : undefined,
            })
        })


        //drawä»“ä½ç”»çº¿
        bs.äº¤æ˜“.getå†å²ä»“ä½UI().forEach(v => {
            const color = v.orderType === 'Buy' ? APPå‚æ•°.theme.color.UP : APPå‚æ•°.theme.color.DOWN
            cb.ä»“ä½ç”»çº¿G.lineStyle(APPå‚æ•°.theme.ç”»çº¿_ä»“ä½.width, color, APPå‚æ•°.theme.ç”»çº¿_ä»“ä½.alpha)
            cb.ä»“ä½ç”»çº¿G.moveTo(cb.timestampToX(v.openTime), cb.toY(v.openPrice))
            cb.ä»“ä½ç”»çº¿G.lineTo(cb.timestampToX(v.closeTime), cb.toY(v.closePrice))
        })
    }

    cb.drawæ ‡é¢˜({
        text: bs.info.name + ' ' + 
              (å‘¨æœŸindex() === -1 ? '1s' : å‘¨æœŸarr[å‘¨æœŸindex()]) + '  ' + 
              //(globalContractsMap[bs.info.name]?.name || '') + ' ' +
              (globalContractsMap[bs.info.name]?.description || ''),
        color: APPå‚æ•°.theme.color.æ ‡é¢˜æ™®é€š,
        index: 0,
    })

    cb.drawæ ‡é¢˜({
        text: 'é¢˜æ:' + Object.keys(kl_client.getæ‰‹åŠ¨dataSRC(bs.info.symbol).tags_dic).join('  '),
        color: APPå‚æ•°.theme.color.æ ‡é¢˜æ™®é€š,
        index: 1,
    })
    cb.drawæ ‡é¢˜({
        text: 
            ('æ¢æ‰‹:' + formatTurnoverRate(globalContractsMap[bs.info.name]?.turnoverRate)) + ' ' +
            ('æˆäº¤é‡:' + (globalContractsMap[bs.info.name]?.volume24h ? 
                (globalContractsMap[bs.info.name].volume24h / 100000000).toFixed(2) + 'äº¿' 
                : '')),
        color: globalContractsMap[bs.info.name]?.turnoverRate && 
               globalContractsMap[bs.info.name].turnoverRate > 100 
               ? APPå‚æ•°.theme.color.DOWN 
               : APPå‚æ•°.theme.color.UP,
        index: 2,
    })


    if (bs.æ–­çº¿ç§’ >= 5) {
        cb.drawText({
            fontSize: 128,
            fill: 0xff0000,
            anchor: {
                x: 0.5,
                y: 0.5,
            },
        }, {
            x: cb.____width / 2,
            y: cb.____height / 2,
            text: `æ–­çº¿ ${bs.æ–­çº¿ç§’}s`,
        })
    }

}



]]>
</file>
<file path="src/client/getBaseSymbol.ts">
<![CDATA[
import { BaseSymbol } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/BaseSymbol"
import { BinanceSymbol } from "./BinanceSymbol"
import { TVSymbol } from "./TVSymbol"

const binanceDic = new Map<string, BaseSymbol>()

export const getBaseSymbol = (symbol: string) => {
    if (!binanceDic.has(symbol)) {
        if (symbol.indexOf(':') === -1) {
            binanceDic.set(symbol, new BinanceSymbol(symbol))
        } else {
            binanceDic.set(symbol, new TVSymbol(symbol))
        }
    }
    return binanceDic.get(symbol)!
}

]]>
</file>
<file path="src/client/S____________________S.ts">
<![CDATA[
export const S____________________S = new class {

    å½“å‰å³é”®äº¤æ˜“?: {
        isBuy: boolean
        symbol: string
        price: number
    }

    Kçº¿è¡¥é½ = true

    isFullScreen = false
}
]]>
</file>
<file path="src/client/TVSymbol.ts">
<![CDATA[
// src/client/TVSymbol.ts
import { å‘¨æœŸarr } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/binanceSubject"
import { BaseSymbol } from "../tx_server/æ—§çš„__lib/å›¾è¡¨/BaseSymbol"
import { å¤šå›¾é…ç½® } from "../______________config/å¤šå›¾é…ç½®"

type KLine = {
    timestamp: number
    open: number
    high: number
    low: number
    close: number
    volume?: number
}
// = a================================================================================================
// --- æ ¸å¿ƒåº“å®ç° (è‡ªåŒ…å«ï¼Œå¸¦æ—¥å¿—) ---
// =================================================================================================

const TradingView = (() => {
    const utils = {
        genSessionID(type = 'xs') {
            let r = '';
            const c = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < 12; i += 1) r += c.charAt(Math.floor(Math.random() * c.length));
            return `${type}_${r}`;
        },
    };

    const protocol = {
        parseWSPacket(str: string) {
            const cleanerRgx = /~h~/g;
            const splitterRgx = /~m~[0-9]{1,}~m~/g;
            return str.replace(cleanerRgx, '').split(splitterRgx)
                .map((p) => {
                    if (!p) return false;
                    try { return JSON.parse(p); }
                    catch (error) { console.warn('Cant parse', p); return false; }
                })
                .filter((p) => p);
        },
        formatWSPacket(packet: any) {
            const msg = typeof packet === 'object' ? JSON.stringify(packet) : packet;
            return `~m~${msg.length}~m~${msg}`;
        },
    };

    const chartSessionGenerator = (bridge: any) => class ChartSession {
        #chartSessionID = utils.genSessionID('cs');
        #bridge = bridge;
        #periods: { [key: number]: any } = {};
        get periods() { return Object.values(this.#periods).sort((a, b) => b.time - a.time); }
        #callbacks: { [key: string]: Function[] } = { update: [], error: [], symbol_resolved: [] };

        #handleEvent(ev: string, ...data: any[]) { this.#callbacks[ev]?.forEach((e) => e(...data)); }
        #handleError(...msgs: any[]) {
            if (this.#callbacks.error.length === 0) console.error(...msgs);
            else this.#handleEvent('error', ...msgs);
        }

        constructor() {
            this.#bridge.sessions[this.#chartSessionID] = {
                type: 'chart',
                onData: (packet: any) => {
                    if (packet.type === 'symbol_resolved') {
                        this.#handleEvent('symbol_resolved', packet.data[2]);
                        return;
                    }
                    if (['timescale_update', 'du'].includes(packet.type)) {
                        const prices = packet.data[1].$prices;
                        if (!prices || !prices.s) return;
                        prices.s.forEach((p: any) => {
                            this.#periods[p.v[0]] = {
                                time: p.v[0], open: p.v[1], close: p.v[4],
                                max: p.v[2], min: p.v[3],
                                volume: Math.round(p.v[5] * 100) / 100,
                            };
                        });
                        this.#handleEvent('update');
                        return;
                    }
                    if (packet.type === 'symbol_error') this.#handleError(`(${packet.data[1]}) Symbol error:`, packet.data[2]);
                    if (packet.type === 'series_error') this.#handleError('Series error:', packet.data[3]);
                },
            };
            this.#bridge.send('chart_create_session', [this.#chartSessionID]);
        }

        #seriesCreated = false;
        #currentSeries = 0;

        setSeries(timeframe = '1', range = 100, to: number | null = null) {
            if (!this.#currentSeries) return this.#handleError('Please set market before series');
            this.#periods = {};
            this.#bridge.send(`${this.#seriesCreated ? 'modify' : 'create'}_series`, [
                this.#chartSessionID, '$prices', 's1', `ser_${this.#currentSeries}`,
                timeframe, this.#seriesCreated ? '' : (to ? ['bar_count', to, range] : range),
            ]);
            this.#seriesCreated = true;
        }

        setMarket(symbol: string, options: { timeframe?: string, range?: number, to?: number } = {}) {
            this.#periods = {};
            this.#currentSeries += 1;
            this.#bridge.send('resolve_symbol', [
                this.#chartSessionID, `ser_${this.#currentSeries}`,
                `=${JSON.stringify({ symbol: symbol || 'BTCEUR' })}`,
            ]);
            this.setSeries(options.timeframe, options.range, options.to);
        }

        onUpdate(cb: () => void) { this.#callbacks.update.push(cb); }
        onError(cb: (...args: any[]) => void) { this.#callbacks.error.push(cb); }
        onSymbolResolved(cb: (symbolInfo: any) => void) { this.#callbacks.symbol_resolved.push(cb); }

        delete() {
            this.#bridge.send('chart_delete_session', [this.#chartSessionID]);
            delete this.#bridge.sessions[this.#chartSessionID];
        }
    };

    class Client {
        #ws: WebSocket | null = null;
        #logged = false;
        #sessions: { [key: string]: any } = {};
        #callbacks: { [key: string]: Function[] } = { error: [] };
        #sourceName: string;
        public lastMessageTimestamp: number = Date.now();

        #handleError(...msgs: any[]) {
            if (this.#callbacks.error.length === 0) console.error(...msgs);
            else this.#callbacks.error.forEach(cb => cb(...msgs));
        }

        #parsePacket(str: string) {
            protocol.parseWSPacket(str).forEach((packet: any) => {
                if (typeof packet === 'number') {
                    const keepAliveMsg = protocol.formatWSPacket(`~h~${packet}`);
                    this.#ws?.send(keepAliveMsg);
                    return;
                }
                if (packet.m === 'protocol_error') return this.#handleError(`[${this.#sourceName}] Client critical error:`, packet.p);
                if (packet.m && packet.p) {
                    const session = packet.p[0];
                    if (session && this.#sessions[session]) {
                        this.#sessions[session].onData({ type: packet.m, data: packet.p });
                    }
                }
            });
        }

        #sendQueue: string[] = [];
        send(t: string, p: any[] = []) {
            this.#sendQueue.push(protocol.formatWSPacket({ m: t, p }));
            this.sendQueue();
        }

        sendQueue() {
            while (this.#ws && this.#ws.readyState === WebSocket.OPEN && this.#logged && this.#sendQueue.length > 0) {
                const msg = this.#sendQueue.shift();
                if (msg) {
                    this.#ws.send(msg);
                }
            }
        }

        get ws() {
            return this.#ws;
        }

        constructor(clientOptions: { sourceName?: string, websocketUrl?: string } = {}) {
            this.#sourceName = clientOptions.sourceName || 'Unknown Source';
            const websocketUrl = clientOptions.websocketUrl || 'wss://data.tradingview.com/socket.io/websocket?type=chart';
            //console.log(`[TV-LIFECYCLE] (${this.#sourceName}) Initializing connection to: ${websocketUrl}`);

            this.#ws = new WebSocket(websocketUrl);

            this.#sendQueue.unshift(protocol.formatWSPacket({
                m: 'set_auth_token', p: ['unauthorized_user_token'],
            }));
            this.#logged = true;

            this.#ws.onopen = () => {
                this.lastMessageTimestamp = Date.now();
                //console.log(`[TV-LIFECYCLE] (${this.#sourceName}) WebSocket connection established. Sending queued messages...`);
                this.sendQueue();
            };

            this.#ws.onclose = (event) => {
                //console.warn(`[TV-LIFECYCLE] (${this.#sourceName}) WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
            };

            this.#ws.onerror = (event) => {
                //.error(`[TV-LIFECYCLE] (${this.#sourceName}) WebSocket error occurred.`, event);
                this.#handleError(`[${this.#sourceName}] WebSocket error occurred.`);
            };

            this.#ws.onmessage = (event) => {
                this.lastMessageTimestamp = Date.now();
                this.#parsePacket(event.data.toString());
            };

            const clientBridge = {
                sessions: this.#sessions,
                send: (t: string, p: any[]) => this.send(t, p),
            };
            this.Session = { Chart: chartSessionGenerator(clientBridge) };
        }

        onError(cb: (...args: any[]) => void) { this.#callbacks.error.push(cb); }

        public Session: { Chart: any } = { Chart: null };
    }
    return { Client };
})();


// =================================================================================================
// --- åº”ç”¨é€»è¾‘ (TVSymbol ç±») ---
// =================================================================================================

type ClientType = 'main' | 'aux';

enum MarketState {
    CLOSED,
    REGULAR,
}

interface SessionData {
    start: string; // "HHMM"
    end: string;   // "HHMM"
    corrections: Map<string, { start: string, end: string }>;
}

interface TradingSessionInfo {
    is24x7: boolean;
    timezone: string;
    holidays: Set<string>;
    sessions: {
        regular?: SessionData;
    };
}

export class TVSymbol extends BaseSymbol {

    buy1 = NaN;
    sell1 = NaN;

    private clients: { [key in ClientType]?: any } = {};
    private healthCheck: { [key in ClientType]?: { timer: any } } = {};
    private tradingSessionInfo: TradingSessionInfo | null = null;
    private originalName: string | null = null;
    private staticDebugInfo: string = '';
    private reconnecting: { [key in ClientType]?: boolean } = {};
    private lastKLineTimestamp: number = 0;

    private readonly HEALTH_CHECK_INTERVAL = 3000;
    private readonly CONNECTION_TIMEOUT = 30000; 

    override getOrderBook() {
        return { buy1: this.buy1, sell1: this.sell1 };
    }

    override getKLine(index: number): ArrayLike<KLine> {
        return this.è¡Œæƒ….klines[index] || [];
    }

    constructor(symbol: string) {
        if (!symbol || typeof symbol !== 'string') {
            // console.error(
            //     `%c--- CRITICAL: INVALID TVSymbol CREATION ---%c
            //     Symbol Value: %o
            //     Symbol Type: %s
            //     Halting initialization for this instance.`,
            //     'color: white; background-color: red; font-size: 14px; padding: 2px;',
            //     '',
            //     symbol,
            //     typeof symbol
            // );
            super({ symbol: 'INVALID_SYMBOL', name: 'Error: Invalid Symbol', priceTick: 1 });
            return;
        }
        
        const config = å¤šå›¾é…ç½®.find(v => v.symbol === symbol);
        super({
            symbol,
            name: config?.name || symbol,
            priceTick: config?.tick || 1,
        });
        this.originalName = this.info.name;

        this.setupConnection('main', symbol);
        this.setupConnection('aux', symbol);
    }

    private parseCorrections(correctionStr?: string): Map<string, { start: string; end: string; }> {
        const corrections = new Map<string, { start: string, end: string }>();
        if (!correctionStr) return corrections;
        correctionStr.split(';').forEach(rule => {
            if (!rule.includes(':')) return;
            const [time, dates] = rule.split(':', 2);
            if (!time.includes('-')) return;
            const [start, end] = time.split('-').map(t => t.replace(':', ''));
            dates.split(',').forEach(date => {
                if (date) corrections.set(date, { start, end });
            });
        });
        return corrections;
    }

    private parseAndStoreSessionInfo(symbolInfo: any) {
        if (!symbolInfo || this.tradingSessionInfo) return;
        
        if (symbolInfo.pricescale && symbolInfo.minmov) {
            this.info.priceTick = symbolInfo.minmov / symbolInfo.pricescale;
        }
        
        const mainSession = symbolInfo.session || 'N/A';
        this.staticDebugInfo = ` [äº¤æ˜“æ—¶é—´: ${mainSession}]`;

        if (symbolInfo.type === 'crypto' || symbolInfo.session === '24x7') {
            this.tradingSessionInfo = {
                is24x7: true,
                timezone: 'Etc/UTC',
                holidays: new Set(),
                sessions: {
                    regular: { start: '0000', end: '2400', corrections: new Map() }
                }
            };
            return;
        }

        const holidays = new Set<string>(symbolInfo.session_holidays?.split(',') || []);
        const timezone = symbolInfo.timezone || 'Etc/UTC';
        const parsedSessions: TradingSessionInfo['sessions'] = {};
        
        if (mainSession !== 'N/A') {
            const [start, end] = mainSession.split('-').map((t: string) => t.replace(':', ''));
            parsedSessions.regular = {
                start,
                end,
                corrections: this.parseCorrections(symbolInfo['session-correction']),
            };
        }

        this.tradingSessionInfo = {
            is24x7: false,
            timezone,
            holidays,
            sessions: parsedSessions
        };
        //console.log(`[TVSymbol: ${this.symbol}] Trading session info parsed:`, this.tradingSessionInfo);
    }
    
    private isTimeInPeriod(hhmm: string, start: string, end: string): boolean {
        if (start <= end) {
            return hhmm >= start && hhmm < end;
        } else {
            return hhmm >= start || hhmm < end;
        }
    }

    private getMarketState(): MarketState {
        if (!this.tradingSessionInfo) return MarketState.REGULAR;
        if (this.tradingSessionInfo.is24x7) return MarketState.REGULAR;

        const { timezone, holidays, sessions } = this.tradingSessionInfo;

        try {
            const now = new Date();
            const yyyymmdd = new Intl.DateTimeFormat('en-CA', { timeZone: timezone }).format(now).replace(/-/g, '');
            const hhmm = new Intl.DateTimeFormat('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: timezone }).format(now).replace(':', '');

            if (holidays.has(yyyymmdd)) return MarketState.CLOSED;

            const regularSession = sessions.regular;
            if (!regularSession) {
                const dayOfWeek = now.toLocaleDateString('en-US', { timeZone: timezone, weekday: 'short' });
                if (dayOfWeek === 'Sat' || dayOfWeek === 'Sun') return MarketState.CLOSED;
                return MarketState.REGULAR;
            }

            const corrected = regularSession.corrections.get(yyyymmdd);
            const start = corrected?.start || regularSession.start;
            const end = corrected?.end || regularSession.end;

            if (this.isTimeInPeriod(hhmm, start, end)) {
                return MarketState.REGULAR;
            }

            return MarketState.CLOSED;

        } catch (e) {
            //console.error(`[TVSymbol: ${this.symbol}] Error checking market status:`, e);
            return MarketState.REGULAR;
        }
    }

    private disconnect(type: ClientType) {
        if (this.healthCheck[type]?.timer) {
            clearInterval(this.healthCheck[type]!.timer);
        }
        this.healthCheck[type] = undefined;

        const client = this.clients[type];
        if (client?.ws) {
            client.ws.onclose = null;
            client.ws.onerror = null;
            client.ws.onmessage = null;
            client.ws.close();
        }
        this.clients[type] = undefined;
    }

    private setupConnection(type: ClientType, symbol: string) {
        this.disconnect(type);
        this.reconnecting[type] = false;

        const isMain = type === 'main';
        const url = isMain
            ? 'wss://prodata.tradingview.com/socket.io/websocket?type=chart'
            : 'wss://data.tradingview.com/socket.io/websocket?type=chart';
        const sourceName = `TVSymbol-${symbol}-${type}`;

        const client = new TradingView.Client({ sourceName, websocketUrl: url });
        this.clients[type] = client;

        //client.onError((...err: any[]) => console.error(`[TVSymbol: ${symbol}] Client-level error on ${type}:`, ...err));

        this.healthCheck[type] = {
            timer: setInterval(() => {
                const now = Date.now();
                const clientInstance = this.clients[type];
                if (!clientInstance) return;

                // ç¬¬ä¸€é“é˜²çº¿ï¼šç‰©ç†è¿æ¥æ£€æŸ¥ (æ°¸è¿œåœ¨çº¿)
                if (clientInstance.ws && clientInstance.ws.readyState !== WebSocket.OPEN && clientInstance.ws.readyState !== WebSocket.CONNECTING) {
                    //console.warn(`[TVSymbol: ${symbol}] Detected dead WebSocket for ${type} (state: ${clientInstance.ws.readyState}). Reconnecting...`);
                    this.reconnect(type, symbol, 'dead websocket detected');
                    return;
                }

                const marketState = this.getMarketState();
                
                const statusText = (marketState === MarketState.REGULAR) ? '(äº¤æ˜“ä¸­)' : '(å·²æ”¶ç›˜)';
                let dataStaleText = '';

                // [ä¿®æ”¹] åªæœ‰åœ¨äº¤æ˜“æ—¶æ®µï¼Œæ‰æ˜¾ç¤ºæ•°æ®æ›´æ–°æ—¶é—´
                if (marketState === MarketState.REGULAR) {
                    if (this.lastKLineTimestamp > 0) {
                        const secondsSinceKLine = Math.floor((now - this.lastKLineTimestamp) / 1000);
                        dataStaleText = ` (${secondsSinceKLine}s)`;
                    } else {
                        dataStaleText = ' (ç­‰å¾…æ•°æ®)';
                    }
                }

                const baseName = this.originalName || symbol;
                this.info.name = `${baseName}${this.staticDebugInfo} ${statusText}${dataStaleText}`;
                
                // ç¬¬äºŒé“é˜²çº¿ï¼šé€»è¾‘å¿ƒè·³æ£€æŸ¥ (ä»…åœ¨äº¤æ˜“æ—¶æ®µ)
                if (marketState === MarketState.REGULAR) {
                    if (now - clientInstance.lastMessageTimestamp > this.CONNECTION_TIMEOUT) {
                        //console.warn(`[TVSymbol: ${symbol}] Connection timeout on ${type} during REGULAR hours! No message for ${this.CONNECTION_TIMEOUT / 1000}s.`);
                        this.reconnect(type, symbol, 'connection heartbeat timeout');
                    }
                }
            }, this.HEALTH_CHECK_INTERVAL),
        };
        // const å‘¨æœŸ = ['1', '5', '30', '4H', '1D', '1W']
        const tvTimeframes = ['1', '5', '30','4H'];
        const klineHistorySize = 2000;
        const periodsToSubscribe = isMain ? å‘¨æœŸarr.map((_, i) => i) : [0];

        periodsToSubscribe.forEach(å‘¨æœŸindex => {
            const timeframe = tvTimeframes[å‘¨æœŸindex];
            if (!timeframe) return;

            const chart = new client.Session.Chart();
            //chart.onError((...err: any[]) => console.error(`[TVSymbol: ${symbol}] Chart error on ${type} (${timeframe}):`, ...err));

            if (å‘¨æœŸindex === 0) {
                chart.onSymbolResolved((symbolInfo: any) => this.parseAndStoreSessionInfo(symbolInfo));
            }
            
            chart.onUpdate(() => this.handleKLineUpdate(type, å‘¨æœŸindex, chart.periods));
            chart.setMarket(symbol, { timeframe, range: klineHistorySize });
        });
    }

    private handleKLineUpdate(sourceType: ClientType, å‘¨æœŸindex: number, periods: any[]) {
        this.lastKLineTimestamp = Date.now();

        if (!periods.length) return;

        const newKlines: KLine[] = periods.map((p: any) => ({
            timestamp: p.time * 1000,
            open: p.open,
            high: p.max,
            low: p.min,
            close: p.close,
            æˆäº¤é¢: p.volume,
        })).reverse();

        this.è¡Œæƒ….klines[å‘¨æœŸindex] = newKlines;

        const lastKline = newKlines[newKlines.length - 1];
        if (lastKline) {
            this.buy1 = lastKline.close;
            this.sell1 = lastKline.close;
        }
    }

    private reconnect(type: ClientType, symbol: string, reason: string) {
        if (this.reconnecting[type]) {
            return;
        }
        this.reconnecting[type] = true;

        //console.log(`[TVSymbol: ${symbol}] Reconnecting ${type} client due to: ${reason}.`);
        setTimeout(() => this.setupConnection(type, symbol), 1000);
    }
}
]]>
</file>
<file path="src/index.tsx">
<![CDATA[
// src/index.tsx
import * as React from 'react'
import { pixiExt } from './tx_server/æ—§çš„__lib/å›¾è¡¨/pixiExt'
import { å…¨å±€_____State } from './client/å…¨å±€_____State'
import { useRefresh, å¿«æ·é”®_init, APPUIRefresh } from './client/å¿«æ·é”®_init'
import { é¼ æ ‡æ“ä½œ_func } from './client/é¼ æ ‡æ“ä½œ_init'
import { Graphics } from 'pixi.js'

import {
    ControlledMenu,
    MenuDivider,
    MenuItem,
    SubMenu
} from '@szhsin/react-menu'
import '@szhsin/react-menu/dist/index.css'

import ReactDOM from 'react-dom'
import { ChartView } from './tx_server/æ—§çš„__lib/å›¾è¡¨/ChartView'
import { S____________________S } from './client/S____________________S'
import { getPrivateSubject, getSymbolå¤šå°‘å€, get_SLå‡€å€¼, get_å‡€å€¼, getå½“å‰å¤šå°‘å€ } from './tx_server/æ—§çš„__lib/å›¾è¡¨/binanceSubject'
import { toK } from './tx_server/æ—§çš„__lib/é€šç”¨/toK'
import { console_ç‰ˆæœ¬å· } from './console_ç‰ˆæœ¬å·'
import { kl_client } from './kl_server/kl_client'
import { CustomCell } from './client/CustomCell'
import { uniq } from 'ramda'
import { æé†’server__Client } from './tx_server/æé†’server__Client'
import { æé†’_Key } from './tx_server/æé†’server__newRealDB'
import { View } from './_____lib/View'
import { è¡¨æ ¼é¢œè‰² } from './è¡¨æ ¼é¢œè‰²'
import { symbolæ˜¾ç¤º } from './tx_server/æ—§çš„__lib/å›¾è¡¨/symbolæ˜¾ç¤ºé˜…è¯»'
import { fetchContracts, getTopTurnoverRates } from './cryptoInfo_server/contractsClient'
import { DetailPanel } from './cryptonews/detailpanel'
import { SymbolRankingStats } from './kl_server/statisticalDataTypes'
import { APPå‚æ•° } from './______________config/APPå‚æ•°'

const get24å°æ—¶æ¶¨å¹… = (symbol: string) => {
    return kl_client.c3?.realDB.data.rankings[symbol]?._1å¤©æ¶¨å¹… ?? 0;
}

const get____arr = (): Array<{ symbol: string, data: SymbolRankingStats }> => {
    if (!kl_client.c3?.realDB.data.rankings) return [];
    return Object.entries(kl_client.c3.realDB.data.rankings)
        .map(([symbol, data]) => ({ symbol, data: data! }));
}

const getSymbolValue = (symbol: string) => {
    return {
        symbol,
        message: '',
        value: get24å°æ—¶æ¶¨å¹…(symbol),
    }
}

let binanceä»“ä½: string[] = []
getPrivateSubject().subscribe(v => {
    binanceä»“ä½ =
        uniq([...Object.entries(v.positionDic)
            .filter(v => v[1].å¤šä»“.size !== 0 || v[1].ç©ºä»“.size !== 0)
            .map(v => v[0]),
        ...Object.entries(v.orderDic).map(v => v[0]),
        ]).map(v => v)
})

export const formatTurnoverRate = (rate: number): string => {
    if (!rate || rate < 0.01) return '<0.01%';
    return rate.toFixed(2) + '%';
};

const getTypeArr = (type: 'è‡ªé€‰' | 'ä»“ä½' | 'æ¢æ‰‹ç‡') => {
    if (type === 'æ¢æ‰‹ç‡') {
        return getTopTurnoverRates(10).map(contract => ({
            symbol: contract.symbol,
            message: `${symbolæ˜¾ç¤º(contract.symbol)} ${formatTurnoverRate(contract.turnoverRate || 0)}`,
            value: contract.turnoverRate || 0
        }));
    } else if (type === 'è‡ªé€‰') {
        const arr = Object.entries(æé†’server__Client.realDB.mutableData.state)
            .filter(v => v[1]!.isè‡ªé€‰)
            .map(v => getSymbolValue(v[0]));
        arr.push({
            symbol: 'CAPITALCOM:US500',
            message: 'æ ‡æ™®500æœŸè´§',
            value: 0,
        });
        return arr;
    } else if (type === 'ä»“ä½') {
        return binanceä»“ä½.map(getSymbolValue).map(v => ({
            ...v,
            message: (get24å°æ—¶æ¶¨å¹…(v.symbol) * 100).toFixed(2) + '% ' + ' ' + symbolæ˜¾ç¤º(v.symbol) + '_____' + getSymbolå¤šå°‘å€(v.symbol, get_å‡€å€¼(s => kl_client.get24æœ€æ–°(s).æœ€æ–°ä»·æ ¼)).toFixed(2) + 'å€'
        }));
    }
    return [];
};

const __getæé†’ = (key: æé†’_Key) => {
    return Object.entries(æé†’server__Client.realDB.mutableData.logList[key] || [])
        .map(v => ({
            ...getSymbolValue(v[1].symbol),
            message: v[1].message,
        })).reverse();
};

console_ç‰ˆæœ¬å·()
console.log('URL symbolList:', APPå‚æ•°.symbolList);

const isMultiChartMode = APPå‚æ•°.symbolList.split('_').filter(Boolean).length > 1;
console.log(`[index.tsx] æ¨¡å¼åˆ¤æ–­: isMultiChartMode = ${isMultiChartMode} (åŸºäºæœ€ç»ˆçš„ symbolList)`);

export let updateäº¤æ˜“å“ç§åˆ—è¡¨: () => void;
const DYNAMIC_LIST_SIZE = 9;

const createUpdateäº¤æ˜“å“ç§åˆ—è¡¨ = () => {
    let lastDynamicSymbols: string[] = [];
    let consecutiveEmptyDataCount = 0;

    return (): void => {
        console.log('%c[UI Update] å¼€å§‹æ‰§è¡Œ updateäº¤æ˜“å“ç§åˆ—è¡¨', 'color: purple; font-weight: bold;');
        
        if (å…¨å±€_____State.__arr === null || å…¨å±€_____State.__arr.length === 0) {
            consecutiveEmptyDataCount++;
            if (consecutiveEmptyDataCount <= 3 || consecutiveEmptyDataCount % 10 === 0) {
                console.warn(`[UI Update] ç»Ÿè®¡æ•°æ® (__arr) æœªå°±ç»ª, æš‚æ—¶è·³è¿‡åŠ¨æ€åˆ—è¡¨æ›´æ–° (ç¬¬${consecutiveEmptyDataCount}æ¬¡)`);
            }
            return;
        }
        consecutiveEmptyDataCount = 0;

        // --- å“ç§è®¡ç®—é€»è¾‘ ---
        const allSymbolsWithGain = å…¨å±€_____State.__arr.map(item => ({
            symbol: item.symbol,
            value: item.data._2å°æ—¶æ¶¨å¹…,
        }));

        const priceAlertSymbol = __getæé†’('åˆ—è¡¨1')[0]?.symbol;
        const volumeAlertSymbol = __getæé†’('åˆ—è¡¨2')[0]?.symbol;
        const klineAlertSymbol = __getæé†’('åˆ—è¡¨3')[0]?.symbol;
        
        const alertSymbols = [
            priceAlertSymbol || lastDynamicSymbols.find(s => s.endsWith('USDT')),
            volumeAlertSymbol,
            klineAlertSymbol
        ];

        const baseFixedSymbols = ['BTCUSDT', 'CAPITALCOM:US500'];
        const fillerCandidates = allSymbolsWithGain
            .sort((a, b) => b.value - a.value)
            .map(item => item.symbol)
            .filter(symbol => ![...alertSymbols, ...baseFixedSymbols].includes(symbol));

        const baseDynamicSymbols = fillerCandidates.slice(0, 4);

        const dynamicCandidates = uniq([
            ...baseDynamicSymbols,
            ...baseFixedSymbols,
            ...alertSymbols,
        ]);

        // ã€ä¿®æ”¹ 1ã€‘: è®¡ç®—å‡ºå®Œæ•´çš„ã€æœ€ç»ˆè¦å±•ç¤ºçš„åˆ—è¡¨
        const fullNewSymbolList = dynamicCandidates
            .filter((s): s is string => !!s)
            .slice(0, DYNAMIC_LIST_SIZE);
        
        // --- ã€ä¿®æ”¹ 2ã€‘: ç²¾ç¡®è®¡ç®—å‡ºâ€œæ–°å¢â€å’Œâ€œç§»é™¤â€çš„å“ç§ ---
        const lastSymbolsSet = new Set(lastDynamicSymbols);
        const newlyAddedSymbols = fullNewSymbolList.filter(s => !lastSymbolsSet.has(s));
        const removedSymbols = lastDynamicSymbols.filter(s => !fullNewSymbolList.includes(s));

        // å¦‚æœåˆ—è¡¨å†…å®¹æ²¡æœ‰å˜åŒ–ï¼Œåˆ™è·³è¿‡æ‰€æœ‰æ“ä½œ
        if (newlyAddedSymbols.length === 0 && removedSymbols.length === 0) {
            return;
        }
        
        console.log(`[UI Update] æœ¬æ¬¡åŠ¨æ€è®¡ç®—æœ€ç»ˆåˆ—è¡¨:`, fullNewSymbolList);
        const symbolsThatNeedData = newlyAddedSymbols.filter(symbol => {
            // æˆ‘ä»¬ä»¥5åˆ†é’ŸKçº¿(ç´¢å¼•ä¸º1)æ˜¯å¦å­˜åœ¨ä½œä¸ºåˆ¤æ–­ä¾æ®
            const kline = kl_client.getKline(symbol, 1); 
            // å¦‚æœé•¿åº¦ä¸º0ï¼Œè¯´æ˜è¿™ä¸ªå“ç§çš„æ•°æ®è¿˜æ²¡æ¥
            return kline.length === 0;
        });
        
        // ã€ä¿®æ”¹ 3ã€‘: éµç…§æŒ‡ç¤ºï¼Œåªå°†â€œæ–°å¢çš„å“ç§åˆ—è¡¨â€ä¼ é€’ç»™è®¢é˜…å‡½æ•°
        if (symbolsThatNeedData.length > 0) {
            console.log(`%c[UI Update] å‘ç° ${symbolsThatNeedData.length} ä¸ªçœŸæ­£éœ€è¦ä¸‹è½½çš„å“ç§ï¼Œæ­£åœ¨è¯·æ±‚ K çº¿å¿«ç…§...`, 'color: orange; font-weight: bold;', symbolsThatNeedData);
            kl_client.addSymbolKline(symbolsThatNeedData);
        }

        // --- åç»­é€»è¾‘ä½¿ç”¨â€œå®Œæ•´åˆ—è¡¨â€æ¥æ›´æ–°çŠ¶æ€å’ŒUI ---
        
        // æ›´æ–° lastDynamicSymbols ä»¥å¤‡ä¸‹æ¬¡æ¯”è¾ƒ
        lastDynamicSymbols = [...fullNewSymbolList];
        
        // æ›´æ–°UI
        å…¨å±€_____State.removeAllByIndexäº¤æ˜“å“ç§();
        fullNewSymbolList.forEach(symbol => å…¨å±€_____State.addäº¤æ˜“å“ç§(symbol));
        
        console.log('%c[UI Update] åŠ¨æ€åˆ—è¡¨æ›´æ–°åŒæ­¥å®Œæˆ (UIå·²åˆ·æ–°)', 'color: purple; font-weight: bold;');
    }
}

const getContractsInfo = async () => {
    try {
        const contractsData = await fetchContracts()
        console.log('åˆçº¦ä¿¡æ¯:', contractsData) // åˆçº¦ä¿¡æ¯ç…§å¸¸è·å–
    } catch (error) {
        console.error('è·å–åˆçº¦ä¿¡æ¯å¤±è´¥:', error)
    }
}

let ä½™é¢ = 0;
getPrivateSubject().subscribe(v => {
    ä½™é¢ = v.USDT;
});

let å½“å‰åˆ†ç±» = 'ä¸€ä¸ªæœˆå†…ä¸Šçº¿';

const APP = class extends pixiExt.Box {
    g = new Graphics();
    isDrawing = false;

    constructor() {
        super();
        å¿«æ·é”®_init();
    }

    override ____draw() {
        if (this.isDrawing) return;
        this.isDrawing = true;

        const COUNT = å…¨å±€_____State.äº¤æ˜“å“ç§.length;
        if (COUNT === 0) {
            this.isDrawing = false;
            return;
        }
        const W_COUNT = Math.round(Math.sqrt(COUNT));
        const H_COUNT = Math.ceil(COUNT / W_COUNT);

        å…¨å±€_____State.å…¨å±index = Math.min(COUNT - 1, å…¨å±€_____State.å…¨å±index);

        while (this.children.length !== 0) this.removeChildAt(0);
        å…¨å±€_____State.äº¤æ˜“å“ç§.forEach((v) => {
            this.addChild(v.chartBox);
            this.addChild(v.chartBoxVOL);
        });
        this.addChild(this.g);
        this.g.clear();

        for (let i = 0; i < COUNT; i++) {
            const len = å…¨å±€_____State.äº¤æ˜“å“ç§[i].baseSymbol.getKLine(å…¨å±€_____State.å½“å‰å‘¨æœŸindex).length;
            const left = å…¨å±€_____State.æ”¾å¤§ç¼©å°å¹³ç§».showRange.left + len;
            const right = å…¨å±€_____State.æ”¾å¤§ç¼©å°å¹³ç§».showRange.right + len;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.viewBox.left = left;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.viewBox.right = right;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.viewBox.left = left;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.viewBox.right = right;
        }

        if (å…¨å±€_____State.äº¤æ˜“å“ç§.length === 2 && å…¨å±€_____State.äº¤æ˜“å“ç§[0].baseSymbol.info.symbol === å…¨å±€_____State.äº¤æ˜“å“ç§[1].baseSymbol.info.symbol) {
            const a = å…¨å±€_____State.äº¤æ˜“å“ç§[1].baseSymbol.getKLine(å…¨å±€_____State.å½“å‰å‘¨æœŸindex).length;
            const b = å…¨å±€_____State.äº¤æ˜“å“ç§[0].baseSymbol.getKLine(4).length;
            const å·® = b - a;
            å…¨å±€_____State.äº¤æ˜“å“ç§[0].chartBox.viewBox.left += å·®;
            å…¨å±€_____State.äº¤æ˜“å“ç§[0].chartBox.viewBox.right += å·®;
            å…¨å±€_____State.äº¤æ˜“å“ç§[0].chartBoxVOL.viewBox.left += å·®;
            å…¨å±€_____State.äº¤æ˜“å“ç§[0].chartBoxVOL.viewBox.right += å·®;
        }

        this.g.clear();

        if (å…¨å±€_____State.å…¨å±index >= 0) {
            for (let i = 0; i < COUNT; i++) {
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.visible = false;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.visible = false;
            }
            const i = å…¨å±€_____State.å…¨å±index;
            const VOL_HEIGHT = 300;

            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.visible = true;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.x = 0;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.y = 0;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.____width = this.____width;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.____height = this.____height - VOL_HEIGHT;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.____draw();

            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.visible = true;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.x = 0;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.y = this.____height - VOL_HEIGHT;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.____width = this.____width;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.____height = VOL_HEIGHT;
            å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.____draw();
        } else {
            for (let i = 0; i < COUNT; i++) {
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.visible = true;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBoxVOL.visible = false;
            }
            const w = this.____width / W_COUNT;
            const h = this.____height / H_COUNT;
            for (let i = 0; i < COUNT; i++) {
                const x = (i % W_COUNT) * w;
                const y = Math.floor(i / W_COUNT) * h;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.x = x;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.y = y;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.____width = w;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.____height = h;
                å…¨å±€_____State.äº¤æ˜“å“ç§[i].chartBox.____draw();
            }
        }
        this.isDrawing = false;
    }
}

window.addEventListener('mouseover', () => {
    å…¨å±€_____State.controlLeftIsDown = false;
});

const ______________________ = {
    contextMenuOnClose: () => (S____________________S.å½“å‰å³é”®äº¤æ˜“ = undefined),
};

const CustomTable = (props: {
    title: React.ReactNode
    data: {
        symbol: string,
        value: number,
        message: React.ReactNode
        onClick?: () => void
        cssColor?: string
    }[]
    searchInput?: boolean
    searchText?: string
    setSearchText?: (str: string) => void
    backgroundColor?: string
}) =>
    <div style={{
        width: '100%',
        height: '100%',
        color: è¡¨æ ¼é¢œè‰².æ ‡é¢˜,
        backgroundColor: props.backgroundColor || è¡¨æ ¼é¢œè‰².èƒŒæ™¯,
        overflowY: 'auto',
    }}>
        <table style={{ width: '100%' }}>
            <thead>
                <tr className='xxxx' onMouseDown={() => {
                    const symbolsToPin = props.data.filter(v => v.symbol).map(v => v.symbol);
                    if (symbolsToPin.length > 0) {
                        console.log(`[UI] Pinning list "${props.title}" with ${symbolsToPin.length} symbols.`);
                        å…¨å±€_____State.removeAllByIndexäº¤æ˜“å“ç§();
                        symbolsToPin.forEach(symbol => å…¨å±€_____State.addäº¤æ˜“å“ç§(symbol));
                    }
                }}>
                    <td>
                        <h5>{props.title}</h5>
                    </td>
                </tr>
            </thead>
            {props.searchInput &&
                <input style={{ width: '100%' }} value={props.searchText!} onChange={e => props.setSearchText!(e.target.value)} />
            }
            <tbody>
                {props.data.map((v, i) => (
                    <tr key={i} className='xxxx'>
                        <CustomCell
                            symbol={v.symbol}
                            value={v.value}
                            message={v.message}
                            onClick={v.onClick}
                            cssColor={v.cssColor}
                        />
                    </tr>
                ))}
            </tbody>
        </table>
    </div >;

const å·¦è¾¹ = '700px';

const APPUI = () => {

    const [isOpen, setOpen] = React.useState(false);
    const [anchorPoint, setAnchorPoint] = React.useState({ x: 0, y: 0 });
    const menuArr = isOpen ? é¼ æ ‡æ“ä½œ_func() : [];
    useRefresh();
    const [searchText, setSearchText] = React.useState('');

    // ä½¿ç”¨ useRef è·Ÿè¸ªå½“å‰ä¸»äº¤æ˜“å“ç§
    const mainSymbolRef = React.useRef<string | undefined>();
    const currentMainSymbol = å…¨å±€_____State.äº¤æ˜“å“ç§[0]?.baseSymbol.info.name;

    // ã€ä¿®æ­£ã€‘è¿™ä¸ª Effect ç°åœ¨åªåœ¨ currentMainSymbol å˜åŒ–æ—¶è¿è¡Œ
    React.useEffect(() => {
        // å¦‚æœä¸»å“ç§å˜åŒ–äº†ï¼Œå°±é‡æ–°åˆå§‹åŒ–æ–°é—»é¢æ¿
        if (currentMainSymbol && currentMainSymbol !== mainSymbolRef.current) {
            console.log(`ä¸»äº¤æ˜“å“ç§å˜æ›´ä¸º: ${currentMainSymbol}ï¼Œé‡æ–°åˆå§‹åŒ–æ–°é—»é¢æ¿ã€‚`);
            initDetailPanel();
            mainSymbolRef.current = currentMainSymbol;
        }
    }, [currentMainSymbol]); // <-- ã€å…³é”®ã€‘æ·»åŠ ä¾èµ–é¡¹æ•°ç»„ï¼Œç¡®ä¿åªåœ¨å“ç§å˜åŒ–æ—¶è§¦å‘

    React.useEffect(() => {
        kl_client.onDataUpdated = APPUIRefresh;
    });

    React.useEffect(() => {
        // è¿æ¥æ—¶ä¸å†ç«‹å³å‘é€åˆå§‹å“ç§ï¼Œè®¢é˜…å°†ç”±åç»­çš„çŠ¶æ€æ›´æ–°è§¦å‘
        kl_client.connect([]);

        if (!isMultiChartMode) {
            // å•å›¾æˆ–å›ºå®šåˆ—è¡¨æ¨¡å¼ï¼šä½¿ç”¨URLå‚æ•°
            const initialSymbols = APPå‚æ•°.symbolList.split('_').filter(Boolean);
            const symbolsToLoad = initialSymbols.length > 0 ? initialSymbols : ['BTCUSDT'];
            console.log(`[UI Init] å•å›¾/å›ºå®šåˆ—è¡¨æ¨¡å¼å¯åŠ¨ï¼Œåˆå§‹å“ç§åˆ—è¡¨ç¡®å®šä¸º:`, symbolsToLoad);
            symbolsToLoad.forEach(symbol => å…¨å±€_____State.addäº¤æ˜“å“ç§(symbol));
           // kl_client.addSymbolKline(symbolsToLoad);
        } else {
            // å¤šå›¾æ¨¡å¼ï¼šä¸åŠ è½½URLå‚æ•°ä¸­çš„å“ç§ï¼Œç­‰å¾…åŠ¨æ€æ›´æ–°
            console.log('[UI Init] å¤šå›¾æ¨¡å¼å¯åŠ¨ï¼Œå°†ç­‰å¾…é¦–æ¬¡åŠ¨æ€è®¡ç®—æ¥ç¡®å®šå“ç§åˆ—è¡¨ã€‚');
        }

        const CONTRACTS_FETCH_INTERVAL = 5 * 60 * 1000;
        getContractsInfo();
        const contractsInterval = setInterval(getContractsInfo, CONTRACTS_FETCH_INTERVAL);

        let updateInterval: NodeJS.Timeout | undefined;
        if (isMultiChartMode) {
            updateäº¤æ˜“å“ç§åˆ—è¡¨ = createUpdateäº¤æ˜“å“ç§åˆ—è¡¨();
            updateInterval = setInterval(updateäº¤æ˜“å“ç§åˆ—è¡¨, 5000);
            console.log('[UI Init] å¤šå›¾æ¨¡å¼å¯åŠ¨ï¼Œå·²å¼€å¯åŠ¨æ€å“ç§æ›´æ–°å®šæ—¶å™¨ (5ç§’/æ¬¡)ã€‚');
        } else {
            console.log('[UI Init] å•å›¾/å›ºå®šåˆ—è¡¨æ¨¡å¼å¯åŠ¨ï¼ŒåŠ¨æ€å“ç§æ›´æ–°å·²ç¦ç”¨ã€‚');
        }

        å…¨å±€_____State.æ˜¾ç¤ºå·¦è¾¹ = APPå‚æ•°.binanceAPIKey !== '';

        // --- ã€é‡æ„ã€‘ä½¿ç”¨æ–°çš„åŸå­åŒ–åè®®åŠ è½½çƒ­é—¨å“ç§ ---
        // const loadHotSymbolsInBackground = () => {
        //     console.log("[UI] Attempting to load hot symbols in background...");
        //     if (kl_client.c1?.isConnected) {
        //         try {
        //             console.log("[UI] Low priority channel is ready. Requesting atomic background sync for hot symbols...");
        //             // kl_client.c1.func.syncHotSymbols({});
        //         } catch (error) {
        //             console.error("[UI] Failed to initiate hot symbols sync:", error);
        //         }
        //     } else {
        //         console.log("[UI] Low priority channel not ready, will retry hot symbols sync in 1s.");
        //         setTimeout(loadHotSymbolsInBackground, 1000); // å¦‚æœé€šé“æœªå°±ç»ªï¼Œç¨åé‡è¯•
        //     }
        // };

        // --- ç›‘å¬åˆå§‹åŒæ­¥å®Œæˆä¿¡å· ---
        const checkSyncInterval = setInterval(() => {
            if (kl_client.isInitialSyncComplete) {
                console.log("[UI] Initial sync complete signal received. Triggering hot symbols load.");
                clearInterval(checkSyncInterval);
                //loadHotSymbolsInBackground();
            }
        }, 100);

        return () => {
            // æ¸…ç†å®šæ—¶å™¨
            console.log("[UI] Cleanup: Clearing intervals.");
            clearInterval(contractsInterval);
            clearInterval(checkSyncInterval);
            if (updateInterval) clearInterval(updateInterval);
        };
    }, []); // ç©ºä¾èµ–æ•°ç»„ï¼Œç¡®ä¿åªæ‰§è¡Œä¸€æ¬¡

    å…¨å±€_____State.__arr = get____arr();

    const å‡€å€¼ = get_å‡€å€¼(s => kl_client.get24æœ€æ–°(s).æœ€æ–°ä»·æ ¼);
    const SLå‡€å€¼ = get_SLå‡€å€¼();
    const æ æ† = getå½“å‰å¤šå°‘å€(å‡€å€¼);

    type KEY = keyof import('./kl_server/statisticalDataTypes').SymbolRankingStats;
    const __æ­£åº = (key: KEY) => (å…¨å±€_____State.__arr || [])
        .map(v => ({ symbol: v.symbol, value: v.data[key], message: '' }))
        .sort((b, a) => a.value - b.value)
        .slice(0, APPå‚æ•°.count);

    const __å€’åº = (key: KEY) => (å…¨å±€_____State.__arr || [])
        .map(v => ({ symbol: v.symbol, value: v.data[key], message: '' }))
        .sort((b, a) => b.value - a.value)
        .slice(0, APPå‚æ•°.count);

    const Cæœç´¢ = () => <CustomTable
        searchInput={true}
        title='æœç´¢'
        data={
            searchText === '' ?
                []
                :
                (å…¨å±€_____State.__arr || [])
                    .map(v => ({ symbol: v.symbol, value: v.data._1å¤©æ¶¨å¹…, message: '' }))
                    .filter(v => v.symbol.indexOf(searchText.toUpperCase()) !== -1)
                    .sort((a, b) => a.symbol.localeCompare(b.symbol))
        }
        searchText={searchText}
        setSearchText={setSearchText}
    />;

    const Cè‡ªé€‰ = () => <CustomTable
        title='è‡ªé€‰'
        data={getTypeArr('è‡ªé€‰')}
    />;

    const Cä»“ä½ = () => <CustomTable
        title={'ä½™é¢  ' + toK(ä½™é¢)}
        data={[
            { symbol: '', value: 0, message: <h5 style={{ color: è¡¨æ ¼é¢œè‰².æ ‡é¢˜ }}>å‡€å€¼  {toK(å‡€å€¼)}</h5>, onClick: () => { }, cssColor: 'black' },
            { symbol: '', value: 0, message: <h5 style={{ color: è¡¨æ ¼é¢œè‰².æ ‡é¢˜ }}>SLå‡€å€¼  {toK(SLå‡€å€¼)}</h5>, onClick: () => { }, cssColor: 'black' },
            { symbol: '', value: 0, message: <h5 style={{ color: è¡¨æ ¼é¢œè‰².æ ‡é¢˜ }}>æ æ†  {Number(æ æ†.toFixed(2))}å€</h5>, onClick: () => { }, cssColor: 'black' },
            ...getTypeArr('ä»“ä½')
        ]}
    />;

    const Cæˆäº¤é¢å‰15 = () => <CustomTable
        title='7æ—¥æˆäº¤é¢æ’è¡Œ'
        data={kl_client.getTurnoverTop15().map(item => ({
            symbol: item.symbol,
            value: item.turnover,
            message: <div style={{ fontSize: '12px' }}>{symbolæ˜¾ç¤º(item.symbol)} {item.turnover.toFixed(1)}äº¿</div>
        }))}
    />;

    const Cåˆ†ç±» = () => <CustomTable
        backgroundColor='#333333'
        title={<span style={{ color: 'white' }}>åˆ†ç±»</span>}
        data={
            kl_client.getæ‰‹åŠ¨_é¢˜æ_æ’åº().map(vvv => ({
                symbol: '',
                value: 0,
                message: vvv.tag + ' ' + vvv.list.length,
                onClick: () => { å½“å‰åˆ†ç±» = vvv.tag; },
                cssColor: vvv.cssColor,
            }))
        }
    />;

    const Cå½“å‰åˆ†ç±» = () => <CustomTable
        backgroundColor='#333333'
        title={<span style={{ color: 'white' }}>{å½“å‰åˆ†ç±»}</span>}
        data={
            (kl_client.getæ‰‹åŠ¨_é¢˜æ_æ’åº().find(v => v.tag === å½“å‰åˆ†ç±»)?.list || []).map(v => ({
                symbol: v.symbol,
                value: get24å°æ—¶æ¶¨å¹…(v.symbol),
                message: '',
                cssColor: v.cssColor,
            })).sort((b, a) => a.value - b.value)
        }
    />;

    return <div
        style={{
            userSelect: 'none',
            display: 'flex',
            width: '100%',
            height: '100%',
        }}>

        {(å…¨å±€_____State.å…¨å±index === -1 && å…¨å±€_____State.æ˜¾ç¤ºå·¦è¾¹) &&
            <div style={{ display: 'flex', width: å·¦è¾¹, minWidth: å·¦è¾¹, maxWidth: å·¦è¾¹, backgroundColor: è¡¨æ ¼é¢œè‰².èƒŒæ™¯ }}>
                <View.LR>
                    <View.TB>
                        {Cæœç´¢()}
                        <CustomTable title='æé†’1' data={__getæé†’('åˆ—è¡¨1')} />
                        <CustomTable title='æé†’2' data={__getæé†’('åˆ—è¡¨2')} />
                        <CustomTable title='æé†’3' data={__getæé†’('åˆ—è¡¨3')} />
                    </View.TB>
                    <View.TB>
                        <CustomTable title='5åˆ†é’Ÿæˆäº¤é¢' data={__æ­£åº('_5åˆ†é’Ÿæˆäº¤é¢')} />
                        <CustomTable title='1å°æ—¶æˆäº¤é¢' data={__æ­£åº('_1å°æ—¶æˆäº¤é¢')} />
                        <CustomTable title='4å°æ—¶æˆäº¤é¢' data={__æ­£åº('_4å°æ—¶æˆäº¤é¢')} />
                        <CustomTable title='1å¤©æˆäº¤é¢' data={__æ­£åº('_1å¤©æˆäº¤é¢')} />
                    </View.TB>
                    <View.TB>
                        <CustomTable title='15åˆ†é’Ÿæ¶¨å¹…' data={__æ­£åº('_15åˆ†é’Ÿæ¶¨å¹…')} />
                        <CustomTable title='15åˆ†é’Ÿè·Œå¹…' data={__å€’åº('_15åˆ†é’Ÿæ¶¨å¹…')} />
                        <CustomTable title='2å°æ—¶æ¶¨å¹…' data={__æ­£åº('_2å°æ—¶æ¶¨å¹…')} />
                        <CustomTable title='1å¤©æ¶¨å¹…' data={__æ­£åº('_1å¤©æ¶¨å¹…')} />
                    </View.TB>
                    <View.TB>
                        {Cè‡ªé€‰()}
                        <CustomTable title='60sæˆäº¤é¢' data={__æ­£åº('_60ç§’æˆäº¤é¢')} />
                        {Cä»“ä½()}
                        {Cæˆäº¤é¢å‰15()}
                    </View.TB>
                    <View.TB>
                        {Cåˆ†ç±»()}
                        {Cå½“å‰åˆ†ç±»()}
                    </View.TB>
                </View.LR>
            </div>
        }
        <div
            onContextMenu={e => {
                e.preventDefault();
                if (é¼ æ ‡æ“ä½œ_func().length !== 0) {
                    setAnchorPoint({ x: e.clientX, y: e.clientY });
                    setOpen(true);
                }
            }}
            style={{
                display: 'flex',
                width: (å…¨å±€_____State.å…¨å±index === -1 && å…¨å±€_____State.æ˜¾ç¤ºå·¦è¾¹) ? `calc(100% - ${å·¦è¾¹})` : '100%',
            }}
        >
            <ChartView C={APP} />
        </div>
        <ControlledMenu
            anchorPoint={anchorPoint}
            isOpen={isOpen}
            onClose={() => {
                setOpen(false)
                ______________________.contextMenuOnClose()
            }}
        >{
                menuArr.map((v, i) => {
                    if (v.type === 'separator') return <MenuDivider key={i} />
                    if (v.submenu) {
                        return <SubMenu key={i} label={v.label}>{
                            (v.submenu as any[]).map((v, i) => (
                                <MenuItem key={i} type={v.type === 'checkbox' ? 'checkbox' : undefined} checked={v.checked} disabled={v.enabled === false} onClick={v.click as any}>{v.label}</MenuItem>
                            ))
                        }</SubMenu>
                    }
                    return <MenuItem key={i} type={v.type === 'checkbox' ? 'checkbox' : undefined} checked={v.checked} disabled={v.enabled === false} onClick={v.click as any}>{v.label}</MenuItem>
                })
            }
        </ControlledMenu>
    </div >
}

export const initDetailPanel = () => {
    if (å…¨å±€_____State.äº¤æ˜“å“ç§.length === 0) return;
    const currentsymbol = å…¨å±€_____State.äº¤æ˜“å“ç§[0].baseSymbol.info.name;
    const iframe = document.getElementById('detailsPanel') as HTMLIFrameElement;
    if (!iframe) return;
    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
    if (iframeDoc) {
        iframeDoc.body.innerHTML = '';
        const container = iframeDoc.createElement('div');
        iframeDoc.body.appendChild(container);
        ReactDOM.render(<DetailPanel symbol={currentsymbol} />, container);
    }
}

declare global {
    interface Window {
        initDetailPanel: () => void;
    }
}
window.initDetailPanel = initDetailPanel;

ReactDOM.render(<APPUI />, document.querySelector('#root'));
]]>
</file>
<file path="src/kl_server/åˆçº¦__getKLine_ext.ts">
<![CDATA[
// import { ç§æœ‰API_get_cg_æŒä»“é‡ } from "../_____lib/API/ç§æœ‰API/ç§æœ‰API_get_cg_æŒä»“é‡";
import { BinanceInterval } from "./BinanceInterval";
import { binanceè¡Œæƒ…_HTTP } from "../_____lib/API/è¡Œæƒ…API/binanceè¡Œæƒ…_HTTP";

type RequestOptions = {
    purpose?: 'concurrent' | 'default'
}

export const åˆçº¦__getKLine_ext = async (p: {
    symbol: string;
    interval: BinanceInterval
    limit: number
}, options?: RequestOptions) => {
    // const a = await binanceè¡Œæƒ…_HTTP.ç°è´§__getKLine(p)
    // return a

    const a = await binanceè¡Œæƒ…_HTTP.åˆçº¦__getKLine(p, options)
    // const b = await ç§æœ‰API_get_cg_æŒä»“é‡(p)

    // if (a && b) {
    //     for (let i = 0; i < a.length; i++) {
    //         const index = b.length - a.length + i
    //         if (index >= 0) {
    //             a[i].ext_æŒä»“é‡ = b[index].close
    //         }
    //     }
    //     return a
    // } else {
    //     return undefined
    // }

    return a
}
]]>
</file>
<file path="src/kl_server/ç»Ÿè®¡ä¿¡æ¯è®¡ç®—.ts">
<![CDATA[
// src/kl_server/ç»Ÿè®¡ä¿¡æ¯è®¡ç®—.ts

import { baServer2 } from "./baServer2";
import { baServer1, baServer3 } from "./servers";
import { SymbolRankingStats } from "./statisticalDataTypes";
import { c_log } from "../_____lib/func/c_log";
import { latestPriceCache } from "./latestPriceCache";

const UPDATE_INTERVAL_MS = 1000; // æ¯ç§’æœ€å¤šæ‰¹é‡æ›´æ–°ä¸€æ¬¡

/**
 * èŒè´£å•ä¸€çš„è®¡ç®—å‡½æ•°ï¼Œå°è£…åœ¨å‘½åç©ºé—´å†…ã€‚
 */
namespace Calculators {
    // ä¸ºäº†æ€§èƒ½ï¼Œå°†Kçº¿è·å–å’Œè®¡ç®—åˆ†ç¦»
    const _getåˆ†é’Ÿæ¶¨å¹… = (kline1m: any, latestPrice: number | undefined, n_åˆ†é’Ÿ: number) => {
        if (!kline1m || kline1m.length < 2) return 0;
        const closes = kline1m.data.close;
        const æœ€æ–°ä»·æ ¼ = latestPrice ?? closes[closes.length - 1];
        const æ—§ä»·æ ¼ = closes[Math.max(0, closes.length - n_åˆ†é’Ÿ - 1)];
        if (æ—§ä»·æ ¼ === 0) return 0;
        return æœ€æ–°ä»·æ ¼ / æ—§ä»·æ ¼ - 1;
    };

    const _get24å°æ—¶æ¶¨å¹… = (kline1m: any, kline5m: any, latestPrice: number | undefined) => {
        if (!kline1m || kline1m.length === 0 || !kline5m || kline5m.length < 2) return 0;
        const æœ€æ–°ä»·æ ¼ = latestPrice ?? kline1m.data.close[kline1m.length - 1];
        const close5m = kline5m.data.close;
        const n = 24 * 12; // 24å°æ—¶, æ¯å°æ—¶12æ ¹5åˆ†é’ŸKçº¿
        const æ—§ä»·æ ¼ = close5m[Math.max(0, close5m.length - n - 1)];
        if (æ—§ä»·æ ¼ === 0) return 0;
        return æœ€æ–°ä»·æ ¼ / æ—§ä»·æ ¼ - 1;
    };

    const _getXæˆäº¤é¢ = (kline: any, n: number) => {
        if (!kline || kline.length === 0) return 0;
        const volumes = kline.data.æˆäº¤é¢;
        let sum = 0;
        for (let i = volumes.length - 1; i >= Math.max(0, volumes.length - n); i--) {
            sum += volumes[i];
        }
        return sum;
    };

    export function calculateRankingStats(symbol: string): SymbolRankingStats {
        // ä¸€æ¬¡æ€§è·å–æ‰€æœ‰éœ€è¦çš„æ•°æ®
        const kline1s = baServer1.realDB.get_kline(`${symbol}_-1`);
        const kline1m = baServer1.realDB.get_kline(`${symbol}_0`);
        const kline5m = baServer1.realDB.get_kline(`${symbol}_1`);
        const latestPrice = latestPriceCache.get(symbol);
        const kline1d = baServer1.realDB.get_kline(`${symbol}_4`); // è·å–æ—¥Kçº¿ (index 4)

        return {
            _15åˆ†é’Ÿæ¶¨å¹…: _getåˆ†é’Ÿæ¶¨å¹…(kline1m, latestPrice, 15),
            _2å°æ—¶æ¶¨å¹…: _getåˆ†é’Ÿæ¶¨å¹…(kline1m, latestPrice, 120),
            _1å¤©æ¶¨å¹…: _get24å°æ—¶æ¶¨å¹…(kline1m, kline5m, latestPrice),
            _10ç§’æˆäº¤é¢: _getXæˆäº¤é¢(kline1s, 10),
            _30ç§’æˆäº¤é¢: _getXæˆäº¤é¢(kline1s, 30),
            _60ç§’æˆäº¤é¢: _getXæˆäº¤é¢(kline1s, 60),
            _5åˆ†é’Ÿæˆäº¤é¢: _getXæˆäº¤é¢(kline1m, 5),
            _15åˆ†é’Ÿæˆäº¤é¢: _getXæˆäº¤é¢(kline1m, 15),
            _1å°æ—¶æˆäº¤é¢: _getXæˆäº¤é¢(kline1m, 60),
            _4å°æ—¶æˆäº¤é¢: _getXæˆäº¤é¢(kline5m, 12 * 4),
            _1å¤©æˆäº¤é¢: _getXæˆäº¤é¢(kline5m, 12 * 24),
            _7å¤©æˆäº¤é¢: _getXæˆäº¤é¢(kline1d, 7), // ç´¯åŠ æœ€è¿‘7æ ¹æ—¥Kçº¿çš„æˆäº¤é¢
        };
    }
}

class StatsCalculatorService {
    private symbolsToUpdate = new Set<string>();

    public start() {
        c_log(`[ç»Ÿè®¡è®¡ç®—æœåŠ¡ V3-æ··åˆæ¨¡å¼] å¯åŠ¨ï¼Œæ¯${UPDATE_INTERVAL_MS}msæ‰¹é‡æ›´æ–°`);
        this._initialize();
        setInterval(() => this._processUpdates(), UPDATE_INTERVAL_MS);
    }

    /**
     * å…¬å¼€APIï¼šä¾›å¤–éƒ¨ç›´æ¥è°ƒç”¨ï¼Œä»¥å®‰æ’ä¸€ä¸ªå“ç§è¿›è¡Œä¸‹ä¸€æ¬¡æ‰¹é‡æ›´æ–°ã€‚
     * è¿™æ›¿ä»£äº† PubSub äº‹ä»¶ã€‚
     */
    public scheduleUpdate(symbol: string) {
        this.symbolsToUpdate.add(symbol);
    }

    private _updateSymbol(symbol: string) {
        try {
            const rankingStats = Calculators.calculateRankingStats(symbol);
            baServer3.realDB.__(v => v.rankings[symbol]).set(rankingStats);
        } catch (e) {
            console.error(`[ç»Ÿè®¡è®¡ç®—æœåŠ¡] è®¡ç®— ${symbol} å¤±è´¥:`, e);
        }
    }

    private _initialize() {
        const allSymbols = Object.keys(baServer2.realDB.data.åˆçº¦_info);
        if (allSymbols.length === 0) {
            c_log('[ç»Ÿè®¡è®¡ç®—æœåŠ¡] åˆçº¦ä¿¡æ¯ä¸ºç©ºï¼Œ5ç§’åé‡è¯•åˆå§‹è®¡ç®—...');
            setTimeout(() => this._initialize(), 5000);
            return;
        }
        c_log(`[ç»Ÿè®¡è®¡ç®—æœåŠ¡] å¼€å§‹ä¸º ${allSymbols.length} ä¸ªå“ç§æ‰§è¡Œåˆå§‹è®¡ç®—...`);
        allSymbols.forEach(symbol => this.scheduleUpdate(symbol));
    }

    private _processUpdates() {
        if (this.symbolsToUpdate.size === 0) return;
        // Set å·²ç»æ˜¯å”¯ä¸€çš„ï¼Œæ— éœ€ ramda.uniq
        const symbols = Array.from(this.symbolsToUpdate);
        this.symbolsToUpdate.clear();
        symbols.forEach(symbol => this._updateSymbol(symbol));
    }
}

export const statsCalculator = new StatsCalculatorService();
]]>
</file>
<file path="src/kl_server/BA_1.ts">
<![CDATA[
// src/kl_server/BA_1.ts
import { RealDB } from "../_____lib/net/sync/RealDBBase";
import { ONE_K } from "./ONE_K";
import { K_Line } from "./ONE_K";
import { safeJSONParse } from "../_____lib/net/safeJSONParse";
import { binance_kline_å‘¨æœŸ_é…ç½® } from "./binance_kline_å‘¨æœŸ_é…ç½®";
import { SyncInfo } from "../_____lib/net/sync/SyncInfo";
import { formatBytes } from "../_____lib/formatæ ¼å¼åŒ–/formatBytes";
import { kl_state } from "./kl_state";
// import { kl_client } from "./kl_client"; // ã€å…³é”®ä¿®æ”¹ã€‘ç§»é™¤é¡¶å±‚çš„å¾ªç¯å¯¼å…¥
import { isNodejs } from "../_____lib/net/isNodejs";
import { c_log } from "../_____lib/func/c_log";

const SYMBOL_PERIOD_BYTE_LENGTH = 32;

const ONE_RECORD_BYTE_LENGTH = (
    SYMBOL_PERIOD_BYTE_LENGTH +
    K_Line.å­—èŠ‚æ•°
);

type OP = { type: 'set', kline: ONE_K[] }
    |
{ type: 'push' | 'updateLast', kline: ONE_K }

type OpUpdateLast = { type: 'updateLast', kline: ONE_K };

export class ALL_K extends RealDB {
    // Common - Client side is a Map, Server side uses this as a view cache over ArrayBuffer
    private state__dic: { [symbol_å‘¨æœŸ: string]: K_Line } = {};

    // Server-side properties
    private server_ab?: ArrayBuffer;
    private server_recordCount = new Uint32Array(); // View over server_ab
    private server_symbolToIndex: { [symbol_å‘¨æœŸ: string]: number } = {};
    private server_currentIndex = 0;
    private server_op: { [symbol_å‘¨æœŸ: string]: OP[] } = {};

    // Server-side monitoring
    public diffStats: { [symbol: string]: { [period: string]: number } } = {};
    public isStatsLocked = false;

    // Client-side properties
    private client_map: Map<string, K_Line> = new Map();
    // Client-side monitoring
    private client_diffStats: Map<string, number> = new Map();


    private ensureKlineObject(symbol_å‘¨æœŸ: string): K_Line {
        if (isNodejs()) { // Server logic
            if (this.state__dic[symbol_å‘¨æœŸ] === undefined) {
                if (!this.server_ab) throw new Error("Server ArrayBuffer not initialized");

                const index = this.server_currentIndex++;
                this.server_symbolToIndex[symbol_å‘¨æœŸ] = index;
                this.server_recordCount[0] = this.server_currentIndex;

                const recordOffset = 8 + index * ONE_RECORD_BYTE_LENGTH;
                const encoder = new TextEncoder();
                encoder.encodeInto(symbol_å‘¨æœŸ, new Uint8Array(this.server_ab, recordOffset, SYMBOL_PERIOD_BYTE_LENGTH));

                const klineOffset = recordOffset + SYMBOL_PERIOD_BYTE_LENGTH;
                this.state__dic[symbol_å‘¨æœŸ] = new K_Line(this.server_ab, klineOffset);
            }
            return this.state__dic[symbol_å‘¨æœŸ];
        } else { // Client logic
            throw new Error("Client should not call ensureKlineObject without providing buffer and offset via parseSnapshot");
        }
    }

    // --- Server-side methods ---
    init(å“ç§æ•°é‡: number) {
        if (!isNodejs()) return;
        const å­—èŠ‚æ•° = 8 + å“ç§æ•°é‡ * ONE_RECORD_BYTE_LENGTH * (binance_kline_å‘¨æœŸ_é…ç½®.length + 2); // +2 for 1s and other potential periods
        kl_state.å†…å­˜str = formatBytes(å­—èŠ‚æ•°)
        this.server_ab = new ArrayBuffer(å­—èŠ‚æ•°)
        this.server_recordCount = new Uint32Array(this.server_ab, 0, 2)
        c_log(`[BA_1 Server DB] Initialized with ${formatBytes(å­—èŠ‚æ•°)} ArrayBuffer for ~${å“ç§æ•°é‡} symbols.`);
    }

    set(symbol_å‘¨æœŸ: string, arr: ONE_K[]) {
        if (!isNodejs()) return;
        const kl = this.ensureKlineObject(symbol_å‘¨æœŸ);
        kl.set(arr);
        // if (!this.server_op[symbol_å‘¨æœŸ]) this.server_op[symbol_å‘¨æœŸ] = [];
        // this.server_op[symbol_å‘¨æœŸ].push({ type: 'set', kline: arr });
    }

    push(symbol_å‘¨æœŸ: string, one: ONE_K) {
        if (!isNodejs()) return;
        const kl = this.ensureKlineObject(symbol_å‘¨æœŸ);
        kl.push(one);
        if (!this.server_op[symbol_å‘¨æœŸ]) this.server_op[symbol_å‘¨æœŸ] = [];
        this.server_op[symbol_å‘¨æœŸ].push({ type: 'push', kline: one });
    }

    updateLast(symbol_å‘¨æœŸ: string, one: ONE_K) {
        if (!isNodejs()) return;
        const kl = this.ensureKlineObject(symbol_å‘¨æœŸ);
        kl.updateLast(one);
        if (!this.server_op[symbol_å‘¨æœŸ]) this.server_op[symbol_å‘¨æœŸ] = [];
        const ops = this.server_op[symbol_å‘¨æœŸ];
        if (ops.length > 0 && ops[ops.length - 1].type === 'updateLast') {
            (ops[ops.length - 1] as OpUpdateLast).kline = one;
        } else {
            ops.push({ type: 'updateLast', kline: one });
        }
    }

    override get__all() {
        if (!isNodejs()) return undefined;
        return this.server_ab ? new Uint8Array(this.server_ab, 0, 8 + this.server_currentIndex * ONE_RECORD_BYTE_LENGTH) : undefined;
    }

    override get__diff(activeSymbols: Set<string>) {
        if (!isNodejs()) return undefined;

        if (Object.keys(this.server_op).length === 0) {
            return undefined;
        }

        const opsToSend = this.server_op;

        if (!this.isStatsLocked) {
            for (const symbol_å‘¨æœŸ in opsToSend) {
                const ops = opsToSend[symbol_å‘¨æœŸ];
                if (ops.length > 0) {
                    const [symbol, period] = symbol_å‘¨æœŸ.split('_');
                    if (!this.diffStats[symbol]) {
                        this.diffStats[symbol] = {};
                    }
                    const opCount = ops.reduce((sum, op) => {
                        if (op.type === 'set') return sum + op.kline.length;
                        return sum + 1;
                    }, 0);
                    this.diffStats[symbol][period] = (this.diffStats[symbol][period] || 0) + opCount;
                }
            }
        }

        const diffBuffer = new TextEncoder().encode(JSON.stringify(opsToSend));
        this.server_op = {};

        return diffBuffer;
    }

    override get__partial(symbols: string[]) {
        if (!isNodejs() || !this.server_ab) return undefined;
        const recordsToSend: { index: number, symbol_å‘¨æœŸ: string }[] = [];
        const symbolSet = new Set(symbols);

        for (const symbol_å‘¨æœŸ in this.server_symbolToIndex) {
            const [symbol] = symbol_å‘¨æœŸ.split('_');
            if (symbolSet.has(symbol)) {
                recordsToSend.push({ index: this.server_symbolToIndex[symbol_å‘¨æœŸ], symbol_å‘¨æœŸ });
            }
        }

        if (recordsToSend.length === 0) {
            return undefined;
        }

        const partialBufferSize = 8 + recordsToSend.length * ONE_RECORD_BYTE_LENGTH;
        const partialBuffer = new ArrayBuffer(partialBufferSize);
        new Uint32Array(partialBuffer, 0, 1)[0] = recordsToSend.length;

        recordsToSend.forEach((record, i) => {
            const destOffset = 8 + i * ONE_RECORD_BYTE_LENGTH;
            const srcOffset = 8 + record.index * ONE_RECORD_BYTE_LENGTH;
            new Uint8Array(partialBuffer, destOffset, ONE_RECORD_BYTE_LENGTH).set(
                new Uint8Array(this.server_ab!, srcOffset, ONE_RECORD_BYTE_LENGTH)
            );
        });

        return new Uint8Array(partialBuffer);
    }

    public get__partial_for_one_period(symbol: string, periodIndex: string): Uint8Array | undefined {
        if (!isNodejs() || !this.server_ab) return undefined;

        const symbol_å‘¨æœŸ = `${symbol}_${periodIndex}`;
        const recordIndex = this.server_symbolToIndex[symbol_å‘¨æœŸ];

        if (recordIndex === undefined) {
            return undefined;
        }

        const partialBufferSize = 8 + ONE_RECORD_BYTE_LENGTH;
        const partialBuffer = new ArrayBuffer(partialBufferSize);
        new Uint32Array(partialBuffer, 0, 1)[0] = 1;

        const destOffset = 8;
        const srcOffset = 8 + recordIndex * ONE_RECORD_BYTE_LENGTH;
        new Uint8Array(partialBuffer, destOffset, ONE_RECORD_BYTE_LENGTH).set(
            new Uint8Array(this.server_ab, srcOffset, ONE_RECORD_BYTE_LENGTH)
        );

        return new Uint8Array(partialBuffer);
    }

    // --- Client-side methods ---
    private parseSnapshot(buf: Uint8Array): { count: number; symbols: string[] } {
        if (isNodejs()) return { count: 0, symbols: [] };

        const timeLabel = `[BA_1 Client DB] parseSnapshot size ${buf.byteLength}`;
        console.time(timeLabel);

        const symbols: string[] = [];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        const recordCount = new Uint32Array(ab, 0, 1)[0];

        for (let i = 0; i < recordCount; i++) {
            const recordOffset = 8 + i * ONE_RECORD_BYTE_LENGTH;
            const symbolBytes = new Uint8Array(ab, recordOffset, SYMBOL_PERIOD_BYTE_LENGTH);
            const symbol_å‘¨æœŸ = new TextDecoder().decode(symbolBytes).replace(/\u0000/g, '');
            symbols.push(symbol_å‘¨æœŸ);
            const klineOffset = recordOffset + SYMBOL_PERIOD_BYTE_LENGTH;
            const klineDataBuffer = ab.slice(klineOffset, klineOffset + K_Line.å­—èŠ‚æ•°);
            this.client_map.set(symbol_å‘¨æœŸ, new K_Line(klineDataBuffer, 0));
        }
        
        console.timeEnd(timeLabel);
        return { count: recordCount, symbols };
    }

    override set__all(buf: Uint8Array): string[] | void {
        if (isNodejs()) return;
        const time = new Date().toISOString().slice(11, 23);
        c_log(`[${time}] [BA_1 Client DB] set__all: Clearing all data and applying full snapshot.`);
        this.client_map.clear();
        const { count, symbols } = this.parseSnapshot(buf);
        c_log(`[${time}] [BA_1 Client DB] set__all: Parsed ${count} records. Total keys now: ${this.client_map.size}.`);
        
        // ã€å…³é”®ä¿®æ”¹ã€‘åœ¨å‡½æ•°å†…éƒ¨åŠ¨æ€åŠ è½½ kl_client
        const { kl_client } = require("./kl_client");
        kl_client.signalInitialSyncComplete();
        kl_client.onDataUpdated();
        return symbols;
    }

    override merge_snapshot(buf: Uint8Array, silent: boolean = false): string[] | void {
        if (isNodejs()) return;
        const { symbols } = this.parseSnapshot(buf);
        if (!silent) {
            const time = new Date().toISOString().slice(11, 23);
            c_log(`[${time}] [BA_1 Client DB] Merging partial snapshot. Total keys now: ${this.client_map.size}.`);
            // ã€å…³é”®ä¿®æ”¹ã€‘åœ¨å‡½æ•°å†…éƒ¨åŠ¨æ€åŠ è½½ kl_client
            const { kl_client } = require("./kl_client");
            kl_client.onDataUpdated();
        }
        return symbols;
    }

    override set__diff(buf: Uint8Array): string[] | void {
        if (isNodejs()) return;
        const opsBySymbol = safeJSONParse(new TextDecoder().decode(buf)) as { [symbol_å‘¨æœŸ: string]: OP[] };
        const updatedSymbols: string[] = [];

        for (const symbol_å‘¨æœŸ in opsBySymbol) {
            const kl = this.client_map.get(symbol_å‘¨æœŸ);
            if (!kl) {
                continue;
            }
            updatedSymbols.push(symbol_å‘¨æœŸ);

            opsBySymbol[symbol_å‘¨æœŸ].forEach(op => {
                if (op.type === 'set') kl.set(op.kline);
                else if (op.type === 'push') kl.push(op.kline);
                else if (op.type === 'updateLast') kl.updateLast(op.kline);
            });

            const totalUpdates = opsBySymbol[symbol_å‘¨æœŸ].reduce((sum, op) => op.type === 'set' ? sum + op.kline.length : sum + 1, 0);

            if (totalUpdates > 0) {
                const currentCount = this.client_diffStats.get(symbol_å‘¨æœŸ) || 0;
                this.client_diffStats.set(symbol_å‘¨æœŸ, currentCount + totalUpdates);
            }
        }
        if (updatedSymbols.length > 0) {
            // ã€å…³é”®ä¿®æ”¹ã€‘åœ¨å‡½æ•°å†…éƒ¨åŠ¨æ€åŠ è½½ kl_client
            const { kl_client } = require("./kl_client");
            kl_client.onDataUpdated();
        }
        return updatedSymbols;
    }

    public getAndClearClientDiffStats() {
        if (isNodejs()) return new Map();
        const stats = this.client_diffStats;
        this.client_diffStats = new Map();
        return stats;
    }

    override prune(activeSymbols: Set<string>) {
        if (isNodejs()) return;
        c_log(`[BA_1 Client DB] prune: Starting cleanup based on ${activeSymbols.size} active symbols.`);
        const keysToDelete: string[] = [];
        for (const key of this.client_map.keys()) {
            const symbol = key.split('_')[0];
            if (!activeSymbols.has(symbol)) {
                keysToDelete.push(key);
            }
        }
        if (keysToDelete.length > 0) {
            c_log(`[BA_1 Client DB] prune: Deleting ${keysToDelete.length} keys from local cache.`);
            keysToDelete.forEach(key => this.client_map.delete(key));
        }
    }

    get_kline(symbol_å‘¨æœŸ: string) {
        if (isNodejs()) {
            return this.state__dic[symbol_å‘¨æœŸ];
        } else {
            let kl = this.client_map.get(symbol_å‘¨æœŸ);
            if (!kl) {
                kl = new K_Line(new ArrayBuffer(K_Line.å­—èŠ‚æ•°), 0);
                this.client_map.set(symbol_å‘¨æœŸ, kl);
            }
            return kl;
        }
    }
}


export const BA_1 = SyncInfo({
    realDB: new ALL_K(),
    funcList: {
        setSubscriptions: { symbols: [''] },
        addSubscriptions: { symbols: [''] },
        syncHotSymbols: {},
    },
    path: '/bsdafhsfdgytsert54766dfgb',
    port: 6222,
})
]]>
</file>
<file path="src/kl_server/BA_2.ts">
<![CDATA[
import { RealDBJSON } from "../_____lib/net/sync/RealDBJSON";
import { SyncInfo } from "../_____lib/net/sync/SyncInfo";

export const BA_2 = SyncInfo({
    realDB: new RealDBJSON({
        æé†’: {
            lastId: '',
            lastSymbol: '',
            dic: Object.create(null) as {
                [symbol: string]: {
                    [price: number]: boolean
                }
            },
        },

        åˆçº¦_info: {} as {
            [symbol: string]: {
                tickSize: number
                stepSize: number
                limit_min: number
                limit_max: number
                market_min: number
                market_max: number
                ä¸Šçº¿æ—¶é—´: number
                å¼ºå¹³è´¹ç‡: number
                å¸‚ä»·åƒå•: number
            }
        },

        åˆçº¦__æ ‡è®°ä»·æ ¼: {} as {
            [symbol: string]: {
                æ ‡è®°ä»·æ ¼: number
                ç°è´§æŒ‡æ•°ä»·æ ¼: number
                èµ„é‡‘è´¹ç‡: number
                èµ„é‡‘è´¹ç‡å€’è®¡æ—¶: number
            }
        },

        åˆçº¦__ç°è´§_info: {} as {
            [symbol: string]: {
                binanceç°è´§tags_key: string[]
                æœ€å¤§ä¾›åº”é‡: number
                æ€»ä¾›åº”é‡: number
                æµé€šé‡: number
            }
        },

        æ‰‹åŠ¨_symbol_info_dic: {} as {
            [symbol: string]: {//æ”¹æˆäº†symbol
                __: string
                assetName: string
                tags_dic: { [k: string]: string }
                website: string
                X: string
            }
        },
        æ‰‹åŠ¨_é¢˜æ_æ’åº: [] as {
            tag: string
            cssColor: string
            list: {
                symbol: string //æ”¹æˆäº†symbol
                cssColor: string
            }[]
        }[],
        é¢˜ææ›²çº¿: {
            é¢œè‰²å¾ªç¯: [] as number[],
            æ˜¾ç¤ºçš„é¢˜æ: [] as string[],
        },
    }, data => class {
    }),
    funcList: {
        addæé†’: {
            symbol: '',
            price: 0,
        },
        deleteæé†’: {
            symbol: '',
            price: 0,
        },
    },
    path: '/adSGBVawerawerfdavzsadcvasdf',
    port: 6333,
})
]]>
</file>
<file path="src/kl_server/BA_3.ts">
<![CDATA[
// src/kl_server/BA_3.ts
import { RealDBJSON } from "../_____lib/net/sync/RealDBJSON";
import { SyncInfo } from "../_____lib/net/sync/SyncInfo";
import { StatsDataForRealDB } from "./statisticalDataTypes";

export const BA_3 = SyncInfo({
    realDB: new RealDBJSON({
        rankings: {},
    } as StatsDataForRealDB, data => class { }),
    funcList: {}, // è¿™ä¸ªé€šé“æ˜¯åªè¯»çš„ï¼Œä¸éœ€è¦å®¢æˆ·ç«¯è°ƒç”¨å‡½æ•°
    path: '/asdfqwerzxcv12345678',
    port: 6444,
});
]]>
</file>
<file path="src/kl_server/baServer2.ts">
<![CDATA[
import { kl_state } from "./kl_state";
import { SyncServer } from "../_____lib/net/sync/SyncServer";
import { BA_2 } from "./BA_2";
import { binance_symbolToAssetCode } from "./binance_symbolToAssetCode";
import { is_USDT_Symbol } from "../_____lib/API/è¡Œæƒ…API/is_USDT_Symbol";

export const baServer2 = new SyncServer(BA_2)

const db = baServer2.realDB

baServer2.func.addæé†’ = req => {
    if (is_USDT_Symbol(req.symbol)) {
        if (db.data.æé†’.dic[req.symbol] === undefined) {
            db.__(v => v.æé†’.dic[req.symbol]).set({})
        }
        db.__(v => v.æé†’.dic[req.symbol][req.price]).set(false)
    }
}

baServer2.func.deleteæé†’ = req => {
    if (is_USDT_Symbol(req.symbol)) {
        if (db.data.æé†’.dic?.[req.symbol]?.[req.price] === true) {
            db.__(v => v.æé†’.dic[req.symbol][req.price]).set(false)
        }
        if (db.data.æé†’.dic?.[req.symbol]?.[req.price] === false) {
            db.__(v => v.æé†’.dic[req.symbol][req.price]).set(undefined)
            if (Object.keys(db.data.æé†’.dic[req.symbol]).length === 0) {
                db.__(v => v.æé†’.dic[req.symbol]).set(undefined)
            }
        }
    }
}


export function baServer2_åªæœ‰åˆçº¦(symbol: string) {
    const assetCode = binance_symbolToAssetCode(symbol)
    const ç°è´§symbol = baServer2_assetCodeToç°è´§Symbol(assetCode)
    const åªæœ‰åˆçº¦ = kl_state.ç°è´§_info[ç°è´§symbol] === undefined
    return åªæœ‰åˆçº¦
}

export function baServer2_assetCodeToç°è´§Symbol(assetCode: string) {
    const a = assetCode + 'USDT'
    const b = '1000' + a
    if (kl_state.ç°è´§_info[a]) {
        return a
    }
    else if (kl_state.ç°è´§_info[b]) {
        return b
    }
    else {
        return ''
    }
}

export function baServer2_assetCodeToåˆçº¦Symbol(assetCode: string) {
    const a = assetCode + 'USDT'
    const b = '1000' + a
    if (db.data.åˆçº¦_info[a]) {
        return a
    }
    else if (db.data.åˆçº¦_info[b]) {
        return b
    }
    else {
        return ''
    }
}

]]>
</file>
<file path="src/kl_server/get_one_symbol_all_kline.ts">
<![CDATA[
import { binance_kline_å‘¨æœŸ_é…ç½® } from "./binance_kline_å‘¨æœŸ_é…ç½®";
import { ONE_K } from "./ONE_K";
import { safeFS } from "../_____lib/func/safeFS";
import { waitFor } from "../_____lib/func/waitFor";
import { åˆçº¦__getKLine_ext } from "./åˆçº¦__getKLine_ext";
import { K_Line } from "./ONE_K";

const BINANCE_API_MAX_LIMIT = Math.min(K_Line.ARR_MAX_LENGTH, 1500) //1500 ä¸èƒ½æ”¹ 

export const get_one_symbol_all_kline = async (symbol: string) => {
    let retArr: ONE_K[][] = [];

    for (let i = 0; i < binance_kline_å‘¨æœŸ_é…ç½®.length; i++) {
        const { interval, é—´éš” } = binance_kline_å‘¨æœŸ_é…ç½®[i]
        const ä¸Šä¸€ä¸ª = i === 0 ? undefined : retArr[i - 1]
        const path = `db/${interval}/${symbol}.json`
        const A = safeFS.readJSONFileSync(path) as ONE_K[] | undefined
        const Aæœ‰ = A !== undefined && A.length >= 2 //åªæœ‰1ä¸ª å¤§çº§åˆ« timestamp ä¸æ˜¯èµ·ç‚¹

        const set = (arr: ONE_K[]) => {
            const arr2 = arr.slice(Math.max(0, arr.length - K_Line.ARR_MAX_LENGTH))
            safeFS.writeJSONFileSync(path, arr2)
            retArr[i] = arr2
        }


        //åˆæˆAåˆ°æœ€æ–°
        if (Aæœ‰ && ä¸Šä¸€ä¸ª) {
            const index = ä¸Šä¸€ä¸ª.findIndex(v => v.timestamp === A[A.length - 1].timestamp)
            if (index !== -1) {
                A.pop()
                for (let i = index; i < ä¸Šä¸€ä¸ª.length; i++) {
                    const v = ä¸Šä¸€ä¸ª[i]
                    if (Number(v.timestamp) % é—´éš” === 0) {
                        A.push(v)
                    } else {
                        const x = A[A.length - 1]
                        A[A.length - 1] = {
                            ...x,
                            high: Math.max(x.high, v.high),
                            low: Math.min(x.low, v.low),
                            close: v.close,
                            æˆäº¤é¢: x.æˆäº¤é¢ + v.æˆäº¤é¢,
                        }
                    }
                }
                set(A)
                continue;
            }
        }


        //è¿½åŠ ä¸‹è½½Aåˆ°æœ€æ–° 
        let è¿½åŠ ä¸‹è½½_limit = BINANCE_API_MAX_LIMIT
        if (Aæœ‰) {
            const last = A[A.length - 1].timestamp;
            const count = Math.floor((Date.now() - Number(last)) / é—´éš”);
            // é™åˆ¶æœ€å¤§ä¸‹è½½æ•°é‡ï¼Œé¿å…æ–°å¸ä¸‹è½½è¿‡å¤šKçº¿
            è¿½åŠ ä¸‹è½½_limit = Math.min(count + 10, BINANCE_API_MAX_LIMIT, 1000); //10è¯¯å·® å¤šä¸‹è½½10ä¸ªï¼Œæœ€å¤šä¸‹è½½1200æ ¹Kçº¿
        } else {
            // å¯¹äºæ–°å¸ï¼Œé™åˆ¶åˆå§‹ä¸‹è½½çš„Kçº¿æ•°é‡
            è¿½åŠ ä¸‹è½½_limit = Math.min(BINANCE_API_MAX_LIMIT, 200); // æ–°å¸é¦–æ¬¡ä¸‹è½½æœ€å¤š200æ ¹Kçº¿
        }
        const B = await åˆçº¦__getKLine_ext({
            symbol,
            interval,
            limit: è¿½åŠ ä¸‹è½½_limit,
        }, { purpose: 'concurrent' })
        await waitFor(30)
        if (B === undefined) return undefined
        if (A !== undefined && A.findIndex(v => v.timestamp === B[0].timestamp) !== -1) {
            set([
                ...A.slice(0, A.findIndex(v => v.timestamp === B[0].timestamp)),
                ...B,
            ])
        } else {
            set(B)
        }
    }

    return retArr
}

]]>
</file>
<file path="src/kl_server/index.ts">
<![CDATA[
// src/kl_server/index.ts
import { binance_kline_å‘¨æœŸ_é…ç½® } from "./binance_kline_å‘¨æœŸ_é…ç½®"
import { get_one_symbol_all_kline } from "./get_one_symbol_all_kline"
import { ONE_K } from "./ONE_K"
import { ç§æœ‰API_cg_ws } from "../_____lib/API/ç§æœ‰API/ç§æœ‰API_cg_ws"
// import { binance_symbolToAssetCode } from "./binance_symbolToAssetCode"
// import { ç§æœ‰API_get_ba_ç°è´§info } from "../_____lib/API/ç§æœ‰API/ç§æœ‰API_get_ba_ç°è´§info"
import { baServer2 } from "./baServer2"
import { åˆ·æ–°é¢˜æ, ç›‘æ§åˆ·æ–° } from "./åˆ·æ–°é¢˜æ"
import { binanceè¡Œæƒ…_HTTP } from "../_____lib/API/è¡Œæƒ…API/binanceè¡Œæƒ…_HTTP"
import { ç€ç¬”è¡Œæƒ…ws } from "../_____lib/API/è¡Œæƒ…API/ç€ç¬”è¡Œæƒ…ws"
import { æ ‡è®°ä»·æ ¼ws_onlyUSDT } from "../_____lib/API/è¡Œæƒ…API/æ ‡è®°ä»·æ ¼ws_onlyUSDT"
import { kl_state } from "./kl_state"
import { waitFor } from "../_____lib/func/waitFor"
import { c_log } from "../_____lib/func/c_log"
import { latestPriceCache } from "./latestPriceCache";
import { ä»·æ ¼æé†’ } from "./ä»·æ ¼æé†’"
import { statsCalculator } from "./ç»Ÿè®¡ä¿¡æ¯è®¡ç®—";
import { IndexServer } from "./IndexServer"
import { getPoolStatus, reportAllPoolStatus } from "../_____lib/net/getAgentWithURL"
import * as fs from 'fs'
import * as path from 'path'
import { baServer1 } from "./servers";

// åˆ›å»ºæ—¥å¿—ç›®å½•ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
// è·å–é¡¹ç›®æ ¹ç›®å½•è·¯å¾„ï¼ˆå½“å‰æ–‡ä»¶æ‰€åœ¨ç›®å½•çš„ä¸Šä¸Šçº§ç›®å½•ï¼‰
const ROOT_DIR = path.resolve(__dirname, '../..')
const LOG_DIR = path.join(ROOT_DIR, 'logs')

try {
    if (!fs.existsSync(LOG_DIR)) {
        fs.mkdirSync(LOG_DIR, { recursive: true })
        c_log(`åˆ›å»ºæ—¥å¿—ç›®å½•æˆåŠŸ: ${LOG_DIR}`)
    }
} catch (error) {
    c_log(`åˆ›å»ºæ—¥å¿—ç›®å½•å¤±è´¥: ${error}`)
}

/**
 * å†™å…¥æ—¥å¿—åˆ°æ–‡ä»¶
 * @param message - æ—¥å¿—æ¶ˆæ¯
 * @param data - é¢å¤–æ•°æ®ï¼ˆå¯é€‰ï¼‰
 */
function writeLog(message: string, data: any = '') {
    try {
        const timestamp = new Date().toISOString()
        const logFile = path.join(LOG_DIR, `log_${new Date().toISOString().split('T')[0]}.log`)
        const logMessage = `[${timestamp}] ${message}\n${data ? `Data: ${JSON.stringify(data, null, 2)}\n` : ''}${'-'.repeat(80)}\n`

        fs.appendFileSync(logFile, logMessage, 'utf8')
        c_log(logMessage)
    } catch (error) {
        c_log(`å†™å…¥æ—¥å¿—å¤±è´¥: ${error}`)
    }
}

setInterval(() => {
    const poolStatus = getPoolStatus();
    const concurrentHealth = poolStatus.concurrent.health;
    const defaultHealth = poolStatus.default.health;

    process.title = [
        `å†…å­˜:${kl_state.å†…å­˜str}`,
        `å‰©ä½™:${kl_state.ä¸‹è½½é˜Ÿåˆ—.length}`,
        `å¤šäº†:${kl_state.å¤šäº†.join(' ')}`,
        `å°‘äº†:${kl_state.å°‘äº†.join(' ')}`,
        `é¢˜æåˆ·æ–°æ¬¡æ•°:${kl_state.é¢˜æåˆ·æ–°æ¬¡æ•°}`,
        `è¿æ¥æ± :${concurrentHealth}/${defaultHealth}`,
    ].join('   ')
}, 100)

const å¹¶å‘ä¸‹è½½å‡ ä¸ª = 20
const cg_ws = new ç§æœ‰API_cg_ws()
const ç€ç¬”ws = new ç€ç¬”è¡Œæƒ…ws()
const æ ‡è®°ws = new æ ‡è®°ä»·æ ¼ws_onlyUSDT()

async function getOne(symbol: string) {
    // const assetCode = binance_symbolToAssetCode(symbol)
    // const ç°è´§symbol = baServer2_assetCodeToè´§Symbol(assetCode)
    // const åªæœ‰åˆçº¦ = baServer2_åªæœ‰åˆçº¦(symbol)

    const info = {
        binanceç°è´§tags_key: [] as string[],
        æœ€å¤§ä¾›åº”é‡: 0,
        æ€»ä¾›åº”é‡: 0,
        æµé€šé‡: 0,
    }

    // if (åªæœ‰åˆçº¦ === false) {        
    //     const ç°è´§æµé€šé‡ = await ç§æœ‰API_get_ba_ç°è´§æµé€šé‡(ç°è´§symbol)
    //     if (ç°è´§æµé€šé‡ === undefined) {
    //         console.log(`ä¸‹è½½ ${symbol} ç°è´§æµé€šé‡ å¤±è´¥`)
    //         return undefined
    //     }

    //     const åˆçº¦æœ‰1000 = symbol.indexOf('1000') === 0
    //     const ç°è´§æœ‰1000 = ç°è´§symbol.indexOf('1000') === 0

    //     if (åˆçº¦æœ‰1000 === ç°è´§æœ‰1000) {
    //         info.æµé€šé‡ = ç°è´§æµé€šé‡.circulatingSupply
    //         info.æœ€å¤§ä¾›åº”é‡ = ç°è´§æµé€šé‡.maxSupply
    //         info.æ€»ä¾›åº”é‡ = ç°è´§æµé€šé‡.totalSupply
    //     } else if (åˆçº¦æœ‰1000 && !ç°è´§æœ‰1000) {
    //         info.æµé€šé‡ = ç°è´§æµé€šé‡.circulatingSupply / 1000
    //         info.æœ€å¤§ä¾›åº”é‡ = ç°è´§æµé€šé‡.maxSupply / 1000
    //         info.æ€»ä¾›åº”é‡ = ç°è´§æµé€šé‡.totalSupply / 1000
    //     } else if (!åˆçº¦æœ‰1000 && ç°è´§æœ‰1000) {
    //         //ä¸å­˜åœ¨è¿™ç§æƒ…å†µ
    //     }

    //     const ç°è´§info = await ç§æœ‰API_get_ba_ç°è´§info(è´§symbol)
    //     if (ç°è´§info === undefined){
    //         console.log(`ä¸‹è½½ ${symbol} ç°è´§info å¤±è´¥`)
    //          return ç°è´§info
    //     }
    //     info.binanceç°è´§tags_key = ç°è´§info.tagsKey
    // }

    const ____arr = await get_one_symbol_all_kline(symbol)
    if (____arr === undefined) return undefined


    return { info, ____arr }
}

async function ä¸‹è½½(symbol: string) {
    // å…ˆå–æ¶ˆè¯¥symbolçš„æ—§è®¢é˜…ï¼Œé¿å…é‡å¤è®¢é˜…
    ç€ç¬”ws.unsubscribeSymbol(symbol)

    const one = await getOne(symbol)
    if (one === undefined) {
        //writeLog(`ä¸‹è½½å¤±è´¥: ${symbol}`)
        kl_state.ä¸‹è½½é˜Ÿåˆ—.push(symbol) //æ·»åŠ åˆ°é˜Ÿåˆ—
        return
    }

    //writeLog(`æˆåŠŸä¸‹è½½: ${symbol}`)
    kl_state.éœ€è¦åˆ·æ–° = true

    baServer2.realDB.__(v => v.åˆçº¦__ç°è´§_info[symbol]).set(one.info)

    const { ____arr } = one

    // å­˜å‚¨æ¯ä¸ªå‘¨æœŸçš„è®¢é˜…å‡½æ•°ï¼Œä¾¿äºç®¡ç†
    const subscriptions: { [index: number]: (obj: any) => void } = {}

    for (let index = 0; index < binance_kline_å‘¨æœŸ_é…ç½®.length; index++) {
        const res = ____arr[index]
        baServer1.realDB.set(symbol + '_' + index, res)

        // ä½¿ç”¨subscribeBySymbolæ–¹æ³•ï¼Œä¾¿äºåç»­æŒ‰symbolå–æ¶ˆè®¢é˜…
        subscriptions[index] = ç€ç¬”ws.pubSub.subscribeBySymbol(symbol, v => {
            if (v.symbol === symbol) {
                const { timestamp, price, size } = v.data

                // å¡«å……é«˜ç²¾åº¦ä»·æ ¼ç¼“å­˜
                latestPriceCache.set(symbol, price);

                const æˆäº¤é¢ = price * size
                const kline = baServer1.realDB.get_kline(symbol + '_' + index)
                const { é—´éš” } = binance_kline_å‘¨æœŸ_é…ç½®[index]
                if (kline && kline.length > 0) {
                    // --- æƒ…å†µä¸€ï¼šKçº¿å·²å­˜åœ¨ï¼Œæ‰§è¡Œæ›´æ–°æˆ–è¿½åŠ é€»è¾‘ ---
                    const lastTimestamp = Number(kline.data.timestamp[kline.length - 1])
                    const last = Math.floor(lastTimestamp / é—´éš”)
                    const i = Math.floor(timestamp / é—´éš”)

                    if (i === last) { // æ›´æ–°æœ€åä¸€æ ¹Kçº¿
                        baServer1.realDB.updateLast(symbol + '_' + index, {
                            timestamp: lastTimestamp,
                            open: kline.data.open[kline.length - 1],
                            high: Math.max(kline.data.high[kline.length - 1], price),
                            low: Math.min(kline.data.low[kline.length - 1], price),
                            close: price,
                            æˆäº¤é¢: kline.data.æˆäº¤é¢[kline.length - 1] + æˆäº¤é¢,
                            ext_æŒä»“é‡: cg_ws.dic[symbol]?.æŒä»“é‡ ?? kline.data.ext_æŒä»“é‡[kline.length - 1],
                            ext_èµ„é‡‘è´¹ç‡: 0,
                            ext_å¤šç©ºæ¯”: cg_ws.dic[symbol]?.å¤šç©ºæ¯” ?? kline.data.ext_å¤šç©ºæ¯”[kline.length - 1],
                        })
                        statsCalculator.scheduleUpdate(symbol);
                    } else if (i > last) { // æ¨é€ä¸€æ ¹æ–°çš„Kçº¿
                        const preClose = kline.data.close[kline.length - 1]
                        baServer1.realDB.push(symbol + '_' + index, {
                            timestamp: i * é—´éš”,
                            open: preClose,
                            high: Math.max(preClose, price),
                            low: Math.min(preClose, price),
                            close: price,
                            æˆäº¤é¢,
                            ext_æŒä»“é‡: cg_ws.dic[symbol]?.æŒä»“é‡ ?? kline.data.ext_æŒä»“é‡[kline.length - 1],
                            ext_èµ„é‡‘è´¹ç‡: 0,
                            ext_å¤šç©ºæ¯”: cg_ws.dic[symbol]?.å¤šç©ºæ¯” ?? kline.data.ext_å¤šç©ºæ¯”[kline.length - 1],
                        })
                        statsCalculator.scheduleUpdate(symbol);
                    }
                } else {
                    // --- æƒ…å†µäºŒï¼šKçº¿ä¸å­˜åœ¨ï¼Œä¸ºæ–°å“ç§åˆ›å»ºç¬¬ä¸€æ ¹Kçº¿ ---
                    const i = Math.floor(timestamp / é—´éš”)
                    const firstBar: ONE_K = {
                        timestamp: i * é—´éš”,
                        open: price,
                        high: price,
                        low: price,
                        close: price,
                        æˆäº¤é¢,
                        ext_æŒä»“é‡: cg_ws.dic[symbol]?.æŒä»“é‡ ?? 0,
                        ext_èµ„é‡‘è´¹ç‡: 0,
                        ext_å¤šç©ºæ¯”: cg_ws.dic[symbol]?.å¤šç©ºæ¯” ?? 0,
                    }
                    baServer1.realDB.set(symbol + '_' + index, [firstBar]);
                    statsCalculator.scheduleUpdate(symbol);
                }
                if (index === 0) {
                    const sk = baServer1.realDB.get_kline(symbol + '_' + '-1')
                    const é—´éš” = 1000 //1s
                    const i = Math.floor(timestamp / é—´éš”)

                    // å¦‚æœå½“å‰æ—¶é—´æˆ³ä¸ç³»ç»Ÿæ—¶é—´ç›¸å·®å¤ªå¤§ï¼Œå¯èƒ½æ˜¯é”™è¯¯æ•°æ®ï¼Œå¿½ç•¥å¤„ç†
                    const currentTime = Date.now()
                    if (Math.abs(timestamp - currentTime) > 60000) { // å¦‚æœæ—¶é—´æˆ³ä¸å½“å‰æ—¶é—´ç›¸å·®è¶…è¿‡1åˆ†é’Ÿï¼Œå¯èƒ½æ˜¯é”™è¯¯æ•°æ®
                        return
                    }

                    const preClose = sk && sk.data.close.length > 0 ? sk.data.close[sk.length - 1] : price
                    const item: ONE_K = {
                        timestamp: i * é—´éš”,
                        open: preClose,
                        high: Math.max(preClose, price),
                        low: Math.min(preClose, price),
                        close: price,
                        æˆäº¤é¢,
                        ext_æŒä»“é‡: cg_ws.dic[symbol] !== undefined ? cg_ws.dic[symbol]!.æŒä»“é‡ : 0,
                        ext_èµ„é‡‘è´¹ç‡: 0,
                        ext_å¤šç©ºæ¯”: cg_ws.dic[symbol] !== undefined ? cg_ws.dic[symbol]!.å¤šç©ºæ¯” : 0,
                    }

                    if (sk && sk.length > 0) {
                        const last = Math.floor(Number(sk.data.timestamp[sk.length - 1]) / é—´éš”)
                        if (i === last) {
                            baServer1.realDB.updateLast(symbol + '_' + '-1', {
                                timestamp: Number(sk.data.timestamp[sk.length - 1]),
                                open: sk.data.open[sk.length - 1],
                                high: Math.max(sk.data.high[sk.length - 1], price),
                                low: Math.min(sk.data.low[sk.length - 1], price),
                                close: price,
                                æˆäº¤é¢: sk.data.æˆäº¤é¢[sk.length - 1] + æˆäº¤é¢,
                                ext_æŒä»“é‡: cg_ws.dic[symbol] !== undefined ? cg_ws.dic[symbol]!.æŒä»“é‡ : 0,
                                ext_èµ„é‡‘è´¹ç‡: 0,
                                ext_å¤šç©ºæ¯”: cg_ws.dic[symbol] !== undefined ? cg_ws.dic[symbol]!.å¤šç©ºæ¯” : 0,
                            })
                        } else if (i > last) {
                            baServer1.realDB.push(symbol + '_' + '-1', item);
                        }
                        // åªè¦ä¸æ˜¯è¿‡æ—¶æ•°æ®å°±è§¦å‘æ›´æ–°
                        if (i >= last) {
                            statsCalculator.scheduleUpdate(symbol);
                        }
                    } else {
                        baServer1.realDB.set(symbol + '_' + '-1', [item]);
                        statsCalculator.scheduleUpdate(symbol);
                    }
                }
            }
        })

    }

}

/**
 * æ‰¹é‡ä¸‹è½½Kçº¿æ•°æ®å¹¶è®¡ç®—è€—æ—¶
 * è¾“å…¥ï¼šæ— ï¼ˆä½¿ç”¨å…¨å±€ä¸‹è½½é˜Ÿåˆ—ï¼‰
 * è¾“å‡ºï¼šæ— ï¼ˆæ›´æ–°å…¨å±€çŠ¶æ€ï¼‰
 * åŠŸèƒ½ï¼šå¹¶å‘ä¸‹è½½Kçº¿æ•°æ®ï¼Œç»Ÿè®¡ä¸‹è½½è€—æ—¶ï¼Œè‡ªåŠ¨åˆ·æ–°é¢˜æ
 */
async function æ’é˜Ÿä¸‹è½½() {
    const startTotalTime = Date.now()    // è®°å½•æ€»å¼€å§‹æ—¶é—´

    while (true) {
        const arr = kl_state.ä¸‹è½½é˜Ÿåˆ—.splice(Math.max(0, kl_state.ä¸‹è½½é˜Ÿåˆ—.length - å¹¶å‘ä¸‹è½½å‡ ä¸ª), å¹¶å‘ä¸‹è½½å‡ ä¸ª)
        if (arr.length > 0) {
            await Promise.all(arr.map(v => ä¸‹è½½(v)))

            // è®¡ç®—ä»å¼€å§‹åˆ°ç°åœ¨çš„æ€»è€—æ—¶
            const totalElapsedTime = Math.round((Date.now() - startTotalTime) / 1000)  // è½¬æ¢ä¸ºç§’

            writeLog(`ä¸‹è½½è¿›åº¦: å‰©ä½™${kl_state.ä¸‹è½½é˜Ÿåˆ—.length}ä¸ª, æ€»è€—æ—¶${totalElapsedTime}ç§’`)
        }

        await waitFor(100)
        if (kl_state.éœ€è¦åˆ·æ–°) {
            åˆ·æ–°é¢˜æ()
            kl_state.éœ€è¦åˆ·æ–° = false
        }
    }
}

/**
 * Windowsç¯å¢ƒä¸‹æ¸©æŸ”å¥³å£°è¯­éŸ³æ’­æŠ¥
 * @param text - éœ€è¦æ’­æŠ¥çš„æ–‡æœ¬
 */
const speakText = (text: string) => {
    // ä½¿ç”¨Windowså†…ç½®çš„è¯­éŸ³åˆæˆ
    const command = `powershell.exe -Command "
        try {
            Add-Type -AssemblyName System.Speech;
            $speak = New-Object System.Speech.Synthesis.SpeechSynthesizer;
            $voices = $speak.GetInstalledVoices() | Where-Object { $_.Enabled -eq $true };
            
            # å°è¯•ä½¿ç”¨ä¸­æ–‡è¯­éŸ³
            $chineseVoice = $voices | Where-Object { $_.VoiceInfo.Culture -like 'zh-*' } | Select-Object -First 1;
            if ($chineseVoice) {
                $speak.SelectVoice($chineseVoice.VoiceInfo.Name);
            } else {
                # å¦‚æœæ²¡æœ‰ä¸­æ–‡è¯­éŸ³ï¼Œä½¿ç”¨é»˜è®¤è¯­éŸ³
                $defaultVoice = $voices | Select-Object -First 1;
                $speak.SelectVoice($defaultVoice.VoiceInfo.Name);
            }
            
            $speak.Rate = -1;  # è¯­é€Ÿç¨å¿«
            $speak.Volume = 80; # é€‚ä¸­éŸ³é‡
            [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12;
            $speak.Speak([uri]::UnescapeDataString('${encodeURIComponent(text)}'));
            $speak.Dispose();
        } catch {
            Write-Error $_.Exception.Message;
            exit 1;
        }"`;

    require('child_process').exec(command, (error: Error) => {
        if (error) {
            writeLog('è¯­éŸ³æ’­æŠ¥å¤±è´¥', { error: error.message });
            // å¤±è´¥æ—¶ä½¿ç”¨ç³»ç»Ÿé€šçŸ¥ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
            require('node-notifier').notify({
                title: 'ç³»ç»Ÿé€šçŸ¥',
                message: text,
                sound: true,
                wait: true
            });
        }
    });
};

const notifyWithSound = (title: string, message: string) => {
    // ä½¿ç”¨ç³»ç»Ÿé€šçŸ¥ä½œä¸ºä¸»è¦é€šçŸ¥æ–¹å¼
    require('node-notifier').notify({
        title,
        message,
        sound: true,
        wait: true
    });

    // å°è¯•ä½¿ç”¨è¯­éŸ³æ’­æŠ¥ä½œä¸ºè¾…åŠ©é€šçŸ¥
    try {
        speakText(`${title}ï¼Œ${message}`);
    } catch (error) {
        writeLog('è¯­éŸ³æ’­æŠ¥å°è¯•å¤±è´¥', { error });
    }
}

// ç”¨äºè·Ÿè¸ªæ­£åœ¨å¤„ç†çš„æ–°å“ç§
const processingSymbols = new Map<string, boolean>()
async function æ–°å“ç§task(symbol: string) {
    // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨å¤„ç†è¿™ä¸ªå“ç§
    if (processingSymbols.get(symbol)) {
        writeLog('æ–°å“ç§å·²åœ¨å¤„ç†ä¸­', { symbol })
        return
    }

    // å…ˆå–æ¶ˆè¯¥symbolçš„æ—§è®¢é˜…ï¼Œé¿å…é‡å¤è®¢é˜…
    ç€ç¬”ws.unsubscribeSymbol(symbol)

    processingSymbols.set(symbol, true)
    writeLog('æ–°å“ç§ä¸Šçº¿', { symbol })
    notifyWithSound('æ–°å“ç§ä¸Šçº¿', `å‘ç°æ–°å“ç§: ${symbol}`)

    let attemptCount = 0
    const MAX_ATTEMPTS = 0

    const timer = setInterval(async () => {
        attemptCount++
        writeLog(`æ–°å“ç§å¤„ç†ç¬¬${attemptCount}æ¬¡å°è¯•`, { symbol })

        const dic = await binanceè¡Œæƒ…_HTTP.åˆçº¦__exchangeInfo_onlyUSDT()
        writeLog(`dicçŠ¶æ€æ£€æŸ¥ - ç¬¬${attemptCount}æ¬¡`, {
            dicExists: dic !== undefined,
            symbolInDic: dic?.[symbol] !== undefined
        })

        if (dic !== undefined) {
            baServer2.realDB.__(v => v.åˆçº¦_info[symbol]).set(dic[symbol])
            kl_state.ä¸‹è½½é˜Ÿåˆ—.push(symbol)
            ç€ç¬”ws.add([symbol])
            writeLog(`æ–°å“ç§è¿½åŠ æˆåŠŸ - ç¬¬${attemptCount}æ¬¡å°è¯•`, { symbol })
            notifyWithSound('æ–°å“ç§è¿½åŠ æˆåŠŸ', `${symbol}å·²æˆåŠŸæ·»åŠ åˆ°ç³»ç»Ÿï¼Œç»§ç»­å°è¯•ä¸‹è½½${MAX_ATTEMPTS - attemptCount}æ¬¡`)
        }

        if (attemptCount >= MAX_ATTEMPTS) {
            clearInterval(timer)
            processingSymbols.delete(symbol)
            writeLog('æ–°å“ç§è¿½åŠ å¤±è´¥ - å·²è¾¾æœ€å¤§å°è¯•æ¬¡æ•°', { symbol })
        }
    }, 30 * 1000)
}




async function init() {
    //await waitFor(5 * 1000)

    const MAX_RETRIES = 1;  // æœ€å¤§é‡è¯•æ¬¡æ•°
    const RETRY_DELAY = 1000;  // é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰

    let åˆçº¦dic;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
            // å¹¶å‘è¯·æ±‚ä¸¤ä¸ªç«¯ç‚¹ï¼Œå“ªä¸ªå…ˆè¿”å›æˆåŠŸå°±ç”¨å“ªä¸ª
            åˆçº¦dic = await Promise.race([
                binanceè¡Œæƒ…_HTTP.åˆçº¦__exchangeInfo_onlyUSDT_mokex(),
                binanceè¡Œæƒ…_HTTP.åˆçº¦__exchangeInfo_onlyUSDT(),
                binanceè¡Œæƒ…_HTTP.åˆçº¦__exchangeInfo_onlyUSDT_www(),

            ]);

            if (åˆçº¦dic !== undefined) {
                c_log(`ç¬¬${attempt}æ¬¡è·å–exchangeInfoæˆåŠŸ`);
                break;
            }
        } catch (error) {
            c_log(`ç¬¬${attempt}æ¬¡è·å–exchangeInfoå‡ºé”™: ${error}`);
        }

        if (attempt < MAX_RETRIES) {
            c_log(`ç¬¬${attempt}æ¬¡è·å–exchangeInfoå¤±è´¥ï¼Œ${RETRY_DELAY / 1000}ç§’åé‡è¯•...`);
            await waitFor(RETRY_DELAY);
        }
    }

    if (åˆçº¦dic === undefined) {
        c_log(`åŠ è½½ exchangeInfo å¤±è´¥ - å·²é‡è¯•${MAX_RETRIES}æ¬¡`);
        return;
    }




    // kl_state.ç°è´§_info = ç°è´§di
    const all = Object.keys(åˆçº¦dic)
    cg_ws.init(all)
    baServer1.realDB.init(all.length + 32)//<------------- 

    //______________________________________________________________//
    baServer2.realDB.__(v => v.åˆçº¦_info).set(åˆçº¦dic)
    kl_state.ä¸‹è½½é˜Ÿåˆ— = [...all] //copy 
    ç€ç¬”ws.add(all)

    //______________________________________________________________//
    ä»·æ ¼æé†’()
    ç›‘æ§åˆ·æ–°()
    statsCalculator.start()

    æ’é˜Ÿä¸‹è½½()

    //______________________________________________________________//
    æ ‡è®°ws.init()


    æ ‡è®°ws.pubSub.subscribe(async ({ symbol, data }) => {
        baServer2.realDB.__(v => v.åˆçº¦__æ ‡è®°ä»·æ ¼[symbol]).set(data)


        if (kl_state.å¼€å§‹æ¥æ”¶æ–°å“ç§) {
            if (baServer2.realDB.data.åˆçº¦_info[symbol] === undefined) {
                // æ£€æŸ¥æ ‡è®°ä»·æ ¼æ˜¯å¦æœ‰å˜åŒ–
                const markPrice = data
                const prevMarkPrice = baServer2.realDB.data.åˆçº¦__æ ‡è®°ä»·æ ¼[symbol]



                if (markPrice !== prevMarkPrice) {
                    writeLog(`å‘ç°æ–°å“ç§æ ‡è®°ä»·æ ¼å˜åŒ–`, {
                        symbol,
                        ä»: prevMarkPrice,
                        å˜ä¸º: markPrice
                    })
                    æ–°å“ç§task(symbol)
                }
            }
        }
    })
    // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡æ–°å“ç§
    // å»¶è¿Ÿ1åˆ†é’Ÿåå¼€å§‹æ‰§è¡Œå®šæ—¶ä»»åŠ¡
    setTimeout(() => {
        setInterval(async () => {
            try {
                // è·å–æœ€æ–°çš„åˆçº¦åˆ—è¡¨
                console.log('å¼€å§‹è·å–åˆçº¦åˆ—è¡¨')
                // --- [ä¿®å¤ 451 é”™è¯¯] ---
                // ä¼˜å…ˆå°è¯• mokexï¼Œå¦‚æœå¤±è´¥å†å°è¯• binance å®˜æ–¹ï¼Œæé«˜æˆåŠŸç‡
                let dic = await binanceè¡Œæƒ…_HTTP.åˆçº¦__exchangeInfo_onlyUSDT_mokex().catch(() => undefined);
                if (!dic) {
                    dic = await binanceè¡Œæƒ…_HTTP.åˆçº¦__exchangeInfo_onlyUSDT().catch(() => undefined);
                }
                console.log('å½“å‰åˆçº¦å“ç§æ•°é‡:', Object.keys(dic || {}).length) // æ‰“å°åˆçº¦å“ç§æ•°é‡
                if (!dic) return

                // è·å–å½“å‰å·²çŸ¥çš„åˆçº¦åˆ—è¡¨
                const currentSymbols = Object.keys(baServer2.realDB.data.åˆçº¦_info)

                // å¯¹æ¯”æ‰¾å‡ºæ–°å¢å“ç§
                const newSymbols: string[] = []
                for (const symbol of Object.keys(dic)) {
                    // å¦‚æœè¯¥å“ç§ä¸åœ¨å½“å‰åˆ—è¡¨ä¸­,ä¸”æœªè¢«è®°å½•
                    if (!currentSymbols.includes(symbol) &&
                        baServer2.realDB.data.åˆçº¦_info[symbol] === undefined) {

                        writeLog('å‘ç°æ–°å“ç§', {
                            symbol,
                            info: dic[symbol]
                        })
                        newSymbols.push(symbol)
                    }
                }

                // å¹¶è¡Œå¤„ç†æ‰€æœ‰æ–°å“ç§
                if (newSymbols.length > 0) {
                    Promise.all(newSymbols.map(symbol => æ–°å“ç§task(symbol)))
                        .catch(error => writeLog('å¤„ç†æ–°å“ç§å‡ºé”™', error))
                }
            } catch (e) {
                writeLog('æ£€æŸ¥æ–°å“ç§å‡ºé”™', e)
            }
        }, 10 * 1000) // 10ç§’æ‰§è¡Œä¸€æ¬¡
    }, 60 * 1000) // å»¶è¿Ÿ1åˆ†é’Ÿæ‰§è¡Œ

    c_log('_____________________ç­‰å¾…30ç§’12 å‡†å¤‡æ¥æ”¶æ–°å“ç§3')
    await waitFor(30 * 1000)
    kl_state.å¼€å§‹æ¥æ”¶æ–°å“ç§ = true
    c_log('_____________________å¼€å§‹ æ¥æ”¶æ–°å“ç§')

    // åˆå§‹åŒ–æŒ‡æ•°æœåŠ¡
    const indexServer = new IndexServer(baServer1, baServer2)
    indexServer.start()

    // å¯åŠ¨è¿æ¥æ± ç›‘æ§ï¼ˆæ¯5åˆ†é’ŸæŠ¥å‘Šä¸€æ¬¡çŠ¶æ€ï¼‰
    setInterval(() => {
        const poolStatus = getPoolStatus();

        // åªåœ¨æœ‰æ´»åŠ¨æ—¶æŠ¥å‘ŠçŠ¶æ€
        if (poolStatus.concurrent.stats.totalRequests > 0 || poolStatus.default.stats.totalRequests > 0) {
            console.log(`[è¿æ¥æ± ç›‘æ§] å¹¶å‘æ± : ${poolStatus.concurrent.health} (è¯·æ±‚:${poolStatus.concurrent.stats.totalRequests}, å¤±è´¥ç‡:${poolStatus.concurrent.stats.failureRate})`);
            console.log(`[è¿æ¥æ± ç›‘æ§] é»˜è®¤æ± : ${poolStatus.default.health} (è¯·æ±‚:${poolStatus.default.stats.totalRequests}, å¤±è´¥ç‡:${poolStatus.default.stats.failureRate})`);
        }

        // å¦‚æœè¿æ¥æ± çŠ¶æ€ä¸å¥åº·ï¼Œè¾“å‡ºè¯¦ç»†æŠ¥å‘Š
        if (poolStatus.concurrent.health === 'UNHEALTHY' || poolStatus.default.health === 'UNHEALTHY') {
            console.warn('[è¿æ¥æ± ç›‘æ§] æ£€æµ‹åˆ°ä¸å¥åº·çš„è¿æ¥æ± ï¼Œè¾“å‡ºè¯¦ç»†æŠ¥å‘Š:');
            reportAllPoolStatus();
        }
    }, 5000 * 60 * 1000); // æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
}

init()
]]>
</file>
<file path="src/kl_server/kl_client.ts">
<![CDATA[
// src/kl_server/kl_client.ts
import { K_Line } from "./ONE_K"
import { SyncClient } from "../_____lib/net/sync/SyncClient"
import { ALL_K } from "./BA_1"
import { BA_2 } from "./BA_2"
import { BA_3 } from "./BA_3"
import { binance_symbolToAssetCode } from "./binance_symbolToAssetCode"
import { binance_kline_å‘¨æœŸ_é…ç½® } from "./binance_kline_å‘¨æœŸ_é…ç½®"

export namespace kl_client {
    export let c3: SyncClient<typeof BA_3.realDB, typeof BA_3.funcList>;
    export let c2: SyncClient<typeof BA_2.realDB, typeof BA_2.funcList>;

    const klineDB = new ALL_K();

    let _indexServer: {
        getIndices: () => {
            marketCapIndex: number;
            equalWeightIndex: number;
            timestamp: number;
        };
    } | undefined;

    let isConnectingOrConnected = false;
    export let isInitialSyncComplete = false;
    export let onDataUpdated: () => void = () => { };

    export function signalInitialSyncComplete() {
        if (!isInitialSyncComplete) {
            const time = new Date().toISOString().slice(11, 23);
            console.log(`[${time}] [kl_client] ğŸš€ Backend Info/Stats sync complete!`);
            isInitialSyncComplete = true;
            onDataUpdated();
        }
    }

    export function setIndexServer(server: typeof _indexServer) {
        _indexServer = server;
    }

    export function getIndices() {
        if (!_indexServer) {
            return { marketCapIndex: 0, equalWeightIndex: 0, timestamp: 0 };
        }
        return _indexServer.getIndices();
    }

    export const connect = (initialSymbols: string[] = []) => {
        if (isConnectingOrConnected) return;
        isConnectingOrConnected = true;
        const time = new Date().toISOString().slice(11, 23);
        console.log(`[${time}] [kl_client] Initiating connection (K-line WS disabled)...`);

        c3 = new SyncClient('kl_client_ba3', BA_3);
        c2 = new SyncClient('kl_client_ba2', BA_2);
        console.log("[kl_client] c2 (info) and c3 (stats) clients initialized.");

        let c2_ok = false, c3_ok = false;
        const check_sync_ok = () => {
            if (c2_ok && c3_ok) {
                signalInitialSyncComplete();
            }
        };
        c2.onStatusChange.subscribe(() => { if (c2.isConnected) { c2_ok = true; check_sync_ok(); } });
        c3.onStatusChange.subscribe(() => { if (c3.isConnected) { c3_ok = true; check_sync_ok(); } });

        console.log(`[${time}] [kl_client] Connecting c2 and c3...`);
        c3.connect();
        c2.connect();
    }

    export const disconnect = () => {
        if (!isConnectingOrConnected) return;
        const time = new Date().toISOString().slice(11, 23);
        console.log(`[${time}] [kl_client] Disconnecting c2, c3.`);
        c3?.disconnect();
        c2?.disconnect();
        isConnectingOrConnected = false;
    }

    export const addSubscriptions = (symbolsToDownload: string[]) => {
        console.warn('[kl_client] addSubscriptions is deprecated. Use addSymbolKline instead.');
        addSymbolKline(symbolsToDownload);
    }

    // ä½¿ç”¨ Set æ¥é˜²æ­¢é‡å¤è¯·æ±‚
    const pendingKlineRequests = new Set<string>();

    export const addSymbolKline = async (symbolsToDownload: string[]) => {
        if (symbolsToDownload.length === 0) return;

        const time = new Date().toISOString().slice(11, 23);
        console.log(`%c[${time}] [kl_client] HTTP Fetch: å¼€å§‹ä¸º ${symbolsToDownload.length} ä¸ªå“ç§åŠ è½½å†å²Kçº¿...`, 'color: orange; font-weight: bold;', symbolsToDownload);
        
        const allPeriods = [
            { interval: '1s', index: -1 },
            ...binance_kline_å‘¨æœŸ_é…ç½®.map((p, i) => ({ interval: p.interval, index: i }))
        ];

        const allRequests = symbolsToDownload.flatMap(symbol =>
            allPeriods.map(async (period) => {
                const { interval, index } = period;
                const requestKey = `${symbol}_${interval}`;

                // å¦‚æœè¿™ä¸ªè¯·æ±‚å·²ç»åœ¨è¿›è¡Œä¸­ï¼Œå°±è·³è¿‡
                if (pendingKlineRequests.has(requestKey)) {
                    console.log(`[kl_client] HTTP Fetch: Request for ${requestKey} is already pending. Skipping.`);
                    return;
                }

                try {
                    pendingKlineRequests.add(requestKey);

                    const klineInstance = getKline(symbol, index);
                    
                    const url = `http://127.0.0.1:3000/download-binary/${symbol}/${interval}?limit=1500`;
                    const response = await fetch(url);

                    if (!response.ok) {
                        if (response.status !== 404) console.error(`[kl_client] HTTP Fetch: è·å– ${symbol} ${interval} å¤±è´¥, status: ${response.status}`);
                        return;
                    }

                    const ab = await response.arrayBuffer();
                    if (ab.byteLength < 48) {
                        console.log(`[kl_client] HTTP Fetch: ${requestKey} - ArrayBuffer is too small (${ab.byteLength} bytes). Skipping.`);
                        return;
                    }

                    const view = new DataView(ab);
                    if (view.getUint32(0, true) !== 1) {
                        console.error(`[kl_client] HTTP Fetch: ${requestKey} - Invalid record count in header.`);
                        return;
                    }
                    
                    const klineCount = view.getUint32(40, true);
                    if (klineCount === 0) {
                        // console.log(`[kl_client] HTTP Fetch: ${requestKey} - Kline count is 0. Skipping.`);
                        return;
                    }
                    
                    console.log(`[kl_client] HTTP Fetch: Processing ${requestKey} with ${klineCount} records.`);

                    const data_f64: { [key: string]: Float64Array | BigInt64Array } = {};
                    const dataBodyOffset = 48;
                    const FIELD_BLOCK_SIZE = K_Line.ARR_MAX_LENGTH * 8;
                    const sortedKeys = Object.keys(klineInstance.data).sort();

                    sortedKeys.forEach((key, blockIndex) => {
                        const blockOffset = dataBodyOffset + blockIndex * FIELD_BLOCK_SIZE;
                        const constructor = key === 'timestamp' ? BigInt64Array : Float64Array;
                        // @ts-ignore
                        data_f64[key] = new constructor(ab, blockOffset, klineCount);
                    });

                    // ã€è°ƒè¯•æ—¥å¿—ã€‘åœ¨è°ƒç”¨ set_f64 ä¹‹å‰æ‰“å°å…³é”®ä¿¡æ¯
                    console.log(`[kl_client] HTTP Fetch: Calling set_f64 for ${requestKey}. First timestamp:`, data_f64['timestamp']?.[0]);

                    klineInstance.set_f64(data_f64 as any);

                    console.log(`%c[kl_client] HTTP Fetch: Successfully processed and set data for ${requestKey}.`, 'color: green');

                } catch (error) {
                    console.error(`[kl_client] HTTP Fetch: CRASH during request or processing for ${requestKey}`, error);
                } finally {
                    pendingKlineRequests.delete(requestKey);
                }
            })
        );

        await Promise.all(allRequests);
        console.log(`%c[kl_client] HTTP Fetch: All requested symbols have been processed. Triggering UI update.`, 'color: #4CAF50; font-weight: bold;');
        onDataUpdated();
    }

    export const getåˆçº¦info = (symbol: string) => {
        if (!c2) return {
            tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1,
            market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0,
        };
        let info = c2.realDB.data.åˆçº¦_info[symbol]
        if (info === undefined) {
            info = {
                tickSize: 1,
                stepSize: 1,
                limit_min: 1,
                limit_max: 1,
                market_min: 1,
                market_max: 1,
                ä¸Šçº¿æ—¶é—´: 0,
                å¼ºå¹³è´¹ç‡: 0,
                å¸‚ä»·åƒå•: 0,
            }
        }
        return info
    }

    export const getåˆçº¦__ç°è´§_info = (symbol: string) => {
        if (!c2) return { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
        let info = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol]
        if (info === undefined) {
            info = {
                binanceç°è´§tags_key: [],
                æœ€å¤§ä¾›åº”é‡: 0,
                æ€»ä¾›åº”é‡: 0,
                æµé€šé‡: 0,
            }
        }
        return info
    }

    export const getå¤šç©ºæ¯” = (symbol: string) => {
        const v = getKline(symbol, 0)
        return v.data.ext_å¤šç©ºæ¯”.length > 0 ? v.data.ext_å¤šç©ºæ¯”[v.data.ext_å¤šç©ºæ¯”.length - 1] : 0
    }

    export const isæ ‡è®°ä»·æ ¼è¿‘ = (symbol: string) => {
        const æœ€æ–° = get24æœ€æ–°(symbol).æœ€æ–°ä»·æ ¼;
        const æ ‡è®° = getè´¹ç‡(symbol).æ ‡è®°ä»·æ ¼;
        if (isNaN(æœ€æ–°) || isNaN(æ ‡è®°)) return false;
        const max = Math.max(æœ€æ–°, æ ‡è®°);
        const min = Math.min(æœ€æ–°, æ ‡è®°);
        return max / min < 1.001;
    };

    export const getå…¨éƒ¨å“ç§ = () => c2 ? Object.keys(c2.realDB.data.åˆçº¦_info) : [];

    export const getè´¹ç‡ = (symbol: string) => (c2 && c2.realDB.data.åˆçº¦__æ ‡è®°ä»·æ ¼[symbol]) || { æ ‡è®°ä»·æ ¼: NaN, ç°è´§æŒ‡æ•°ä»·æ ¼: NaN, èµ„é‡‘è´¹ç‡: NaN, èµ„é‡‘è´¹ç‡å€’è®¡æ—¶: NaN };

    export const get24æœ€æ–° = (symbol: string) => ({ æœ€æ–°ä»·æ ¼: getOrderBook(symbol).buy1 });

    export const getæµé€šå¸‚å€¼ = (symbol: string) => {
        if (!c2) return 0;
        const price = kl_client.getOrderBook(symbol).buy1;
        const supply = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol]?.æµé€šé‡ || 0;
        return price * supply;
    }

    export const getæ‰‹åŠ¨dataSRC = (symbol: string) => (c2 && c2.realDB.data.æ‰‹åŠ¨_symbol_info_dic[symbol]) || { __: '', assetName: binance_symbolToAssetCode(symbol), tags_dic: {}, website: '', X: '' };

    export const getæ‰‹åŠ¨_é¢˜æ_æ’åº = () => c2 ? c2.realDB.data.æ‰‹åŠ¨_é¢˜æ_æ’åº : [];

    export const getOrderBook = (symbol: string) => {
        const close = getKline(symbol, 0).data.close
        return {
            buy1: close.length > 0 ? close[close.length - 1] : NaN,
            sell1: close.length > 0 ? close[close.length - 1] : NaN,
        }
    }

    const ç©º = new K_Line(new ArrayBuffer(K_Line.å­—èŠ‚æ•°), 0)

    export const getKline = (symbol: string, index: number) => {
        const KEY = symbol + '_' + index
        return klineDB.get_kline(KEY) || ç©º
    }

    export interface TurnoverRankItem {
        symbol: string;
        turnover: number;
        price: number;
        marketCap: number;
    }

    export const getTurnoverTop15 = (): TurnoverRankItem[] => {
        if (!c3?.realDB.data.rankings) return [];
        return Object.entries(c3.realDB.data.rankings)
            .map(([symbol, stats]) => ({
                symbol: symbol,
                turnover: (stats?._7å¤©æˆäº¤é¢ ?? 0) / 100000000,
                price: getOrderBook(symbol)?.buy1 ?? 0,
                marketCap: getæµé€šå¸‚å€¼(symbol) ?? 0,
            }))
            .sort((a, b) => b.turnover - a.turnover)
            .slice(0, 15);
    }
}
]]>
</file>
<file path="src/kl_server/kl_state.ts">
<![CDATA[
export const kl_state = {
    å¼€å§‹æ¥æ”¶æ–°å“ç§: false,
    éœ€è¦åˆ·æ–°: false,
    ä¸‹è½½é˜Ÿåˆ—: [] as string[],
    ç°è´§_info: {} as {
        [symbol: string]: {
            tickSize: number;
            stepSize: number;
            limit_min: number;
            limit_max: number;
            market_min: number;
            market_max: number;
        };
    },
    é¢˜æåˆ·æ–°æ¬¡æ•°: 0,
    å†…å­˜str: '',
    å¤šäº†: [] as string[],
    å°‘äº†: [] as string[],
};

]]>
</file>
<file path="src/kl_server/ONE_K.ts">
<![CDATA[
import { CycleArray } from "../_____lib/func/CycleArray";

export type ONE_K = {
    timestamp: number| bigint;
    open: number;
    high: number;
    low: number;
    close: number;
    æˆäº¤é¢: number;

    //ä¸ç”¨ open close high low äº†
    ext_æŒä»“é‡: number;
    ext_èµ„é‡‘è´¹ç‡: number;
    ext_å¤šç©ºæ¯”: number;
};


// [
//     1499040000000,      // kçº¿å¼€ç›˜æ—¶é—´
//     "0.01634790",       // å¼€ç›˜ä»·
//     "0.80000000",       // æœ€é«˜ä»·
//     "0.01575800",       // æœ€ä½ä»·
//     "0.01577100",       // æ”¶ç›˜ä»·(å½“å‰Kçº¿æœªç»“æŸçš„å³ä¸ºæœ€æ–°ä»·)
//     "148976.11427815",  // æˆäº¤é‡
//     1499644799999,      // kçº¿æ”¶ç›˜æ—¶é—´
//     "2434.19055334",    // æˆäº¤é¢
//     308,                // æˆäº¤ç¬”æ•°
//     "1756.87402397",    // ä¸»åŠ¨ä¹°å…¥æˆäº¤é‡
//     "28.46694368",      // ä¸»åŠ¨ä¹°å…¥æˆäº¤é¢
//     "17928899.62484339" // è¯·å¿½ç•¥è¯¥å‚æ•°
//   ]


export class K_Line extends CycleArray({
    timestamp: BigInt64Array,
    open: Float64Array,
    high: Float64Array,
    low: Float64Array,
    close: Float64Array,
    æˆäº¤é¢: Float64Array,
    ext_æŒä»“é‡: Float64Array,
    ext_èµ„é‡‘è´¹ç‡: Float64Array,
    ext_å¤šç©ºæ¯”: Float64Array,
}, 2000) { }

]]>
</file>
<file path="src/kl_server/servers.ts">
<![CDATA[
// src/kl_server/servers.ts
import { SyncServer } from "../_____lib/net/sync/SyncServer";
import { BA_1 } from "./BA_1";
import { BA_3 } from "./BA_3";
import { c_log } from "../_____lib/func/c_log";

// ä½ä¼˜é€šé“: åªè´Ÿè´£æ¨é€ diff
export const baServer1 = new SyncServer({
    ...BA_1,
    log_tag: 'BA1_LOW_PRIORITY',
    broadcastsDiffs: true,               // âœ… å®ƒéœ€è¦å¹¿æ’­ diff
    sendsSnapshotOnSubscription: false,  // âŒ å“åº”è®¢é˜…æ—¶ä¸å‘é€åˆå§‹å¿«ç…§
});

// é«˜ä¼˜é€šé“: åªè´Ÿè´£å“åº”è®¢é˜…è¯·æ±‚å¹¶ç«‹å³è¿”å›å¿«ç…§
const BA_1_HighPriority_Config = {
    ...BA_1,
    port: 6224,
    path: BA_1.path + '_hp',
    log_tag: 'BA1_HIGH_PRIORITY',
    broadcastsDiffs: false,              // âŒ å®ƒä¸éœ€è¦å¹¿æ’­ diff
    sendsSnapshotOnSubscription: false,   // æ”¹ä¸ºfalseï¼Œå› ä¸ºæˆ‘ä»¬è‡ªå®šä¹‰äº†
};
export const baServer1_highPriority = new SyncServer(BA_1_HighPriority_Config);
baServer1_highPriority.realDB = baServer1.realDB; // ã€å…³é”®ã€‘ä¸¤ä¸ªæœåŠ¡å™¨å®ä¾‹å…±äº«åŒä¸€ä¸ªå†…å­˜æ•°æ®åº“

export const baServer3 = new SyncServer(BA_3);

// ã€é‡è¦ã€‘åºŸå¼ƒ get__allï¼Œå› ä¸ºåˆå§‹å¿«ç…§ç”±è®¢é˜…è§¦å‘ï¼Œæ›´åŠ ç²¾ç¡®
baServer1_highPriority.realDB.get__all = () => undefined;
baServer1.realDB.get__all = () => undefined;

// --- ã€é‡è¦ã€‘ç§»é™¤ syncHotSymbols RPCï¼Œå› ä¸ºçƒ­é—¨åŠŸèƒ½å·²åºŸå¼ƒ ---
delete baServer1.func.syncHotSymbols;

// +++ [æ–°å¢] é‡å†™é«˜ä¼˜æœåŠ¡å™¨çš„ addSubscriptions è¡Œä¸ºï¼Œå®ç°æµå¼å‘é€ +++
baServer1_highPriority.func.addSubscriptions = async (req, wsExt) => {
    const time = new Date().toISOString().slice(11, 23);
    const log_tag = (baServer1_highPriority as any).log_tag || 'BA1_HIGH_PRIORITY';
    if (!req?.symbols || req.symbols.length === 0) {
        c_log(`[${time}] [${log_tag}] -> addSubscriptions from ${wsExt.remoteAddress} with empty request.`);
        return;
    }

    // ä½ æŒ‡å®šçš„å‘¨æœŸé¡ºåº: 5m, 1d, 1m, 30m, 4h, 1w, 1s
    // å¯¹åº”çš„ç´¢å¼•:      1,  4,  0,   2,   3,  5, -1
    const periodOrder = ['1', '4', '0', '2', '3', '5', '-1'];

    c_log(`[${time}] [${log_tag}] -> Starting K-line stream for ${req.symbols.length} symbols to ${wsExt.remoteAddress}.`);
    req.symbols.forEach(s => wsExt.subscriptions.add(s));


    for (const symbol of req.symbols) {
        // 1. å‘é€å¼€å§‹ä¿¡å·
        baServer1_highPriority.sendCustomMessage(wsExt, {
            type: 'kline_stream_start',
            payload: { symbol }
        });

        // 2. æŒ‰é¡ºåºå‘é€æ¯ä¸ªå‘¨æœŸçš„Kçº¿å—
        for (const periodIndex of periodOrder) {
            const chunkBuffer = baServer1.realDB.get__partial_for_one_period(symbol, periodIndex);
            if (chunkBuffer) {
                baServer1_highPriority.sendCustomMessage(
                    wsExt,
                    {
                        type: 'kline_chunk',
                        payload: { symbol, periodIndex }
                    },
                    chunkBuffer
                );
            }
        }

        // 3. å‘é€ç»“æŸä¿¡å·
        baServer1_highPriority.sendCustomMessage(wsExt, {
            type: 'kline_stream_end',
            payload: { symbol }
        });
        c_log(`[${time}] [${log_tag}]   - Finished stream for ${symbol}.`);
    }
};

// ç¡®ä¿é»˜è®¤çš„è®¢é˜…å¤„ç†å™¨ä¹Ÿè¢«è¦†ç›–ï¼Œä»¥é˜²å®¢æˆ·ç«¯è°ƒç”¨setSubscriptions
baServer1_highPriority.func.setSubscriptions = (req, wsExt) => {
    // [FIXED] ä½¿ç”¨å¯é€‰é“¾æ“ä½œç¬¦ ?. æ¥å®‰å…¨åœ°è®¿é—® req.symbols
    wsExt.subscriptions = new Set(req?.symbols || []);
    // è½¬å‘ç»™æˆ‘ä»¬çš„è‡ªå®šä¹‰æµå¼å¤„ç†å™¨
    baServer1_highPriority.func.addSubscriptions?.(req, wsExt);
};
]]>
</file>
</files>
è¿™æ˜¯ä¸€ä»½ä¿®æ”¹`src\kl_server\kl_client.ts`çš„æ–¹æ¡ˆï¼Œä½ é¦–å…ˆä»”ç»†ï¼Œè°¨æ…çš„é˜…è¯»è¿™ä»½æ–¹æ¡ˆï¼Œç„¶åå»é˜…è¯»ç›¸å…³ä»£ç ï¼Œç„¶åæ¥è¯„ä»·ä¸‹è¿™ä»½æ–¹æ¡ˆçš„å¯è¡Œæ€§ï¼Œä½ éœ€è¦ä½œä¸ºä¸€ä¸ªä»”ç»†ï¼Œè°¨æ…ï¼Œæœ€ç»ˆè´Ÿè´£æ‰€æœ‰ç»†èŠ‚çš„ä¼™ä¼´ï¼Œæ¥å®¡è§†æˆ‘çš„æ–¹æ¡ˆï¼Œåˆ—å‡ºéœ€è¦æˆ‘è¡¥å……çš„ç»†èŠ‚ï¼Œæœ€ç»ˆç­‰æˆ‘ç¡®è®¤ï¼Œè¾“å‡ºå®Œæ•´çš„ä¿®æ”¹æ–‡æ¡£,å¦‚æœä½ è§‰å¾—æ–‡æ¡£å·²ç»è¶³å¤Ÿè¯¦ç»†äº†ï¼Œé‚£æˆ‘ä»¬æ¥ç»™å‡ºéœ€è¦ä¿®æ”¹çš„æ–‡ä»¶æ¸…å•ï¼Œä»¥åŠè¾“å‡ºæ¯ä¸ªæ–‡ä»¶çš„å®Œæ•´ç‰ˆæœ¬ï¼Œæ³¨æ„ï¼Œéœ€è¦æ·»åŠ ä¸Šå¤§é‡çš„ï¼Œä¸°å¯Œçš„æ—¥å¿—ï¼Œå› ä¸ºä¸€å®šä¼šæœ‰ä¸€ä¸ªå¾ˆé•¿çš„è°ƒè¯•æœŸ
æˆ‘çš„è¡¥å……
1 å°½é‡æ–°å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œå¦‚æœä¸ä¿®æ”¹kl_client.tsæ˜¯æœ€å¥½çš„ï¼Œä»ç›®å‰çœ‹ï¼Œæˆ‘è§‰å¾—æŠŠaddSymbolKlineçš„æ–¹æ³•æŒªå‡ºæ¥åˆ°æ–°çš„æ–‡ä»¶å°±å¯ä»¥äº†ï¼Œè¿™æ ·å¯¹äºåŸé¡¹ç›®çš„ä¿®æ”¹æ˜¯æœ€å°çš„ï¼Œé¿å…å‡ºç°æœªçŸ¥çš„é—®é¢˜
2 kline_worker.ts çš„ loadHistoricalDataForSymbol å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬è¯·æ±‚çš„ URL æ˜¯ http://127.0.0.1:3000/klines?symbol=...&limit=1500ã€‚æ³¨æ„æ¯æ¬¡æœ€å¤šåªèƒ½è¯·æ±‚1500æ ¹
3 kline_worker.ts ä¸­çš„ ALL_K å®ä¾‹ï¼šWorker å†…éƒ¨çš„ klineDB å®ä¾‹æ˜¯ new ALL_K()ã€‚åœ¨ BA_1.ts çš„å®ç°ä¸­ï¼ŒALL_K åœ¨ Node.js ç¯å¢ƒï¼ˆæœåŠ¡å™¨ç«¯ï¼‰éœ€è¦è°ƒç”¨ init() æ¥é¢„åˆ†é…ä¸€ä¸ªå·¨å¤§çš„ ArrayBufferã€‚ä½†åœ¨æµè§ˆå™¨ç¯å¢ƒï¼ˆWorkerï¼‰ä¸­ï¼Œå®ƒçš„ client_map æ˜¯åŠ¨æ€å¢é•¿çš„ã€‚
4 `å¸å®‰æ–‡æ¡£`ä¸­æœ‰è¯¦ç»†çš„å¦‚ä½•è®¢é˜…websocketçš„æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç 
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
å¥½çš„ï¼Œéå¸¸æ„Ÿè°¢ä½ çš„æ¾„æ¸…å’Œå†³ç­–ã€‚æˆ‘ä»¬ç°åœ¨å·²ç»æ‰«æ¸…äº†æ‰€æœ‰éšœç¢ï¼Œå¯ä»¥è¾“å‡ºä¸€ä»½å®Œæ•´ã€ç²¾ç¡®ã€å¯ç›´æ¥æ‰§è¡Œçš„æœ€ç»ˆæ–¹æ¡ˆäº†ã€‚

ä½ æå‡ºçš„æŒ‘æˆ˜è®©æˆ‘é‡æ–°å®¡è§†äº† CycleArray çš„è®¾è®¡ï¼Œå¹¶æ„æ€äº†ä¸€ä¸ªæ›´ä¼˜çš„æ–¹æ¡ˆï¼Œå³æŠŠå…ƒæ•°æ®ï¼ˆlength, head, tailï¼‰ç›´æ¥ç¼–ç åˆ° ArrayBuffer çš„å¤´éƒ¨ã€‚è¿™ä½¿å¾—æ•°æ®æœ¬èº«å°±æ˜¯è‡ªåŒ…å«çš„ï¼Œä¼ è¾“å’Œæ¢å¤éƒ½å˜å¾—æå…¶ç®€å•å’Œå¥å£®ï¼Œæˆ‘éå¸¸å–œæ¬¢è¿™ä¸ªç»“æœã€‚

ä»¥ä¸‹æ˜¯èåˆäº†æˆ‘ä»¬æ‰€æœ‰è®¨è®ºç»†èŠ‚çš„ V7 - æœ€ç»ˆå®æ–½æ–‡æ¡£ã€‚å®ƒåŒ…å«äº†å®Œæ•´çš„æ–‡å­—æè¿°å’Œæ‰€æœ‰éœ€è¦ä¿®æ”¹/æ–°å¢çš„ä»£ç ï¼Œæœªå˜åŠ¨çš„éƒ¨åˆ†ä¹Ÿå®Œæ•´ä¿ç•™ï¼Œç¡®ä¿äº†æ–‡æ¡£çš„æ•´ä½“æ€§ã€‚

Kçº¿æ•°æ®æŒä¹…åŒ–ä¸å¤šé¡µé¢åè°ƒç¼“å­˜æ–¹æ¡ˆ (V7 - æœ€ç»ˆå®æ–½æ–‡æ¡£)
1. ç›®æ ‡ (Objective)

æ„å»ºä¸€ä¸ªé«˜æ€§èƒ½ã€æ”¯æŒå¤šé¡µé¢ååŒå·¥ä½œçš„Kçº¿æ•°æ®ç¼“å­˜ç³»ç»Ÿã€‚æ—¨åœ¨å®ç°ä»¥ä¸‹ç›®æ ‡ï¼š

æè‡´æ€§èƒ½ï¼š é¦–æ¬¡è¯·æ±‚åï¼ŒKçº¿æ•°æ®å¸¸é©»å†…å­˜ï¼Œåç»­è®¿é—®æ— å»¶è¿Ÿã€‚UIçº¿ç¨‹åªè´Ÿè´£æ¸²æŸ“ã€‚

ç¦»çº¿èƒ½åŠ›ï¼š å…³é—­æµè§ˆå™¨åæ•°æ®ä¸ä¸¢å¤±ï¼Œé€šè¿‡ IndexedDB å®ç°ç§’å¼€å†å²Kçº¿ã€‚

èµ„æºé«˜æ•ˆï¼š åœ¨å¤šä¸ªæ ‡ç­¾é¡µä¸­ï¼Œåªç»´æŒä¸€ä¸ªå…±äº«çš„ WebSocket è¿æ¥æ¥è®¢é˜…æ‰€æœ‰æ•°æ®æµï¼Œæœ€å¤§é™åº¦å‡å°‘ç½‘ç»œå¼€é”€ã€‚

å¥å£®æ€§ï¼š é€šè¿‡åå°äº‹åŠ¡å’Œå¾ªç¯æ•°ç»„ä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ï¼Œè®¾è®¡ç®€æ´ï¼Œæ˜“äºç»´æŠ¤ã€‚

2. æ ¸å¿ƒæ¶æ„ï¼šä¸‰çº§ç¼“å­˜ + SharedWorker

é‡‡ç”¨ SharedWorker ä½œä¸ºæ•´ä¸ªç¼“å­˜ç³»ç»Ÿçš„ä¸­å¿ƒæ¢çº½ã€‚å®ƒåœ¨æµè§ˆå™¨åå°ä½œä¸ºå•ä¾‹è¿è¡Œï¼Œè¢«æ‰€æœ‰åŒæºé¡µé¢å…±äº«ï¼Œæ˜¯å”¯ä¸€çš„æ•°æ®æƒå¨æºã€‚

æ•°æ®æµå‘:
UIé¡µé¢ (Client) <=> SharedWorker (ä¸­å¿ƒæ¢çº½) <=> [L1: å†…å­˜ -> L2: IndexedDB -> L3: ç½‘ç»œ]

L1 - å†…å­˜ç¼“å­˜ (Workerå†…éƒ¨): SharedWorker å†…éƒ¨ç»´æŠ¤ä¸€ä»½ç”± ALL_K ç±»ç®¡ç†çš„äºŒè¿›åˆ¶Kçº¿æ•°æ®ï¼Œä½œä¸ºæœ€é«˜é€Ÿçš„æ•°æ®æºã€‚

L2 - IndexedDB (æŒä¹…åŒ–): SharedWorker ç‹¬å å¯¹ IndexedDB çš„æ‰€æœ‰è¯»å†™æ“ä½œï¼Œä½œä¸ºå†·å¯åŠ¨çš„æ•°æ®æºå’Œæ•°æ®çš„æœ€ç»ˆå½’å®¿ã€‚

L3 - ç½‘ç»œè¯·æ±‚ & WebSocket: æ‰€æœ‰è·å–å†å²Kçº¿çš„ HTTP è¯·æ±‚å’Œå®æ—¶çš„ WebSocket è®¢é˜…éƒ½ç”± SharedWorker ä¸»åŠ¨å‘èµ·å’Œç®¡ç†ã€‚

3. ç»„ä»¶èŒè´£åˆ’åˆ†

kl_client.ts (UIå±‚ - é€šä¿¡ä»£ç†)

èŒè´£:

è¿æ¥åˆ° SharedWorkerã€‚å¦‚æœè¿æ¥å¤±è´¥ï¼Œåˆ™ç›´æ¥æŠ¥é”™ï¼Œä¸æä¾›é™çº§æ–¹æ¡ˆã€‚

å°†UIçš„æ•°æ®è¯·æ±‚ï¼ˆå¦‚ addSymbolKlineï¼‰å°è£…æˆæ¶ˆæ¯ï¼Œæ˜ç¡®åœ°å‘é€ç»™ SharedWorkerã€‚

ç›‘å¬ SharedWorker å‘å›çš„æ•°æ®ï¼š

æ¥æ”¶åˆå§‹åŒ–çš„ã€è‡ªåŒ…å«å…ƒæ•°æ®çš„äºŒè¿›åˆ¶ ArrayBuffer æ•°æ®ï¼Œé€šè¿‡ setBackingBuffer æ–¹æ³•åœ¨è‡ªèº«å†…å­˜ä¸­é«˜æ•ˆé‡å»º K_Line å®ä¾‹å‰¯æœ¬ã€‚

æ¥æ”¶å®æ—¶çš„JSONæ ¼å¼ (ONE_K) æ›´æ–°ï¼Œå¹¶è°ƒç”¨æœ¬åœ° K_Line å®ä¾‹çš„ .push() / .updateLast() æ–¹æ³•ã€‚

è§¦å‘UIåˆ·æ–° (onDataUpdated)ã€‚

ä¸å†è´Ÿè´£: ä»»ä½• IndexedDB æ“ä½œã€WebSocket è¿æ¥ã€HTTP è¯·æ±‚ã€ç¼“å­˜å†³ç­–ã€‚

public/kline_worker.ts (åå° - æ•°æ®å¤§è„‘)

èŒè´£:

ç‹¬å  IndexedDB: ä½¿ç”¨ kline_db_manager æ¨¡å—å®‰å…¨åœ°è¯»å†™æ•°æ®åº“ã€‚

ç»Ÿä¸€ç½‘ç»œç®¡ç†:

ç»´æŠ¤ä¸€ä¸ªå•ä¸€çš„ã€å…±äº«çš„ WebSocket è¿æ¥ (wss://fstream.mokexapp.info/ws)ï¼Œé€šè¿‡ JSON-RPC æ¶ˆæ¯åŠ¨æ€æ‰¹é‡è®¢é˜…/é€€è®¢æ‰€æœ‰éœ€è¦çš„Kçº¿æµã€‚

å†…ç½®ä¼˜é›…çš„æ–­çº¿é‡è¿å’Œè‡ªåŠ¨é‡æ–°è®¢é˜…æœºåˆ¶ã€‚è®¢é˜…å¤±è´¥åä¼šæ¯3ç§’è‡ªåŠ¨é‡è¯•ã€‚

æ ¹æ®å®¢æˆ·ç«¯æ¶ˆæ¯ï¼Œä¸»åŠ¨å‘æœ¬åœ°Rustä¸­è½¬æœåŠ¡ (http://127.0.0.1:3000) å‘èµ· fetch è¯·æ±‚è·å–å†å²Kçº¿ã€‚Workerå±‚é¢å‡å®šHTTPè¯·æ±‚æ€»æ˜¯æˆåŠŸï¼Œç”±Ruståç«¯è´Ÿè´£é‡è¯•å’Œå®¹é”™ã€‚

å®ç°å®Œæ•´ç¼“å­˜é€»è¾‘: æ‰§è¡Œâ€œå†…å­˜ -> DB -> ç½‘ç»œâ€çš„æ£€æŸ¥ã€å†³ç­–ã€æ•°æ®è·å–å’Œåˆå¹¶ã€‚

å¹¿æ’­æ•°æ®: å°†è·å–åˆ°çš„å®Œæ•´äºŒè¿›åˆ¶æ•°æ® (ArrayBuffer) æˆ–å®æ—¶JSONæ›´æ–°å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„ UI é¡µé¢ã€‚

åå°åŒæ­¥: æ¯30ç§’å°†å†…å­˜ä¸­çš„â€œè„æ•°æ®â€å›å†™åˆ° IndexedDBã€‚

public/kline_db_manager.ts (åå° - æ•°æ®è®¿é—®å±‚)

èŒè´£:

å°è£…æ‰€æœ‰ IndexedDB çš„ CRUD æ“ä½œã€‚

æ•°æ®åº“ç»“æ„ï¼šé‡‡ç”¨åä¸º kline_cache_db çš„æ•°æ®åº“ï¼Œå†…éƒ¨åŒ…å«ä¸€ä¸ªåä¸º klines çš„å¯¹è±¡å­˜å‚¨ã€‚è¯¥å­˜å‚¨çš„ key ä¸º symbol_index æ ¼å¼ (ä¾‹å¦‚ 'BTCUSDT_0')ï¼Œvalue ä¸º K_Line å®ä¾‹çš„å®Œæ•´ ArrayBufferã€‚

æä¾›æ¸…æ™°çš„ APIï¼Œå¦‚ getKline(key) å’Œ saveKline(key, data)ã€‚

åœ¨ saveKline å†…éƒ¨å¤„ç†äº‹åŠ¡ï¼Œä¿è¯å†™å…¥çš„åŸå­æ€§ã€‚

åˆå§‹åŒ–å¤±è´¥æ—¶ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œç»ˆæ­¢ Workerã€‚

4. å…³é”®å·¥ä½œæµç¨‹

UI -> Worker: é¡µé¢è°ƒç”¨ addSymbolKline(['BTCUSDT'])ï¼Œkl_client å‘ SharedWorker å‘é€ { type: 'SUBSCRIBE_SYMBOLS', payload: { symbols: ['BTCUSDT'] } } æ¶ˆæ¯ã€‚

Worker å¤„ç† (å¯¹ BTCUSDT çš„æ‰€æœ‰å‘¨æœŸï¼Œä¾‹å¦‚ 1m å‘¨æœŸï¼Œç´¢å¼•ä¸º 0):
a. æ£€æŸ¥å†…å­˜ (L1): æ£€æŸ¥ klineDB ä¸­æ˜¯å¦å­˜åœ¨ 'BTCUSDT_0' çš„æ•°æ®ã€‚è‹¥å­˜åœ¨ï¼Œç›´æ¥å°† ArrayBuffer å¹¿æ’­ç»™å®¢æˆ·ç«¯ï¼Œæµç¨‹ç»“æŸã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›å…¥ä¸‹ä¸€æ­¥ã€‚
b. æŸ¥è¯¢DB (L2):

è°ƒç”¨ klineDBManager.getKline('BTCUSDT_0')ã€‚

è‹¥DBä¸­æœ‰æ•°æ®: å°†DBä¸­çš„ ArrayBuffer åŠ è½½åˆ° Worker çš„å†…å­˜ç¼“å­˜ (klineDB) ä¸­ï¼Œç„¶åå¹¿æ’­ç»™å®¢æˆ·ç«¯ã€‚

è‹¥DBä¸­æ— æ•°æ®: å‡†å¤‡ä»ç½‘ç»œè·å–ã€‚
c. ç½‘ç»œè¯·æ±‚ (L3): Worker å‘æœ¬åœ°RustæœåŠ¡å‘èµ·è¯·æ±‚ï¼šfetch('http://127.0.0.1:3000/klines?symbol=BTCUSDT&interval=1m&limit=1500')ã€‚
d. åˆå¹¶ã€ä¿å­˜ä¸å¹¿æ’­:

å°†ç½‘ç»œè¿”å›çš„JSONæ•°æ® newData ä¸ä»DBåŠ è½½çš„ oldData (å¦‚æœ‰) è¿›è¡Œåˆå¹¶ã€‚åˆå¹¶ç­–ç•¥å¦‚ä¸‹ï¼š

è‹¥ oldData ä¸ºç©ºï¼Œç›´æ¥ä½¿ç”¨ newDataã€‚

è‹¥ oldData ä¸ä¸ºç©ºï¼Œè·å–å…¶æœ€åä¸€æ ¹Kçº¿çš„æ—¶é—´æˆ³ lastTimestampã€‚

æ‰¾åˆ° newData ä¸­ç¬¬ä¸€æ ¹æ—¶é—´æˆ³å¤§äº lastTimestamp çš„Kçº¿ï¼Œå°†åç»­æ‰€æœ‰æ–°Kçº¿ push åˆ° oldData ä¸­ã€‚

å°†åˆå¹¶åçš„æœ€ç»ˆæ•°æ®å­˜å…¥ä¸€ä¸ªæ–°çš„ K_Line å®ä¾‹ä¸­ã€‚è¿™ä¸ªå®ä¾‹çš„ underlyingBuffer åŒ…å«äº†æ‰€æœ‰æ•°æ®å’Œå…ƒæ•°æ®ã€‚

è°ƒç”¨ klineDBManager.saveKline('BTCUSDT_0', finalKline.underlyingBuffer) å°†ç»“æœåŸå­æ€§åœ°å†™å…¥ IndexedDBã€‚

æ›´æ–° Worker è‡ªå·±çš„å†…å­˜ç¼“å­˜ (klineDB)ã€‚

å°†æ­¤å‘¨æœŸæœ€ç»ˆçš„å®Œæ•´ ArrayBuffer é€šè¿‡ postMessage é›¶æ‹·è´å¹¿æ’­ç»™æ‰€æœ‰ Clientã€‚
e. è®¢é˜…å®æ—¶æ•°æ®: å°† BTCUSDT æ‰€æœ‰å‘¨æœŸçš„ stream name (ä¾‹å¦‚ btcusdt_perpetual@continuousKline_1m) æ·»åŠ åˆ°ä¸€ä¸ªå¾…è®¢é˜…é˜Ÿåˆ—ä¸­ã€‚åå°ä»»åŠ¡ä¼šç®¡ç†å•ä¸€ WebSocket è¿æ¥ï¼Œå¹¶æ‰¹é‡å¤„ç†æ­¤é˜Ÿåˆ—ã€‚

SharedWorker çš„å•ä¸€å…±äº« WebSocket æ”¶åˆ°ä¸€æ ¹æ–°çš„Kçº¿æ•°æ®ã€‚

æ ¹æ® k.x å­—æ®µåˆ¤æ–­Kçº¿æ˜¯å¦å®Œç»“ï¼š

k.x === false (æœªå®Œç»“): Worker è°ƒç”¨è‡ªèº«å†…å­˜ä¸­å¯¹åº” K_Line å®ä¾‹çš„ updateLast() æ–¹æ³•ã€‚

k.x === true (å·²å®Œç»“): Worker è°ƒç”¨ push() æ–¹æ³•ã€‚

Worker å°†è¿™æ ¹Kçº¿çš„JSONå¯¹è±¡ (ONE_K) åŒ…è£…æˆ { type: 'KLINE_UPDATE', ... } æ¶ˆæ¯ï¼Œå¹¿æ’­ç»™æ‰€æœ‰ Clientã€‚åœ¨è½¬æ¢æ—¶ï¼Œext_ ç›¸å…³å­—æ®µå…¨éƒ¨ç½®ä¸º 0ã€‚

å„ä¸ªé¡µé¢çš„ kl_client æ”¶åˆ°æ¶ˆæ¯ï¼Œè°ƒç”¨è‡ªå·±é¡µé¢å†…å­˜ä¸­å¯¹åº” K_Line å®ä¾‹çš„ updateLast() æˆ– push() æ–¹æ³•ï¼ŒUI å®æ—¶å“åº”ã€‚

å½“ WebSocket æ›´æ–° Worker å†…å­˜æ—¶ï¼Œå°†è¯¥å“ç§æ ‡è®°ä¸ºâ€œè„æ•°æ®â€ (dirtySymbols.add('BTCUSDT'))ã€‚

SharedWorker å†…éƒ¨æ¯30ç§’è§¦å‘ä¸€æ¬¡å®šæ—¶å™¨ï¼Œéå†æ‰€æœ‰â€œè„æ•°æ®â€å“ç§ï¼Œå°†å…¶åœ¨ Worker å†…å­˜ä¸­çš„æœ€æ–°Kçº¿æ•°æ® (ArrayBuffer) å›å†™å…¥ IndexedDBã€‚

5. æ•°æ®æ ¼å¼ä¸é€šä¿¡åè®®

Client -> Worker

code
TypeScript
download
content_copy
expand_less
// è¯·æ±‚/è®¢é˜…æŸäº›å“ç§çš„æ‰€æœ‰å‘¨æœŸKçº¿
interface SubscribeSymbolsMessage {
 type: 'SUBSCRIBE_SYMBOLS';
 payload: {
 symbols: string[];
 };
}

Worker -> Client

code
TypeScript
download
content_copy
expand_less
// é¦–æ¬¡å‘é€æŸä¸ªå‘¨æœŸçš„å®Œæ•´Kçº¿æ•°æ® (äºŒè¿›åˆ¶)
// æ³¨æ„ï¼šå…ƒæ•°æ®(length, head, tail)å·²åŒ…å«åœ¨bufferå¤´éƒ¨ï¼Œæ— éœ€é¢å¤–å­—æ®µ
interface InitialKlineDataMessage {
 type: 'INITIAL_KLINE_DATA';
 payload: {
 symbol: string;
 index: number; // å‘¨æœŸç´¢å¼•
 buffer: ArrayBuffer; // K_Line å®ä¾‹çš„åº•å±‚ ArrayBufferï¼Œè‡ªåŒ…å«å…ƒæ•°æ®
 };
}

// å¹¿æ’­å®æ—¶Kçº¿æ›´æ–° (JSON)
interface KlineUpdateMessage {
 type: 'KLINE_UPDATE';
 payload: {
 symbol: string;
 index: number;
 updateType: 'push' | 'updateLast';
 kline: ONE_K; // å®Œæ•´çš„Kçº¿å¯¹è±¡
 };
}
6. æ•°æ®ä¸€è‡´æ€§ä¸ç»´æŠ¤ (3000æ¡Kçº¿è§„åˆ™)

å†…å­˜å±‚é¢ (CycleArray): K_Line ç±»çš„å®¹é‡å°†è®¾ç½®ä¸º 3000ã€‚å½“é€šè¿‡ WebSocket push ä¸€æ ¹æ–°Kçº¿æ—¶ï¼Œå¦‚æœæ•°ç»„å·²æ»¡ï¼Œæœ€è€çš„ä¸€æ ¹ä¼šè‡ªåŠ¨è¢«ä¸¢å¼ƒã€‚

å­˜å‚¨å±‚é¢: ç”±äº K_Line çš„ ArrayBuffer å®¹é‡æ˜¯å›ºå®šçš„ (3000æ¡)ï¼Œå†™å…¥DBçš„æ•°æ®å¤©ç„¶å°±ä¸ä¼šè¶…è¿‡ä¸Šé™ï¼Œæ— éœ€ slice æ“ä½œã€‚

7. å®æ–½è®¡åˆ’ä¸ä»£ç ä¿®æ”¹

é‡æ„ CycleArray ä»¥åœ¨ ArrayBuffer å¤´éƒ¨åŒ…å«å…ƒæ•°æ®ï¼Œå¹¶æ·»åŠ  setBackingBuffer æ–¹æ³•ã€‚

code
TypeScript
download
content_copy
expand_less
// src/_____lib/func/CycleArray.ts
/**
 * CycleArray - é«˜æ€§èƒ½åˆ—å¼å­˜å‚¨å¾ªç¯æ•°ç»„
 * 
 * å†…å­˜å¸ƒå±€:
 * [METADATA_HEADER] [COLUMN_1_DATA] [COLUMN_2_DATA] ... [COLUMN_N_DATA]
 * 
 * METADATA_HEADER (16 bytes):
 * - head (Uint32): æŒ‡å‘ç¬¬ä¸€æ¡æ•°æ®çš„ç´¢å¼•ã€‚
 * - tail (Uint32): æŒ‡å‘ä¸‹ä¸€æ¡å¯æ’å…¥æ•°æ®çš„ç´¢å¼•ã€‚
 * - length (Uint32): æ•°ç»„ä¸­çš„å®é™…æ•°æ®é‡ã€‚
 * - capacity (Uint32): æ•°ç»„çš„æœ€å¤§å®¹é‡ã€‚
 * 
 * è¿™ç§è®¾è®¡ä½¿å¾—æ•´ä¸ªæ•°æ®ç»“æ„ï¼ˆåŒ…æ‹¬çŠ¶æ€ï¼‰å¯ä»¥è¢«ä¸€ä¸ª ArrayBuffer å®Œæ•´è¡¨ç¤ºï¼Œ
 * æ–¹ä¾¿é€šè¿‡ postMessage è¿›è¡Œé›¶æ‹·è´ä¼ è¾“å’Œé€šè¿‡ IndexedDB è¿›è¡ŒæŒä¹…åŒ–ã€‚
 */
const METADATA_HEADER_SIZE = 16; // 4 * Uint32

export function CycleArray<T extends { [key: string]: any }>(
 schema: { [K in keyof T]: new (buffer: ArrayBuffer, byteOffset: number, length: number) => T[K] },
 capacity: number
) {
 const fields = Object.keys(schema) as (keyof T)[];
 const fieldConstructors = Object.values(schema);
 const bytesPerElementForField = fieldConstructors.map(c => (c as any).BYTES_PER_ELEMENT);

 const fieldBlockSize = bytesPerElementForField.map(b => b * capacity);
 const totalDataByteLength = fieldBlockSize.reduce((sum, size) => sum + size, 0);
 const totalRecordByteLength = METADATA_HEADER_SIZE + totalDataByteLength;

 return class CycleArrayImpl {
 static readonly å­—èŠ‚æ•° = totalRecordByteLength;
 static readonly ARR_MAX_LENGTH = capacity;

 private buffer: ArrayBuffer;
 private metadata: Uint32Array; // View for head, tail, length, capacity
 public data: T;

 constructor(buffer?: ArrayBuffer, byteOffset: number = 0) {
 if (buffer) {
 this.buffer = buffer.slice(byteOffset, byteOffset + totalRecordByteLength);
 } else {
 this.buffer = new ArrayBuffer(totalRecordByteLength);
 }
 this.metadata = new Uint32Array(this.buffer, 0, 4);
 
 if (!buffer) {
 this.metadata[3] = capacity; // capacity
 }

 this.data = {} as T;
 this.initDataViews();
 }

 private initDataViews() {
 let currentOffset = METADATA_HEADER_SIZE;
 fields.forEach((key, i) => {
 const constructor = schema[key];
 // @ts-ignore
 this.data[key] = new constructor(this.buffer, currentOffset, capacity);
 currentOffset += fieldBlockSize[i];
 });
 }

 get head() { return this.metadata[0]; }
 private set head(val: number) { this.metadata[0] = val; }

 get tail() { return this.metadata[1]; }
 private set tail(val: number) { this.metadata[1] = val; }

 get length() { return this.metadata[2]; }
 private set length(val: number) { this.metadata[2] = val; }

 get capacity() { return this.metadata[3]; }

 get underlyingBuffer(): ArrayBuffer {
 return this.buffer;
 }

 push(item: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }) {
 fields.forEach(key => {
 // @ts-ignore
 this.data[key][this.tail] = item[key];
 });

 if (this.length === this.capacity) {
 this.tail = (this.tail + 1) % this.capacity;
 this.head = (this.head + 1) % this.capacity;
 } else {
 this.tail = (this.tail + 1) % this.capacity;
 this.length++;
 }
 }

 updateLast(item: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }) {
 if (this.length === 0) {
 this.push(item);
 return;
 }
 const lastIndex = (this.tail - 1 + this.capacity) % this.capacity;
 fields.forEach(key => {
 // @ts-ignore
 this.data[key][lastIndex] = item[key];
 });
 }

 set(items: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }[]) {
 this.clear();
 const itemsToPush = items.slice(-this.capacity);
 for (const item of itemsToPush) {
 this.push(item);
 }
 }
 
 set_f64(data_f64: { [key: string]: Float64Array | BigInt64Array }) {
 this.clear();
 const len = data_f64.close.length;
 for (let i = 0; i < len; i++) {
 const item: any = {};
 fields.forEach(key => {
 item[key] = data_f64[key][i];
 });
 this.push(item);
 }
 }

 clear() {
 this.head = 0;
 this.tail = 0;
 this.length = 0;
 }

 setBackingBuffer(newBuffer: ArrayBuffer) {
 if (newBuffer.byteLength !== this.buffer.byteLength) {
 console.error(`[CycleArray] Mismatched buffer size in setBackingBuffer. Expected ${this.buffer.byteLength}, got ${newBuffer.byteLength}.`);
 return;
 }
 this.buffer = newBuffer;
 this.metadata = new Uint32Array(this.buffer, 0, 4);
 this.initDataViews();
 }

 [Symbol.iterator]() {
 let count = 0;
 let currentIndex = this.head;
 return {
 next: () => {
 if (count < this.length) {
 const item: any = {};
 fields.forEach(key => {
 item[key] = this.data[key][currentIndex];
 });
 currentIndex = (currentIndex + 1) % this.capacity;
 count++;
 return { value: item, done: false };
 }
 return { value: undefined, done: true };
 }
 };
 }
 };
}
code
TypeScript
download
content_copy
expand_less
// src/kl_server/ONE_K.ts
import { CycleArray } from "../_____lib/func/CycleArray";

export type ONE_K = {
 timestamp: number| bigint;
 open: number;
 high: number;
 low: number;
 close: number;
 æˆäº¤é¢: number;
 ext_æŒä»“é‡: number;
 ext_èµ„é‡‘è´¹ç‡: number;
 ext_å¤šç©ºæ¯”: number;
};

export class K_Line extends CycleArray({
 timestamp: BigInt64Array,
 open: Float64Array,
 high: Float64Array,
 low: Float64Array,
 close: Float64Array,
 æˆäº¤é¢: Float64Array,
 ext_æŒä»“é‡: Float64Array,
 ext_èµ„é‡‘è´¹ç‡: Float64Array,
 ext_å¤šç©ºæ¯”: Float64Array,
}, 3000) { } // <--- ä¿®æ”¹ä¸º 3000
code
TypeScript
download
content_copy
expand_less
// public/kline_db_manager.ts
const DB_NAME = 'kline_cache_db';
const DB_VERSION = 1;
const KLINE_STORE_NAME = 'klines'; // å•ä¸€å¯¹è±¡å­˜å‚¨

let dbPromise: Promise<IDBDatabase> | null = null;

export const klineDBManager = {
 async init(): Promise<void> {
 if (dbPromise) return;

 dbPromise = new Promise((resolve, reject) => {
 const request = indexedDB.open(DB_NAME, DB_VERSION);

 request.onerror = () => {
 console.error('[DBManager] IndexedDB open error:', request.error);
 reject(new Error('Failed to open IndexedDB.'));
 };

 request.onsuccess = () => {
 console.log('[DBManager] IndexedDB connection successful.');
 resolve(request.result);
 };

 request.onupgradeneeded = (event) => {
 console.log('[DBManager] Upgrading IndexedDB...');
 const db = (event.target as IDBOpenDBRequest).result;
 if (!db.objectStoreNames.contains(KLINE_STORE_NAME)) {
 db.createObjectStore(KLINE_STORE_NAME);
 console.log(`[DBManager] Object store "${KLINE_STORE_NAME}" created.`);
 }
 };
 });

 try {
 await dbPromise;
 } catch (error) {
 dbPromise = null;
 throw error;
 }
 },

 async getKline(key: string): Promise<ArrayBuffer | undefined> {
 if (!dbPromise) await this.init();
 const db = await dbPromise!;

 return new Promise((resolve, reject) => {
 const transaction = db.transaction(KLINE_STORE_NAME, 'readonly');
 const store = transaction.objectStore(KLINE_STORE_NAME);
 const request = store.get(key);

 request.onerror = () => reject(request.error);
 request.onsuccess = () => resolve(request.result as ArrayBuffer | undefined);
 });
 },

 async saveKline(key: string, data: ArrayBuffer): Promise<void> {
 if (!dbPromise) await this.init();
 const db = await dbPromise!;

 return new Promise((resolve, reject) => {
 const transaction = db.transaction(KLINE_STORE_NAME, 'readwrite');
 const store = transaction.objectStore(KLINE_STORE_NAME);
 const request = store.put(data, key);

 transaction.oncomplete = () => resolve();
 transaction.onerror = () => reject(transaction.error);
 });
 }
};
code
TypeScript
download
content_copy
expand_less
// public/kline_worker.ts
import { ALL_K } from '../src/kl_server/BA_1';
import { K_Line, ONE_K } from '../src/kl_server/ONE_K';
import { binance_kline_å‘¨æœŸ_é…ç½® } from '../src/kl_server/binance_kline_å‘¨æœŸ_é…ç½®';
import { klineDBManager } from './kline_db_manager';

// --- Worker å…¨å±€çŠ¶æ€ ---
const ports: MessagePort[] = [];
const klineDB = new ALL_K(); // Worker å†…éƒ¨çš„æƒå¨å†…å­˜æ•°æ®åº“
const dirtySymbols = new Set<string>();

// --- WebSocket ç®¡ç† ---
let ws: WebSocket | null = null;
let connectionState: 'DISCONNECTED' | 'CONNECTING' | 'CONNECTED' = 'DISCONNECTED';
const activeSubscriptions = new Set<string>();
const pendingSubscriptionQueue = new Set<string>();
let subscriptionIdCounter = 1;
const subscriptionIdToStreamsMap = new Map<number, string[]>();

// --- HTTP è¯·æ±‚ç®¡ç† ---
const RUST_BACKEND_URL = 'http://127.0.0.1:3000';

// --- åˆå§‹åŒ– ---
klineDBManager.init().catch(err => {
 console.error('[Worker] CRITICAL: Failed to initialize IndexedDB. Worker will not function.', err);
 self.close();
});

// --- WebSocket æ ¸å¿ƒåŠŸèƒ½ ---
function connectWebSocket() {
 if (connectionState !== 'DISCONNECTED') return;
 console.log('[Worker] WebSocket: Connecting...');
 connectionState = 'CONNECTING';
 ws = new WebSocket('wss://fstream.mokexapp.info/ws');
 ws.onopen = () => {
 console.log('[Worker] WebSocket: Connection OPENED.');
 connectionState = 'CONNECTED';
 activeSubscriptions.forEach(stream => pendingSubscriptionQueue.add(stream));
 activeSubscriptions.clear();
 };
 ws.onmessage = onWebSocketMessage;
 ws.onclose = () => {
 console.log('[Worker] WebSocket: Connection CLOSED. Reconnecting in 3s...');
 ws = null;
 connectionState = 'DISCONNECTED';
 setTimeout(connectWebSocket, 3000);
 };
 ws.onerror = (error) => console.error('[Worker] WebSocket: Error:', error);
}

setInterval(() => {
 if (connectionState === 'CONNECTED' && ws && pendingSubscriptionQueue.size > 0) {
 const batch = Array.from(pendingSubscriptionQueue).slice(0, 50);
 if (batch.length === 0) return;
 const id = subscriptionIdCounter++;
 const subscribeMessage = { method: "SUBSCRIBE", params: batch, id };
 ws.send(JSON.stringify(subscribeMessage));
 console.log(`[Worker] WebSocket: Sent SUBSCRIBE request for ${batch.length} streams (ID: ${id}).`);
 subscriptionIdToStreamsMap.set(id, batch);
 batch.forEach(stream => pendingSubscriptionQueue.delete(stream));
 }
}, 500);

function onWebSocketMessage(event: MessageEvent) {
 const msg = JSON.parse(event.data);
 if (msg.stream && msg.data?.e === 'continuous_kline') {
 const { ps: symbol, k } = msg.data;
 const periodConfig = binance_kline_å‘¨æœŸ_é…ç½®.find(p => p.interval === k.i);
 if (!periodConfig) return;
 const index = binance_kline_å‘¨æœŸ_é…ç½®.indexOf(periodConfig);
 const key = `${symbol}_${index}`;
 const klineInstance = klineDB.get_kline(key);
 if (klineInstance.length === 0) return;
 const oneK: ONE_K = {
 timestamp: BigInt(k.t), open: parseFloat(k.o), high: parseFloat(k.h),
 low: parseFloat(k.l), close: parseFloat(k.c), æˆäº¤é¢: parseFloat(k.q),
 ext_æŒä»“é‡: 0, ext_å¤šç©ºæ¯”: 0, ext_èµ„é‡‘è´¹ç‡: 0,
 };
 const updateType = k.x ? 'push' : 'updateLast';
 if (updateType === 'push') klineInstance.push(oneK);
 else klineInstance.updateLast(oneK);
 dirtySymbols.add(symbol);
 broadcast({ type: 'KLINE_UPDATE', payload: { symbol, index, updateType, kline: oneK } });
 return;
 }
 if (msg.id) {
 const streams = subscriptionIdToStreamsMap.get(msg.id);
 if (msg.result === null) {
 console.log(`[Worker] WebSocket: Subscription success for ID ${msg.id}`);
 streams?.forEach(stream => activeSubscriptions.add(stream));
 } else if (msg.error) {
 console.error(`[Worker] WebSocket: Subscription failed for ID ${msg.id}`, msg.error);
 setTimeout(() => {
 streams?.forEach(stream => pendingSubscriptionQueue.add(stream));
 console.log(`[Worker] WebSocket: Re-queuing ${streams?.length} failed streams for retry.`);
 }, 3000);
 }
 subscriptionIdToStreamsMap.delete(msg.id);
 }
}

// --- æ•°æ®åŠ è½½ä¸ç¼“å­˜æ ¸å¿ƒé€»è¾‘ ---
async function loadHistoricalDataForSymbol(symbol: string) {
 console.log(`[Worker] Starting data load process for ${symbol}...`);
 const periods = binance_kline_å‘¨æœŸ_é…ç½®;
 for (let i = 0; i < periods.length; i++) {
 const { interval } = periods[i];
 const key = `${symbol}_${i}`;
 if (klineDB.get_kline(key) && klineDB.get_kline(key).length > 0) {
 const klineInstance = klineDB.get_kline(key);
 const bufferToSend = klineInstance.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 continue;
 }
 const dbBuffer = await klineDBManager.getKline(key);
 const dbKline = dbBuffer ? new K_Line(dbBuffer) : null;
 const url = `${RUST_BACKEND_URL}/klines?symbol=${symbol}&interval=${interval}&limit=3000`;
 const response = await fetch(url);
 if (!response.ok) { console.error(`[Worker] Failed to fetch ${key}. Status: ${response.status}`); continue; }
 const networkData: ONE_K[] = await response.json();
 if (!networkData || networkData.length === 0) {
 if (dbKline) { // å¦‚æœDBæœ‰æ•°æ®ä½†ç½‘ç»œæ²¡è¿”å›ï¼Œä¾ç„¶ä½¿ç”¨DBæ•°æ®
 klineDB.get_kline(key).setBackingBuffer(dbKline.underlyingBuffer);
 const bufferToSend = dbKline.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 }
 continue;
 }
 const finalKline = dbKline || new K_Line();
 if (dbKline && dbKline.length > 0) {
 const lastDbTimestamp = Number(dbKline.data.timestamp[dbKline.length - 1]);
 const newBars = networkData.filter(k => Number(k.timestamp) > lastDbTimestamp);
 newBars.forEach(bar => finalKline.push({ ...bar, timestamp: BigInt(bar.timestamp) }));
 } else {
 finalKline.set(networkData.map(bar => ({ ...bar, timestamp: BigInt(bar.timestamp) })));
 }
 klineDB.get_kline(key).setBackingBuffer(finalKline.underlyingBuffer);
 await klineDBManager.saveKline(key, finalKline.underlyingBuffer);
 const bufferToSend = finalKline.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 }
 periods.forEach(p => {
 const streamName = `${symbol.toLowerCase()}_perpetual@continuousKline_${p.interval}`;
 pendingSubscriptionQueue.add(streamName);
 });
}

// --- Worker é€šä¿¡ä¸ç”Ÿå‘½å‘¨æœŸ ---
onconnect = (e: SharedWorkerGlobalScopeConnectEvent) => {
 const port = e.ports[0];
 ports.push(port);
 if (ports.length === 1) connectWebSocket();
 port.onmessage = async (event: MessageEvent) => {
 const { type, payload } = event.data;
 if (type === 'SUBSCRIBE_SYMBOLS') {
 for (const symbol of payload.symbols) {
 loadHistoricalDataForSymbol(symbol);
 }
 }
 };
 port.start();
};

function broadcast(message: any, transferables?: Transferable[]) {
 ports.forEach(port => port.postMessage(message, transferables || []));
}

// --- åå°æŒä¹…åŒ– ---
setInterval(async () => {
 if (dirtySymbols.size === 0) return;
 const symbolsToSave = Array.from(dirtySymbols);
 dirtySymbols.clear();
 for (const symbol of symbolsToSave) {
 for (let i = 0; i < binance_kline_å‘¨æœŸ_é…ç½®.length; i++) {
 const key = `${symbol}_${i}`;
 const klineInstance = klineDB.get_kline(key);
 if (klineInstance && klineInstance.length > 0) {
 await klineDBManager.saveKline(key, klineInstance.underlyingBuffer);
 }
 }
 }
}, 30000);
code
TypeScript
download
content_copy
expand_less
// src/kl_server/kl_client.ts
import { K_Line } from "./ONE_K";
import { SyncClient } from "../_____lib/net/sync/SyncClient";
import { ALL_K } from "./BA_1";
import { BA_2 } from "./BA_2";
import { BA_3 } from "./BA_3";
import { binance_symbolToAssetCode } from "./binance_symbolToAssetCode";

export namespace kl_client {
 let worker: SharedWorker | null = null;
 const klineDB = new ALL_K();

 export let c3: SyncClient<typeof BA_3.realDB, typeof BA_3.funcList>;
 export let c2: SyncClient<typeof BA_2.realDB, typeof BA_2.funcList>;
 let _indexServer: any;
 export let isInitialSyncComplete = false;
 export let onDataUpdated: () => void = () => {};

 function handleWorkerMessage(event: MessageEvent) {
 const { type, payload } = event.data;
 switch (type) {
 case 'INITIAL_KLINE_DATA': {
 const { symbol, index, buffer } = payload;
 const key = `${symbol}_${index}`;
 klineDB.get_kline(key).setBackingBuffer(buffer);
 break;
 }
 case 'KLINE_UPDATE': {
 const { symbol, index, updateType, kline } = payload;
 const key = `${symbol}_${index}`;
 const klineInstance = klineDB.get_kline(key);
 const klineForUI = { ...kline, timestamp: BigInt(kline.timestamp) };
 if (updateType === 'push') {
 klineInstance.push(klineForUI);
 } else {
 klineInstance.updateLast(klineForUI);
 }
 break;
 }
 }
 onDataUpdated();
 }

 export function connect() {
 if (!worker) {
 try {
 worker = new SharedWorker('kline_worker.js', { name: 'KlineDataWorker' });
 worker.port.onmessage = handleWorkerMessage;
 worker.port.start();
 console.log('[kl_client] Successfully connected to SharedWorker.');
 } catch (error) {
 console.error('[kl_client] CRITICAL: Failed to connect to SharedWorker. K-line data will not be available.', error);
 return;
 }
 }

 if (c2 && c3) return;
 c3 = new SyncClient('kl_client_ba3', BA_3);
 c2 = new SyncClient('kl_client_ba2', BA_2);
 let c2_ok = false, c3_ok = false;
 const check_sync_ok = () => {
 if (c2_ok && c3_ok && !isInitialSyncComplete) {
 isInitialSyncComplete = true;
 console.log(`[kl_client] ğŸš€ Backend Info/Stats sync complete!`);
 onDataUpdated();
 }
 };
 c2.onStatusChange.subscribe(() => { if (c2.isConnected) { c2_ok = true; check_sync_ok(); } });
 c3.onStatusChange.subscribe(() => { if (c3.isConnected) { c3_ok = true; check_sync_ok(); } });
 c3.connect();
 c2.connect();
 }

 export function addSymbolKline(symbols: string[]) {
 if (!worker || symbols.length === 0) return;
 worker.port.postMessage({
 type: 'SUBSCRIBE_SYMBOLS',
 payload: { symbols }
 });
 }

 export const getKline = (symbol: string, index: number): K_Line => {
 return klineDB.get_kline(`${symbol}_${index}`);
 }

 // --- ä»¥ä¸‹å‡½æ•°ä¿æŒä¸å˜ ---
 export function setIndexServer(server: any) { _indexServer = server; }
 export function getIndices() {
 if (!_indexServer) return { marketCapIndex: 0, equalWeightIndex: 0, timestamp: 0 };
 return _indexServer.getIndices();
 }
 export const disconnect = () => {
 worker?.port.close();
 worker = null;
 c3?.disconnect();
 c2?.disconnect();
 }
 export const getåˆçº¦info = (symbol: string) => {
 if (!c2) return { tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1, market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0 };
 let info = c2.realDB.data.åˆçº¦_info[symbol];
 if (info === undefined) info = { tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1, market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0 };
 return info;
 }
 export const getåˆçº¦__ç°è´§_info = (symbol: string) => {
 if (!c2) return { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
 let info = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol];
 if (info === undefined) info = { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
 return info;
 }
 export const getå¤šç©ºæ¯” = (symbol: string) => {
 const v = getKline(symbol, 0);
 return v.data.ext_å¤šç©ºæ¯”.length > 0 ? v.data.ext_å¤šç©ºæ¯”[v.data.ext_å¤šç©ºæ¯”.length - 1] : 0;
 }
 export const isæ ‡è®°ä»·æ ¼è¿‘ = (symbol: string) => {
 const æœ€æ–° = get24æœ€æ–°(symbol).æœ€æ–°ä»·æ ¼;
 const æ ‡è®° = getè´¹ç‡(symbol).æ ‡è®°ä»·æ ¼;
 if (isNaN(æœ€æ–°) || isNaN(æ ‡è®°)) return false;
 return Math.max(æœ€æ–°, æ ‡è®°) / Math.min(æœ€æ–°, æ ‡è®°) < 1.001;
 };
 export const getå…¨éƒ¨å“ç§ = () => c2 ? Object.keys(c2.realDB.data.åˆçº¦_info) : [];
 export const getè´¹ç‡ = (symbol: string) => (c2 && c2.realDB.data.åˆçº¦__æ ‡è®°ä»·æ ¼[symbol]) || { æ ‡è®°ä»·æ ¼: NaN, ç°è´§æŒ‡æ•°ä»·æ ¼: NaN, èµ„é‡‘è´¹ç‡: NaN, èµ„é‡‘è´¹ç‡å€’è®¡æ—¶: NaN };
 export const get24æœ€æ–° = (symbol: string) => ({ æœ€æ–°ä»·æ ¼: getOrderBook(symbol).buy1 });
 export const getæµé€šå¸‚å€¼ = (symbol: string) => {
 if (!c2) return 0;
 const price = kl_client.getOrderBook(symbol).buy1;
 const supply = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol]?.æµé€šé‡ || 0;
 return price * supply;
 }
 export const getæ‰‹åŠ¨dataSRC = (symbol: string) => (c2 && c2.realDB.data.æ‰‹åŠ¨_symbol_info_dic[symbol]) || { __: '', assetName: binance_symbolToAssetCode(symbol), tags_dic: {}, website: '', X: '' };
 export const getæ‰‹åŠ¨_é¢˜æ_æ’åº = () => c2 ? c2.realDB.data.æ‰‹åŠ¨_é¢˜æ_æ’åº : [];
 export const getOrderBook = (symbol: string) => {
 const close = getKline(symbol, 0).data.close;
 return {
 buy1: close.length > 0 ? close[close.length - 1] : NaN,
 sell1: close.length > 0 ? close[close.length - 1] : NaN,
 }
 }
 export interface TurnoverRankItem { symbol: string; turnover: number; price: number; marketCap: number; }
 export const getTurnoverTop15 = (): TurnoverRankItem[] => {
 if (!c3?.realDB.data.rankings) return [];
 return Object.entries(c3.realDB.data.rankings)
 .map(([symbol, stats]) => ({
 symbol: symbol,
 turnover: (stats?._7å¤©æˆäº¤é¢ ?? 0) / 100000000,
 price: getOrderBook(symbol)?.buy1 ?? 0,
 marketCap: getæµé€šå¸‚å€¼(symbol) ?? 0,
 }))
 .sort((a, b) => b.turnover - a.turnover)
 .slice(0, 15);
 }
}
<system>
Whenever proposing a new or updated file, show the path in a first-line comment of a Markdown Code Block. Please show me the proposed files in full because I have a disability which means I can't type and need to be able to just copy and paste.
</system>