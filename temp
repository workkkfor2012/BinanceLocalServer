å¥½çš„ï¼Œæˆ‘å®Œå…¨ç†è§£ä½ çš„æ–°éœ€æ±‚ã€‚è¿™æ˜¯ä¸€ä¸ªæ›´ç²¾ç¡®ã€æ›´å¸¸è§çš„ç¼“å­˜ç­–ç•¥ã€‚æˆ‘ä»¬ä¸æ˜¯åœ¨æ„å»ºä¸€ä¸ªåºå¤§çš„å†å²æ•°æ®åº“ï¼Œè€Œæ˜¯å°† SQLite ç”¨ä½œå†…å­˜ç¼“å­˜çš„æŒä¹…åŒ–åå¤‡ï¼ˆPersistence Backendï¼‰ã€‚

ç›®æ ‡å¾ˆæ˜ç¡®ï¼š

é‡å¯åèƒ½å¿«é€Ÿæ¢å¤çŠ¶æ€ï¼šæœåŠ¡é‡å¯æ—¶ï¼Œå†…å­˜æ˜¯ç©ºçš„ã€‚æˆ‘ä»¬å¸Œæœ›ä» SQLite æ–‡ä»¶ä¸­æŠŠä¸Šæ¬¡å…³é—­å‰çš„ç¼“å­˜çŠ¶æ€â€œåŠ è½½â€å›å†…å­˜ã€‚

æ“ä½œä¸­å¿ƒä»åœ¨å†…å­˜ï¼šä¸€æ—¦æ•°æ®è¢«åŠ è½½åˆ°å†…å­˜ï¼Œæ‰€æœ‰çš„è¯»ã€å†™ã€æ›´æ–°é€»è¾‘éƒ½åº”è¯¥ä¸»è¦å›´ç»•å†…å­˜ç¼“å­˜ï¼ˆDashMapï¼‰è¿›è¡Œï¼Œå› ä¸ºå®ƒæœ€å¿«ã€‚

ç¡¬ç›˜æ˜¯å†…å­˜çš„â€œå½±å­â€ï¼šå¯¹å†…å­˜ç¼“å­˜çš„ä»»ä½•æ›´æ–°ï¼ˆæ— è®ºæ˜¯å…¨é‡è·å–è¿˜æ˜¯å¢é‡æ›´æ–°ï¼‰ï¼Œéƒ½åº”è¯¥å¼‚æ­¥åœ°â€œåˆ·â€åˆ°ç¡¬ç›˜ä¸Šçš„ SQLite æ–‡ä»¶ä¸­ï¼Œä»¥ä¿è¯ä¸‹æ¬¡é‡å¯æ—¶èƒ½åŠ è½½åˆ°æœ€æ–°çš„æ•°æ®ã€‚

è¿™ç§ç­–ç•¥ä¸‹ï¼ŒæŸ¥è¯¢æµç¨‹ä¼šç®€åŒ–ã€‚æˆ‘ä»¬ä¸å†éœ€è¦å¤æ‚çš„ Memory -> DB -> Network æ£€æŸ¥é“¾ã€‚æ–°çš„é€»è¾‘æ›´åƒæ˜¯ï¼š

è¯·æ±‚åˆ°è¾¾ï¼š

æ£€æŸ¥å†…å­˜ï¼Ÿ

å‘½ä¸­: æ•°æ®åœ¨å†…å­˜é‡Œã€‚æ£€æŸ¥æ˜¯å¦è¿‡æ—¶ï¼ˆstaleï¼‰ã€‚

ä¸è¿‡æ—¶ -> ç›´æ¥è¿”å›ã€‚

è¿‡æ—¶ -> åšä¸€æ¬¡å¢é‡ç½‘ç»œæ›´æ–° -> æ›´æ–°å†…å­˜ -> å¼‚æ­¥æ›´æ–°ç¡¬ç›˜ -> è¿”å›ã€‚

æœªå‘½ä¸­: å†…å­˜é‡Œæ²¡æœ‰ã€‚

å°è¯•ä»ç¡¬ç›˜åŠ è½½ -> èƒ½åŠ è½½åˆ°å—ï¼Ÿ

èƒ½: æŠŠç¡¬ç›˜æ•°æ®æ”¾å…¥å†…å­˜ -> ç°åœ¨ç›¸å½“äºå†…å­˜å‘½ä¸­äº†ï¼Œå›åˆ°ä¸Šä¸€æ­¥ï¼Œæ£€æŸ¥è¿™ä»½åˆšåŠ è½½çš„æ•°æ®æ˜¯å¦è¿‡æ—¶ï¼Œå¹¶æŒ‰éœ€æ›´æ–°ã€‚

ä¸èƒ½ (ç¡¬ç›˜é‡Œä¹Ÿæ²¡æœ‰): è¯´æ˜è¿™æ˜¯å…¨æ–°çš„æ•°æ®è¯·æ±‚ -> åšä¸€æ¬¡å…¨é‡ç½‘ç»œè·å– -> æ”¾å…¥å†…å­˜ -> å¼‚æ­¥å†™å…¥ç¡¬ç›˜ -> è¿”å›ã€‚

è¿™ä¸ªé€»è¾‘çš„æ ¸å¿ƒæ˜¯ï¼šç¡¬ç›˜åªåœ¨å†…å­˜æœªå‘½ä¸­æ—¶è¢«è¯»å–ä¸€æ¬¡ï¼Œç”¨äºâ€œæ°´åˆâ€ï¼ˆhydrateï¼‰å†…å­˜ç¼“å­˜ã€‚è€Œæ‰€æœ‰çš„æ•°æ®å˜æ›´æœ€ç»ˆéƒ½ä¼šè¢«å†™å›ç¡¬ç›˜ã€‚

è¿™ä¸ªç­–ç•¥éå¸¸é€‚åˆä½ æåˆ°çš„å‘¨çº¿ã€æ—¥çº¿ç­‰ä¸å¸¸å˜åŒ–çš„æ•°æ®ã€‚ä¸‹è½½ä¸€æ¬¡åï¼Œå®ƒä»¬ä¼šä¸€ç›´å­˜åœ¨äºç¡¬ç›˜å’Œå†…å­˜ä¸­ï¼Œå‡ ä¹ä¸éœ€è¦å†æ¬¡ä¸‹è½½ã€‚

ç–‘é—®ä¸æ€è€ƒ

è¿™ä¸ªæ–°ç­–ç•¥æ˜¯å¦å®Œç¾æ»¡è¶³ä½ çš„éœ€æ±‚ï¼Ÿ å®ƒä¸“æ³¨äºå¿«é€Ÿé‡å¯å’Œæ¢å¤ï¼Œè€Œä¸æ˜¯å†å²å½’æ¡£ã€‚åœ¨æˆ‘çœ‹æ¥ï¼Œè¿™å®Œå…¨ç¬¦åˆä½ åˆšæ‰çš„æè¿°ã€‚

å†™å…¥æ—¶æœºï¼šæˆ‘ä»¬å°†æ‰€æœ‰æ•°æ®åº“å†™å…¥æ“ä½œéƒ½æ”¾åœ¨ tokio::task::spawn ä¸­ã€‚è¿™æ„å‘³ç€å†™å…¥æ•°æ®åº“ä¸ä¼šé˜»å¡å¯¹å®¢æˆ·ç«¯çš„å“åº”ï¼Œè¿™å¯¹äºä¿æŒä½å»¶è¿Ÿè‡³å…³é‡è¦ã€‚ä½†è¿™ä¹Ÿæ„å‘³ç€ä¸€ä¸ªæç«¯çš„è¾¹ç¼˜æƒ…å†µï¼šå¦‚æœåœ¨è¿”å›å“åº”å’Œæ•°æ®åº“å®Œæˆå†™å…¥ä¹‹é—´çš„å‡ æ¯«ç§’å†…æœåŠ¡å´©æºƒï¼Œé‚£æœ€åä¸€æ¬¡æ›´æ–°å¯èƒ½ä¼šä¸¢å¤±ã€‚å¯¹äºæˆ‘ä»¬çš„åº”ç”¨åœºæ™¯æ¥è¯´ï¼Œè¿™ä¸ªé£é™©å®Œå…¨å¯ä»¥æ¥å—ã€‚

è®©æˆ‘ä»¬æ¥å®æ–½è¿™ä¸ªæ›´ç®€æ´ã€æ›´é«˜æ•ˆçš„ç­–ç•¥ã€‚æ”¹åŠ¨å°†å®Œå…¨é›†ä¸­åœ¨ src/cache_manager.rs ä¸­ã€‚

ä»£ç å®ç°

å…¶ä»–æ–‡ä»¶ï¼ˆCargo.toml, db_manager.rs, main.rs ç­‰ï¼‰ä¸æˆ‘ä¸Šä¸€ä¸ªå›ç­”ä¸­çš„ç‰ˆæœ¬å®Œå…¨ç›¸åŒï¼Œå› ä¸ºåº•å±‚çš„æ•°æ®åº“è¿æ¥å’Œåˆå§‹åŒ–é€»è¾‘ä¸éœ€è¦æ”¹å˜ã€‚æˆ‘ä»¬åªéœ€è¦é‡å†™ CacheManager çš„æ ¸å¿ƒé€»è¾‘ã€‚

src/cache_manager.rs (æ ¸å¿ƒä¿®æ”¹)

è¿™æ˜¯æˆ‘ä»¬å°†è¦åº”ç”¨çš„å…¨æ–°é€»è¾‘ã€‚æˆ‘ç”¨äº†ä¸€ä¸ª loop ç»“æ„æ¥ä¼˜é›…åœ°å¤„ç†â€œä»DBåŠ è½½åé‡æ–°æ£€æŸ¥â€çš„æµç¨‹ï¼Œé¿å…äº†ä»£ç é‡å¤ã€‚

code
Rust
download
content_copy
expand_less
// src/cache_manager.rs
use crate::api_client::ApiClient;
use crate::db_manager::DbManager;
use crate::error::{AppError, Result};
use crate::models::{DownloadTask, Kline};
use crate::utils;
use chrono::Utc;
use dashmap::DashMap;
use std::sync::Arc;
use tokio::task;
use tracing::{info, instrument, warn};

const KLINE_CACHE_LIMIT: usize = 3000;
const KLINE_FULL_FETCH_LIMIT: usize = 1500;

pub struct CacheManager {
    pub api_client: Arc<ApiClient>,
    pub db_manager: Arc<DbManager>,
    mem_cache: DashMap<(String, String), Vec<Kline>>,
}

impl CacheManager {
    pub fn new(api_client: Arc<ApiClient>, db_manager: Arc<DbManager>) -> Self {
        Self {
            api_client,
            db_manager,
            mem_cache: DashMap::new(),
        }
    }

    #[instrument(skip(self), fields(symbol = %symbol, interval = %interval))]
    pub async fn get_klines(&self, symbol: &str, interval: &str) -> Result<Vec<Kline>> {
        let cache_key = (symbol.to_string(), interval.to_string());

        // ä½¿ç”¨ loop ä¼˜é›…åœ°å¤„ç†â€œä»DBåŠ è½½åé‡æ–°è¯„ä¼°â€çš„é€»è¾‘
        loop {
            // --- æ­¥éª¤ 1: æ£€æŸ¥å†…å­˜ç¼“å­˜ ---
            if let Some(mut entry) = self.mem_cache.get_mut(&cache_key) {
                let klines = entry.value_mut();

                // æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æ—¶
                if let Some(last_kline) = klines.last() {
                    let interval_ms = utils::interval_to_milliseconds(interval)?;
                    let now_ms = Utc::now().timestamp_millis();

                    // å¦‚æœæ•°æ®è¶³å¤Ÿæ–°ï¼Œç›´æ¥è¿”å›
                    if now_ms - last_kline.open_time < interval_ms * 2 {
                        info!("âœ… [CACHE] Memory cache hit and fresh for {:?}.", cache_key);
                        let start_index = klines.len().saturating_sub(KLINE_FULL_FETCH_LIMIT);
                        return Ok(klines[start_index..].to_vec());
                    }

                    // --- æ•°æ®è¿‡æ—¶ï¼Œæ‰§è¡Œå¢é‡æ›´æ–° ---
                    info!("-> [CACHE] Memory cache stale for {:?}. Performing incremental update.", cache_key);
                    let task = DownloadTask {
                        symbol: cache_key.0.clone(),
                        interval: cache_key.1.clone(),
                        start_time: Some(last_kline.open_time),
                        end_time: None,
                        limit: KLINE_FULL_FETCH_LIMIT,
                    };
                    let new_klines = self.api_client.download_continuous_klines(&task).await?;

                    if !new_klines.is_empty() {
                        // å¼‚æ­¥ä¿å­˜åˆ°æ•°æ®åº“
                        let db_manager = self.db_manager.clone();
                        let klines_to_save = new_klines.clone();
                        let key_clone = cache_key.clone();
                        task::spawn(async move {
                            info!("ğŸ’¾ [ASYNC] Persisting {} incremental klines to DB for {:?}", klines_to_save.len(), key_clone);
                            if let Err(e) = db_manager.save_klines(&key_clone.0, &key_clone.1, &klines_to_save).await {
                                warn!("Failed to save incremental klines to DB: {}", e);
                            }
                        });

                        // æ›´æ–°å†…å­˜ç¼“å­˜
                        klines.pop(); // ç§»é™¤é‡å çš„æœ€åä¸€æ ¹
                        klines.extend(new_klines);
                        if klines.len() > KLINE_CACHE_LIMIT {
                            let overflow = klines.len() - KLINE_CACHE_LIMIT;
                            klines.drain(..overflow);
                        }
                    }
                    let start_index = klines.len().saturating_sub(KLINE_FULL_FETCH_LIMIT);
                    return Ok(klines[start_index..].to_vec());
                }
            } // å†…å­˜é”åœ¨æ­¤é‡Šæ”¾

            // --- æ­¥éª¤ 2: å†…å­˜æœªå‘½ä¸­ï¼Œå°è¯•ä»æ•°æ®åº“æ°´åˆï¼ˆHydrateï¼‰ ---
            info!("-> [CACHE] Memory cache miss for {:?}. Attempting to hydrate from DB.", cache_key);
            let klines_from_db = self.db_manager.get_latest_klines(&cache_key.0, &cache_key.1, KLINE_CACHE_LIMIT).await?;

            if !klines_from_db.is_empty() {
                info!("ğŸ’§ [CACHE] Hydrated memory with {} klines from DB for {:?}. Re-evaluating.", klines_from_db.len(), cache_key);
                self.mem_cache.insert(cache_key.clone(), klines_from_db);
                continue; // å›åˆ°å¾ªç¯å¼€å§‹ï¼Œä¸‹ä¸€æ¬¡è¿­ä»£å°†å‘½ä¸­å†…å­˜ç¼“å­˜å¹¶æ£€æŸ¥å…¶æ˜¯å¦è¿‡æ—¶
            }

            // --- æ­¥éª¤ 3: æ•°æ®åº“ä¹Ÿæœªå‘½ä¸­ï¼Œä»ç½‘ç»œè·å–å…¨é‡æ•°æ® ---
            info!("-> [CACHE] DB cache miss for {:?}. Performing full network fetch.", cache_key);
            let task = DownloadTask {
                symbol: symbol.to_string(),
                interval: interval.to_string(),
                start_time: None,
                end_time: None,
                limit: KLINE_FULL_FETCH_LIMIT,
            };
            let fresh_klines = self.api_client.download_continuous_klines(&task).await?;

            if !fresh_klines.is_empty() {
                // å¼‚æ­¥ä¿å­˜åˆ°æ•°æ®åº“
                let db_manager = self.db_manager.clone();
                let klines_to_save = fresh_klines.clone();
                let key_clone = cache_key.clone();
                task::spawn(async move {
                    info!("ğŸ’¾ [ASYNC] Persisting {} full-fetch klines to DB for {:?}", klines_to_save.len(), key_clone);
                    if let Err(e) = db_manager.save_klines(&key_clone.0, &key_clone.1, &klines_to_save).await {
                        warn!("Failed to save full-fetch klines to DB: {}", e);
                    }
                });

                // å­˜å…¥å†…å­˜ç¼“å­˜
                self.mem_cache.insert(cache_key, fresh_klines.clone());
            }

            return Ok(fresh_klines);
        }
    }
}
å…¶ä»–æ–‡ä»¶ï¼ˆä¿æŒä¸å˜ï¼‰

ä¸ºäº†æ–¹ä¾¿ä½ ç›´æ¥å¤åˆ¶ç²˜è´´ï¼Œæˆ‘å°†æä¾›æ‰€æœ‰æ–‡ä»¶çš„æœ€ç»ˆç‰ˆæœ¬ï¼Œå³ä½¿å®ƒä»¬å¤§éƒ¨åˆ†æ²¡æœ‰å˜åŒ–ã€‚

code
Toml
download
content_copy
expand_less
// Cargo.toml
# cargo.toml
#ç‰ˆæœ¬å·ä¸è¦éšä¾¿æ”¹ï¼Œå› ä¸ºæ¯ä¸€ä¸ªéƒ½æ˜¯æˆ‘æ‰‹åŠ¨æŸ¥è¯¢è¿‡ï¼Œæ˜¯æœ€æ–°ç‰ˆæœ¬
[package]
name = "BinanceLocalServer"
version = "0.1.0"
edition = "2021"

[dependencies]
# --- Web æ¡†æ¶ä¸æœåŠ¡ ---
axum = "0.8.6"
tokio = { version = "1.48.0", features = ["full"] }
tower-http = { version = "0.6.6", features = ["cors"] }
tower = "0.5.2" # tower::Layer å’Œ tower::Service trait
futures = "0.3.31" # ç”¨äºè‡ªå®šä¹‰ä¸­é—´ä»¶ä¸­çš„ BoxFuture

# --- æ—¥å¿— ---
tracing = "0.1.41"
tracing-subscriber = { version = "0.3.20", features = ["env-filter", "fmt"] }

# --- åºåˆ—åŒ– / ååºåˆ—åŒ– ---
serde = { version = "1.0.228", features = ["derive"] }
serde_json = "1.0.145"

# --- å¼‚æ­¥ HTTP å®¢æˆ·ç«¯ ---
reqwest = { version = "0.12.24", features = ["json"] }

# --- å†…å­˜ç¼“å­˜ ---
dashmap = "6.1.0"

# --- æ•°æ®åº“ ---
tokio-rusqlite = "0.5.0"
rusqlite = { version = "0.31.0", features = ["bundled", "chrono"] }

# --- é”™è¯¯å¤„ç†ä¸å·¥å…·åº“ ---
thiserror = "2.0.17"
chrono = "0.4.42"
once_cell = "1.21.3"
code
Rust
download
content_copy
expand_less
// src/api_client.rs
use crate::error::{AppError, Result};
use crate::models::{DownloadTask, Kline};
use reqwest::header::{HeaderMap, HeaderValue, USER_AGENT};
use reqwest::Client;
use serde_json::Value;
use std::sync::Arc;
use std::time::Duration;
use std::time::Instant;
use tokio::time::sleep;
use tracing::{info, trace, warn, instrument}; // æ·»åŠ  instrument

// Constants
const MOKEX_BASE_URL: &str = "https://www.mokexapp.info";
const BINANCE_BASE_URL: &str = "https://fapi.binance.com";
const PROXY_URL: &str = "http://127.0.0.1:1080";
const FALLBACK_RETRIES: u32 = 10;
const RETRY_DELAY_MS: u64 = 10;

#[derive(Clone)]
pub struct ApiClient {
    mokex_client: Arc<Client>,
    binance_client: Arc<Client>,
}

impl ApiClient {
    pub fn new() -> Result<Self> {
        let mut mokex_headers = HeaderMap::new();
        mokex_headers.insert(
            USER_AGENT,
            HeaderValue::from_static("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Binance/1.54.19 Chrome/128.0.6613.186 Electron/32.3.0 Safari/537.36 (electron 1.54.19)")
        );
        mokex_headers.insert(
            "mclient-x-tag",
            HeaderValue::from_static("tfph2mpTPAuwxbiMHoQc"),
        );

        let mokex_client = Client::builder()
            .default_headers(mokex_headers)
            .timeout(Duration::from_secs(10)) // æ·»åŠ è¶…æ—¶ï¼Œé˜²æ­¢ç½‘ç»œå±‚æ°¸ä¹…å¡æ­»
            .build()
            .map_err(AppError::Reqwest)?;

        let proxy = reqwest::Proxy::all(PROXY_URL).map_err(AppError::Reqwest)?;
        let binance_client = Client::builder()
            .proxy(proxy)
            .timeout(Duration::from_secs(10)) // æ·»åŠ è¶…æ—¶
            .build()
            .map_err(AppError::Reqwest)?;

        Ok(Self {
            mokex_client: Arc::new(mokex_client),
            binance_client: Arc::new(binance_client),
        })
    }

    /// ä½¿ç”¨ fallback å’Œ retry é€»è¾‘ä¸‹è½½Kçº¿
    #[instrument(skip(self))]
    pub async fn download_continuous_klines(&self, task: &DownloadTask) -> Result<Vec<Kline>> {
        let start_time = Instant::now();

        // 1. é¦–å…ˆå°è¯• Mokex
        // trace!("Attempting primary source (Mokex) for task: {:?}", task);
        info!("ğŸŒ [DEBUG_API] å°è¯•ä¸»çº¿è·¯ (Mokex): {}/{}", task.symbol, task.interval);
        let mokex_result = self
            .fetch_klines(&self.mokex_client, MOKEX_BASE_URL, task)
            .await;

        match mokex_result {
            Ok(klines) => {
                info!(
                    "âœ… [DEBUG_API] Mokex æˆåŠŸ ({:.2?}). Task: {}/{}",
                    start_time.elapsed(),
                    task.symbol, task.interval
                );
                Ok(klines)
            }
            Err(e) => {
                warn!(
                    "âš ï¸ [DEBUG_API] Mokex å¤±è´¥: {}. åˆ‡æ¢åˆ° Binance é‡è¯•.",
                    e
                );
                
                let mut last_error: Option<AppError> = None;

                for attempt in 1..=FALLBACK_RETRIES {
                    info!(
                        "ğŸ”„ [DEBUG_API] Binance é‡è¯• {}/{}: {}/{}",
                        attempt,
                        FALLBACK_RETRIES,
                        task.symbol, task.interval
                    );

                    match self
                        .fetch_klines(&self.binance_client, BINANCE_BASE_URL, task)
                        .await
                    {
                        Ok(klines) => {
                            info!(
                                "âœ… [DEBUG_API] Binance æˆåŠŸ (ç¬¬ {} æ¬¡) in {:.2?}.",
                                attempt,
                                start_time.elapsed()
                            );
                            return Ok(klines);
                        }
                        Err(retry_err) => {
                            warn!(
                                "âŒ [DEBUG_API] Binance å°è¯• {} å¤±è´¥: {}",
                                attempt, retry_err
                            );
                            last_error = Some(retry_err);

                            if attempt < FALLBACK_RETRIES {
                                sleep(Duration::from_millis(RETRY_DELAY_MS)).await;
                            }
                        }
                    }
                }

                warn!(
                    "â›” [DEBUG_API] æ‰€æœ‰é‡è¯•å‡å¤±è´¥: {}/{}",
                     task.symbol, task.interval
                );
                Err(last_error.unwrap())
            }
        }
    }

    /// å®é™…æ‰§è¡ŒAPIè¯·æ±‚çš„ç§æœ‰æ–¹æ³•
    async fn fetch_klines(
        &self,
        client: &Client,
        base_url: &str,
        task: &DownloadTask,
    ) -> Result<Vec<Kline>> {
        let mut url_params = format!(
            "pair={}&contractType=PERPETUAL&interval={}&limit={}",
            task.symbol, task.interval, task.limit
        );
        if let Some(start_time) = task.start_time {
            url_params.push_str(&format!("&startTime={}", start_time));
        }
        if let Some(end_time) = task.end_time {
            url_params.push_str(&format!("&endTime={}", end_time));
        }

        let url = format!("{}/fapi/v1/continuousKlines?{}", base_url, url_params);
        // trace!("Downloading K-lines from URL: {}", url);

        info!("ğŸ“¡ [DEBUG_API_REQ] å‘é€ HTTP GET: {}...", &url[..min(url.len(), 60)]); // åªæ‰“å° URL å‰é¢éƒ¨åˆ†é¿å…å¤ªé•¿
        let response = client.get(&url).send().await?.error_for_status()?;
        info!("ğŸ“© [DEBUG_API_REQ] æ”¶åˆ° HTTP å“åº”å¤´ (å‡†å¤‡è¯»å– body)");
        let response_text = response.text().await?;
        info!("ğŸ“¦ [DEBUG_API_REQ] è¯»å– body å®Œæˆ ({} bytes)", response_text.len());

        let raw_klines: Vec<Vec<Value>> = serde_json::from_str(&response_text)?;

        if raw_klines.is_empty() {
            trace!("API returned empty result for task: {:?}", task);
            return Ok(vec![]);
        }

        let klines = raw_klines
            .iter()
            .filter_map(|raw_kline_vec| Kline::from_raw_kline(raw_kline_vec))
            .collect::<Vec<Kline>>();

        Ok(klines)
    }
}

// è¾…åŠ©å‡½æ•°ï¼šç”¨äºæˆªæ–­æ—¥å¿—ä¸­çš„ URL
fn min(a: usize, b: usize) -> usize {
    if a < b { a } else { b }
}
code
Rust
download
content_copy
expand_less
// src/db_manager.rs
use crate::error::{AppError, Result};
use crate::models::Kline;
use tokio_rusqlite::{params, Connection};
use tracing::info;

const DB_PATH: &str = "kline_cache.db";

#[derive(Clone)]
pub struct DbManager {
    conn: Connection,
}

impl DbManager {
    pub async fn new() -> Result<Self> {
        let conn = Connection::open(DB_PATH).await?;
        info!("ğŸ—„ï¸ Database connection opened at '{}'", DB_PATH);
        
        // å¼€å¯ WAL æ¨¡å¼ä»¥æé«˜å¹¶å‘æ€§èƒ½
        conn.call(|conn| {
            conn.pragma_update(None, "journal_mode", "WAL")?;
            conn.pragma_update(None, "synchronous", "NORMAL")?;
            Ok::<(), rusqlite::Error>(())
        }).await?;
        info!("ğŸ—„ï¸ WAL mode enabled for SQLite.");

        // åˆ›å»ºè¡¨
        conn.call(|conn| {
            conn.execute(
                "CREATE TABLE IF NOT EXISTS klines (
                    symbol              TEXT NOT NULL,
                    interval            TEXT NOT NULL,
                    open_time           INTEGER NOT NULL,
                    open                TEXT NOT NULL,
                    high                TEXT NOT NULL,
                    low                 TEXT NOT NULL,
                    close               TEXT NOT NULL,
                    volume              TEXT NOT NULL,
                    close_time          INTEGER NOT NULL,
                    quote_asset_volume  TEXT NOT NULL,
                    number_of_trades    INTEGER NOT NULL,
                    taker_buy_base_asset_volume TEXT NOT NULL,
                    taker_buy_quote_asset_volume TEXT NOT NULL,
                    ignore              TEXT NOT NULL,
                    PRIMARY KEY (symbol, interval, open_time)
                )",
                [],
            )?;
            Ok::<(), rusqlite::Error>(())
        }).await?;
        info!("ğŸ—„ï¸ 'klines' table initialized.");

        Ok(Self { conn })
    }

    /// ä¿å­˜ä¸€æ‰¹Kçº¿æ•°æ®åˆ°æ•°æ®åº“ï¼Œå¦‚æœå·²å­˜åœ¨åˆ™æ›¿æ¢
    pub async fn save_klines(&self, symbol: &str, interval: &str, klines: &[Kline]) -> Result<()> {
        if klines.is_empty() {
            return Ok(());
        }

        let symbol = symbol.to_string();
        let interval = interval.to_string();

        self.conn
            .call(move |conn| {
                let tx = conn.transaction()?;
                {
                    // ä½¿ç”¨é¢„ç¼–è¯‘è¯­å¥æé«˜æ€§èƒ½
                    let mut stmt = tx.prepare_cached(
                        "INSERT OR REPLACE INTO klines (
                            symbol, interval, open_time, open, high, low, close, volume, close_time,
                            quote_asset_volume, number_of_trades, taker_buy_base_asset_volume,
                            taker_buy_quote_asset_volume, ignore
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                    )?;

                    for kline in klines {
                        stmt.execute(params![
                            symbol,
                            interval,
                            kline.open_time,
                            kline.open,
                            kline.high,
                            kline.low,
                            kline.close,
                            kline.volume,
                            kline.close_time,
                            kline.quote_asset_volume,
                            kline.number_of_trades,
                            kline.taker_buy_base_asset_volume,
                            kline.taker_buy_quote_asset_volume,
                            kline.ignore,
                        ])?;
                    }
                }
                tx.commit()?;
                Ok(())
            })
            .await?;
        Ok(())
    }

    /// ä»æ•°æ®åº“è·å–æœ€æ–°çš„Kçº¿æ•°æ®
    pub async fn get_latest_klines(
        &self,
        symbol: &str,
        interval: &str,
        limit: usize,
    ) -> Result<Vec<Kline>> {
        let symbol = symbol.to_string();
        let interval = interval.to_string();

        let klines = self.conn.call(move |conn| {
            let mut stmt = conn.prepare_cached(
                "SELECT * FROM klines WHERE symbol = ?1 AND interval = ?2 ORDER BY open_time DESC LIMIT ?3",
            )?;
            let mut rows = stmt.query(params![symbol, interval, limit])?;
            let mut result_klines = Vec::new();

            while let Some(row) = rows.next()? {
                 result_klines.push(Kline {
                    open_time: row.get(2)?,
                    open: row.get(3)?,
                    high: row.get(4)?,
                    low: row.get(5)?,
                    close: row.get(6)?,
                    volume: row.get(7)?,
                    close_time: row.get(8)?,
                    quote_asset_volume: row.get(9)?,
                    number_of_trades: row.get(10)?,
                    taker_buy_base_asset_volume: row.get(11)?,
                    taker_buy_quote_asset_volume: row.get(12)?,
                    ignore: row.get(13)?,
                });
            }
            // å› ä¸ºæˆ‘ä»¬æ˜¯ DESC æŸ¥è¯¢ï¼Œæ‰€ä»¥éœ€è¦åè½¬å›æ¥
            result_klines.reverse();
            Ok(result_klines)
        }).await?;
        Ok(klines)
    }
    
    /// è·å–ç‰¹å®šäº¤æ˜“å¯¹å’Œå‘¨æœŸçš„æœ€æ–°Kçº¿å¼€ç›˜æ—¶é—´
    pub async fn get_last_open_time(&self, symbol: &str, interval: &str) -> Result<Option<i64>> {
        let symbol = symbol.to_string();
        let interval = interval.to_string();

        let result = self.conn.call(move |conn| {
            let mut stmt = conn.prepare_cached(
                "SELECT MAX(open_time) FROM klines WHERE symbol = ?1 AND interval = ?2",
            )?;
            let last_time: Option<i64> = stmt.query_row(params![symbol, interval], |row| row.get(0))?;
            Ok(last_time)
        }).await?;

        Ok(result)
    }
}
code
Rust
download
content_copy
expand_less
// src/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Reqwest HTTP error: {0}")]
    Reqwest(#[from] reqwest::Error),

    #[error("Serde JSON error: {0}")]
    SerdeJson(#[from] serde_json::Error),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Join error: {0}")]
    Join(#[from] tokio::task::JoinError),

    #[error("Database error: {0}")]
    Database(#[from] tokio_rusqlite::Error),

    #[error("API logic error: {0}")]
    ApiLogic(String),
}

pub type Result<T> = std::result::Result<T, AppError>;

// ä¸ºaxumæä¾›é”™è¯¯è½¬æ¢
impl axum::response::IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, error_message) = match self {
            // å½“æ˜¯ API é€»è¾‘é”™è¯¯ (å¦‚æ— æ•ˆå‚æ•°) æ—¶ï¼Œè¿”å› 400 Bad Request
            AppError::ApiLogic(msg) => (axum::http::StatusCode::BAD_REQUEST, msg),
            
            // ä¸Šæ¸¸ API é”™è¯¯ï¼Œè¿”å› 502 Bad Gateway
            AppError::Reqwest(e) => (
                axum::http::StatusCode::BAD_GATEWAY,
                format!("Upstream API error: {}", e),
            ),

            // å…¶ä»–æ‰€æœ‰é”™è¯¯è§†ä¸ºæœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¿”å› 500
            _ => (
                axum::http::StatusCode::INTERNAL_SERVER_ERROR,
                self.to_string(),
            ),
        };
        let body = axum::Json(serde_json::json!({ "error": error_message }));
        (status, body).into_response()
    }
}
code
Rust
download
content_copy
expand_less
// src/main.rs
mod api_client;
mod cache_manager;
mod db_manager; // <-- æ–°å¢æ¨¡å—
mod error;
mod models;
mod transformer;
mod utils;
mod web_server;

use crate::api_client::ApiClient;
use crate::cache_manager::CacheManager;
use crate::db_manager::DbManager; // <-- æ–°å¢
use axum::{
    extract::Request,
    http::header,
    middleware::{self, Next},
    response::Response,
    routing::get,
    Router,
};
use futures::future::BoxFuture;
use std::sync::Arc;
use tokio::net::TcpListener;
use tower::{Layer, Service};
use tower_http::cors::{Any, CorsLayer};
use tracing::info;

/// ä¸€ä¸ªç®€å•çš„ä¸­é—´ä»¶ï¼Œç”¨äºæ‰“å°æ¯ä¸ªæ”¶åˆ°çš„è¯·æ±‚URL
async fn log_requests(req: Request, next: Next) -> Response {
    let method = req.method().clone();
    let uri = req.uri().clone();
    info!("â¬…ï¸ Received request: {} {}", method, uri);
    next.run(req).await
}

// --- ä¸­é—´ä»¶ç”¨äºæ·»åŠ  PNA å¤´éƒ¨ (ä¿æŒä¸å˜) ---
#[derive(Clone)]
struct PrivateNetworkAccessLayer;

impl<S> Layer<S> for PrivateNetworkAccessLayer {
    type Service = PrivateNetworkAccessService<S>;
    fn layer(&self, inner: S) -> Self::Service {
        PrivateNetworkAccessService { inner }
    }
}
#[derive(Clone)]
struct PrivateNetworkAccessService<S> {
    inner: S,
}
impl<S, ReqBody> Service<axum::http::Request<ReqBody>> for PrivateNetworkAccessService<S>
where
    S: Service<axum::http::Request<ReqBody>, Response = Response> + Send + 'static,
    S::Future: Send + 'static,
    ReqBody: Send + 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = BoxFuture<'static, std::result::Result<Self::Response, Self::Error>>;
    fn poll_ready(
        &mut self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<std::result::Result<(), Self::Error>> {
        self.inner.poll_ready(cx)
    }
    fn call(&mut self, req: axum::http::Request<ReqBody>) -> Self::Future {
        let future = self.inner.call(req);
        Box::pin(async move {
            let mut res: Response = future.await?;
            res.headers_mut().insert(
                "Access-Control-Allow-Private-Network",
                "true".parse().unwrap(),
            );
            Ok(res)
        })
    }
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    info!("Starting K-line API proxy service...");

    // 1. åˆå§‹åŒ– ApiClient
    let api_client = Arc::new(ApiClient::new().expect("Failed to create API clients"));
    info!("API clients initialized.");

    // 2. åˆå§‹åŒ– DbManager
    let db_manager = Arc::new(DbManager::new().await.expect("Failed to initialize DbManager"));
    info!("Database manager initialized.");

    // 3. åˆå§‹åŒ– CacheManagerï¼Œå¹¶å°† ApiClient å’Œ DbManager æ³¨å…¥
    let cache_manager = Arc::new(CacheManager::new(api_client, db_manager));
    info!("CacheManager with multi-level cache initialized.");

    let cors = CorsLayer::new()
        .allow_origin(Any)
        .allow_methods(Any)
        .allow_headers([
            header::CONTENT_TYPE,
            "Access-Control-Request-Private-Network".parse().unwrap(),
        ]);
    info!("CORS middleware configured for PNA.");

    let app = Router::new()
        // ã€è·¯ç”±è¯­æ³•ä¿®æ­£ã€‘ä½¿ç”¨ {param} æ›¿ä»£ :param
        .route(
            "/download/{symbol}/{interval}",
            get(web_server::proxy_kline_handler),
        )
        .route(
            "/download-binary/{symbol}/{interval}",
            get(web_server::binary_kline_handler),
        )
        // æµ‹è¯•æ¥å£ (æ— å‚æ•°ï¼Œä¸å—å½±å“)
        .route("/test-download", get(web_server::test_download_handler))
        .route(
            "/test-download-binary",
            get(web_server::test_download_binary_handler),
        )
        .with_state(cache_manager)
        .layer(middleware::from_fn(log_requests))
        .layer(cors)
        .layer(PrivateNetworkAccessLayer);

    let addr = "127.0.0.1:3000";
    let listener = TcpListener::bind(addr).await.expect("Failed to bind");
    info!("ğŸš€ Server listening on http://{}", addr);
    info!("ğŸŒ Now accessible from public websites due to PNA headers.");

    info!("---");
    info!("ğŸ‘‰ JSON Test endpoint:   curl http://{}/test-download", addr);
    info!(
        "ğŸ‘‰ Binary Test endpoint: curl http://{}/test-download-binary -o test.bin",
        addr
    );
    info!("---");
    info!(
        "ğŸ‘‰ General JSON endpoint:   curl \"http://{}/download/ETHUSDT/5m?limit=10\"",
        addr
    );
    info!(
        "ğŸ‘‰ General Binary endpoint: curl \"http://{}/download-binary/BTCUSDT/5m?limit=10\" -o klines.bin",
        addr
    );
    info!("---");

    axum::serve(listener, app).await.unwrap();
}

å…¶ä»–å¦‚ models.rs, transformer.rs, utils.rs, web_server.rs ç­‰æ–‡ä»¶å®Œå…¨ä¸éœ€è¦ä¿®æ”¹ã€‚æˆ‘å°±ä¸ä¸€ä¸€åˆ—å‡ºäº†ï¼Œä½ å¯ä»¥ç»§ç»­ä½¿ç”¨ä¹‹å‰çš„ç‰ˆæœ¬ã€‚

ç°åœ¨ï¼Œè¿™ä¸ªæ¶æ„å®Œç¾åœ°æ»¡è¶³äº†ä½ â€œå°†ç¡¬ç›˜ä½œä¸ºå†…å­˜é‡å¯å¤‡ä»½â€çš„éœ€æ±‚ï¼Œæ—¢å¥å£®åˆé«˜æ•ˆã€‚