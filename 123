è¿™æ˜¯ä¸€ä»½ä¿®æ”¹`src\kl_server\kl_client.ts`çš„æ–¹æ¡ˆï¼Œä½ é¦–å…ˆä»”ç»†ï¼Œè°¨æ…çš„é˜…è¯»è¿™ä»½æ–¹æ¡ˆï¼Œç„¶åå»é˜…è¯»ç›¸å…³ä»£ç ï¼Œç„¶åæ¥è¯„ä»·ä¸‹è¿™ä»½æ–¹æ¡ˆçš„å¯è¡Œæ€§ï¼Œä½ éœ€è¦ä½œä¸ºä¸€ä¸ªä»”ç»†ï¼Œè°¨æ…ï¼Œæœ€ç»ˆè´Ÿè´£æ‰€æœ‰ç»†èŠ‚çš„ä¼™ä¼´ï¼Œæ¥å®¡è§†æˆ‘çš„æ–¹æ¡ˆï¼Œåˆ—å‡ºéœ€è¦æˆ‘è¡¥å……çš„ç»†èŠ‚ï¼Œæœ€ç»ˆç­‰æˆ‘ç¡®è®¤ï¼Œè¾“å‡ºå®Œæ•´çš„ä¿®æ”¹æ–‡æ¡£,å¦‚æœä½ è§‰å¾—æ–‡æ¡£å·²ç»è¶³å¤Ÿè¯¦ç»†äº†ï¼Œé‚£æˆ‘ä»¬æ¥ç»™å‡ºéœ€è¦ä¿®æ”¹çš„æ–‡ä»¶æ¸…å•ï¼Œä»¥åŠè¾“å‡ºæ¯ä¸ªæ–‡ä»¶çš„å®Œæ•´ç‰ˆæœ¬ï¼Œæ³¨æ„ï¼Œéœ€è¦æ·»åŠ ä¸Šå¤§é‡çš„ï¼Œä¸°å¯Œçš„æ—¥å¿—ï¼Œå› ä¸ºä¸€å®šä¼šæœ‰ä¸€ä¸ªå¾ˆé•¿çš„è°ƒè¯•æœŸ
æˆ‘çš„è¡¥å……
1 å°½é‡æ–°å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œå¦‚æœä¸ä¿®æ”¹kl_client.tsæ˜¯æœ€å¥½çš„ï¼Œä»ç›®å‰çœ‹ï¼Œæˆ‘è§‰å¾—æŠŠaddSymbolKlineçš„æ–¹æ³•æŒªå‡ºæ¥åˆ°æ–°çš„æ–‡ä»¶å°±å¯ä»¥äº†ï¼Œè¿™æ ·å¯¹äºåŸé¡¹ç›®çš„ä¿®æ”¹æ˜¯æœ€å°çš„ï¼Œé¿å…å‡ºç°æœªçŸ¥çš„é—®é¢˜
2 kline_worker.ts çš„ loadHistoricalDataForSymbol å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬è¯·æ±‚çš„ URL æ˜¯ http://127.0.0.1:3000/klines?symbol=...&limit=1500ã€‚æ³¨æ„æ¯æ¬¡æœ€å¤šåªèƒ½è¯·æ±‚1500æ ¹
3 kline_worker.ts ä¸­çš„ ALL_K å®ä¾‹ï¼šWorker å†…éƒ¨çš„ klineDB å®ä¾‹æ˜¯ new ALL_K()ã€‚åœ¨ BA_1.ts çš„å®ç°ä¸­ï¼ŒALL_K åœ¨ Node.js ç¯å¢ƒï¼ˆæœåŠ¡å™¨ç«¯ï¼‰éœ€è¦è°ƒç”¨ init() æ¥é¢„åˆ†é…ä¸€ä¸ªå·¨å¤§çš„ ArrayBufferã€‚ä½†åœ¨æµè§ˆå™¨ç¯å¢ƒï¼ˆWorkerï¼‰ä¸­ï¼Œå®ƒçš„ client_map æ˜¯åŠ¨æ€å¢é•¿çš„ã€‚
4 `å¸å®‰æ–‡æ¡£`ä¸­æœ‰è¯¦ç»†çš„å¦‚ä½•è®¢é˜…websocketçš„æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç 
5 
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
å¥½çš„ï¼Œéå¸¸æ„Ÿè°¢ä½ çš„æ¾„æ¸…å’Œå†³ç­–ã€‚æˆ‘ä»¬ç°åœ¨å·²ç»æ‰«æ¸…äº†æ‰€æœ‰éšœç¢ï¼Œå¯ä»¥è¾“å‡ºä¸€ä»½å®Œæ•´ã€ç²¾ç¡®ã€å¯ç›´æ¥æ‰§è¡Œçš„æœ€ç»ˆæ–¹æ¡ˆäº†ã€‚

ä½ æå‡ºçš„æŒ‘æˆ˜è®©æˆ‘é‡æ–°å®¡è§†äº† CycleArray çš„è®¾è®¡ï¼Œå¹¶æ„æ€äº†ä¸€ä¸ªæ›´ä¼˜çš„æ–¹æ¡ˆï¼Œå³æŠŠå…ƒæ•°æ®ï¼ˆlength, head, tailï¼‰ç›´æ¥ç¼–ç åˆ° ArrayBuffer çš„å¤´éƒ¨ã€‚è¿™ä½¿å¾—æ•°æ®æœ¬èº«å°±æ˜¯è‡ªåŒ…å«çš„ï¼Œä¼ è¾“å’Œæ¢å¤éƒ½å˜å¾—æå…¶ç®€å•å’Œå¥å£®ï¼Œæˆ‘éå¸¸å–œæ¬¢è¿™ä¸ªç»“æœã€‚

ä»¥ä¸‹æ˜¯èåˆäº†æˆ‘ä»¬æ‰€æœ‰è®¨è®ºç»†èŠ‚çš„ V7 - æœ€ç»ˆå®æ–½æ–‡æ¡£ã€‚å®ƒåŒ…å«äº†å®Œæ•´çš„æ–‡å­—æè¿°å’Œæ‰€æœ‰éœ€è¦ä¿®æ”¹/æ–°å¢çš„ä»£ç ï¼Œæœªå˜åŠ¨çš„éƒ¨åˆ†ä¹Ÿå®Œæ•´ä¿ç•™ï¼Œç¡®ä¿äº†æ–‡æ¡£çš„æ•´ä½“æ€§ã€‚

Kçº¿æ•°æ®æŒä¹…åŒ–ä¸å¤šé¡µé¢åè°ƒç¼“å­˜æ–¹æ¡ˆ (V7 - æœ€ç»ˆå®æ–½æ–‡æ¡£)
1. ç›®æ ‡ (Objective)

æ„å»ºä¸€ä¸ªé«˜æ€§èƒ½ã€æ”¯æŒå¤šé¡µé¢ååŒå·¥ä½œçš„Kçº¿æ•°æ®ç¼“å­˜ç³»ç»Ÿã€‚æ—¨åœ¨å®ç°ä»¥ä¸‹ç›®æ ‡ï¼š

æè‡´æ€§èƒ½ï¼š é¦–æ¬¡è¯·æ±‚åï¼ŒKçº¿æ•°æ®å¸¸é©»å†…å­˜ï¼Œåç»­è®¿é—®æ— å»¶è¿Ÿã€‚UIçº¿ç¨‹åªè´Ÿè´£æ¸²æŸ“ã€‚

ç¦»çº¿èƒ½åŠ›ï¼š å…³é—­æµè§ˆå™¨åæ•°æ®ä¸ä¸¢å¤±ï¼Œé€šè¿‡ IndexedDB å®ç°ç§’å¼€å†å²Kçº¿ã€‚

èµ„æºé«˜æ•ˆï¼š åœ¨å¤šä¸ªæ ‡ç­¾é¡µä¸­ï¼Œåªç»´æŒä¸€ä¸ªå…±äº«çš„ WebSocket è¿æ¥æ¥è®¢é˜…æ‰€æœ‰æ•°æ®æµï¼Œæœ€å¤§é™åº¦å‡å°‘ç½‘ç»œå¼€é”€ã€‚

å¥å£®æ€§ï¼š é€šè¿‡åå°äº‹åŠ¡å’Œå¾ªç¯æ•°ç»„ä¿è¯æ•°æ®ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ï¼Œè®¾è®¡ç®€æ´ï¼Œæ˜“äºç»´æŠ¤ã€‚

2. æ ¸å¿ƒæ¶æ„ï¼šä¸‰çº§ç¼“å­˜ + SharedWorker

é‡‡ç”¨ SharedWorker ä½œä¸ºæ•´ä¸ªç¼“å­˜ç³»ç»Ÿçš„ä¸­å¿ƒæ¢çº½ã€‚å®ƒåœ¨æµè§ˆå™¨åå°ä½œä¸ºå•ä¾‹è¿è¡Œï¼Œè¢«æ‰€æœ‰åŒæºé¡µé¢å…±äº«ï¼Œæ˜¯å”¯ä¸€çš„æ•°æ®æƒå¨æºã€‚

æ•°æ®æµå‘:
UIé¡µé¢ (Client) <=> SharedWorker (ä¸­å¿ƒæ¢çº½) <=> [L1: å†…å­˜ -> L2: IndexedDB -> L3: ç½‘ç»œ]

L1 - å†…å­˜ç¼“å­˜ (Workerå†…éƒ¨): SharedWorker å†…éƒ¨ç»´æŠ¤ä¸€ä»½ç”± ALL_K ç±»ç®¡ç†çš„äºŒè¿›åˆ¶Kçº¿æ•°æ®ï¼Œä½œä¸ºæœ€é«˜é€Ÿçš„æ•°æ®æºã€‚

L2 - IndexedDB (æŒä¹…åŒ–): SharedWorker ç‹¬å å¯¹ IndexedDB çš„æ‰€æœ‰è¯»å†™æ“ä½œï¼Œä½œä¸ºå†·å¯åŠ¨çš„æ•°æ®æºå’Œæ•°æ®çš„æœ€ç»ˆå½’å®¿ã€‚

L3 - ç½‘ç»œè¯·æ±‚ & WebSocket: æ‰€æœ‰è·å–å†å²Kçº¿çš„ HTTP è¯·æ±‚å’Œå®æ—¶çš„ WebSocket è®¢é˜…éƒ½ç”± SharedWorker ä¸»åŠ¨å‘èµ·å’Œç®¡ç†ã€‚

3. ç»„ä»¶èŒè´£åˆ’åˆ†

kl_client.ts (UIå±‚ - é€šä¿¡ä»£ç†)

èŒè´£:

è¿æ¥åˆ° SharedWorkerã€‚å¦‚æœè¿æ¥å¤±è´¥ï¼Œåˆ™ç›´æ¥æŠ¥é”™ï¼Œä¸æä¾›é™çº§æ–¹æ¡ˆã€‚

å°†UIçš„æ•°æ®è¯·æ±‚ï¼ˆå¦‚ addSymbolKlineï¼‰å°è£…æˆæ¶ˆæ¯ï¼Œæ˜ç¡®åœ°å‘é€ç»™ SharedWorkerã€‚

ç›‘å¬ SharedWorker å‘å›çš„æ•°æ®ï¼š

æ¥æ”¶åˆå§‹åŒ–çš„ã€è‡ªåŒ…å«å…ƒæ•°æ®çš„äºŒè¿›åˆ¶ ArrayBuffer æ•°æ®ï¼Œé€šè¿‡ setBackingBuffer æ–¹æ³•åœ¨è‡ªèº«å†…å­˜ä¸­é«˜æ•ˆé‡å»º K_Line å®ä¾‹å‰¯æœ¬ã€‚

æ¥æ”¶å®æ—¶çš„JSONæ ¼å¼ (ONE_K) æ›´æ–°ï¼Œå¹¶è°ƒç”¨æœ¬åœ° K_Line å®ä¾‹çš„ .push() / .updateLast() æ–¹æ³•ã€‚

è§¦å‘UIåˆ·æ–° (onDataUpdated)ã€‚

ä¸å†è´Ÿè´£: ä»»ä½• IndexedDB æ“ä½œã€WebSocket è¿æ¥ã€HTTP è¯·æ±‚ã€ç¼“å­˜å†³ç­–ã€‚

public/kline_worker.ts (åå° - æ•°æ®å¤§è„‘)

èŒè´£:

ç‹¬å  IndexedDB: ä½¿ç”¨ kline_db_manager æ¨¡å—å®‰å…¨åœ°è¯»å†™æ•°æ®åº“ã€‚

ç»Ÿä¸€ç½‘ç»œç®¡ç†:

ç»´æŠ¤ä¸€ä¸ªå•ä¸€çš„ã€å…±äº«çš„ WebSocket è¿æ¥ (wss://fstream.mokexapp.info/ws)ï¼Œé€šè¿‡ JSON-RPC æ¶ˆæ¯åŠ¨æ€æ‰¹é‡è®¢é˜…/é€€è®¢æ‰€æœ‰éœ€è¦çš„Kçº¿æµã€‚

å†…ç½®ä¼˜é›…çš„æ–­çº¿é‡è¿å’Œè‡ªåŠ¨é‡æ–°è®¢é˜…æœºåˆ¶ã€‚è®¢é˜…å¤±è´¥åä¼šæ¯3ç§’è‡ªåŠ¨é‡è¯•ã€‚

æ ¹æ®å®¢æˆ·ç«¯æ¶ˆæ¯ï¼Œä¸»åŠ¨å‘æœ¬åœ°Rustä¸­è½¬æœåŠ¡ (http://127.0.0.1:3000) å‘èµ· fetch è¯·æ±‚è·å–å†å²Kçº¿ã€‚Workerå±‚é¢å‡å®šHTTPè¯·æ±‚æ€»æ˜¯æˆåŠŸï¼Œç”±Ruståç«¯è´Ÿè´£é‡è¯•å’Œå®¹é”™ã€‚

å®ç°å®Œæ•´ç¼“å­˜é€»è¾‘: æ‰§è¡Œâ€œå†…å­˜ -> DB -> ç½‘ç»œâ€çš„æ£€æŸ¥ã€å†³ç­–ã€æ•°æ®è·å–å’Œåˆå¹¶ã€‚

å¹¿æ’­æ•°æ®: å°†è·å–åˆ°çš„å®Œæ•´äºŒè¿›åˆ¶æ•°æ® (ArrayBuffer) æˆ–å®æ—¶JSONæ›´æ–°å¹¿æ’­ç»™æ‰€æœ‰è¿æ¥çš„ UI é¡µé¢ã€‚

åå°åŒæ­¥: æ¯30ç§’å°†å†…å­˜ä¸­çš„â€œè„æ•°æ®â€å›å†™åˆ° IndexedDBã€‚

public/kline_db_manager.ts (åå° - æ•°æ®è®¿é—®å±‚)

èŒè´£:

å°è£…æ‰€æœ‰ IndexedDB çš„ CRUD æ“ä½œã€‚

æ•°æ®åº“ç»“æ„ï¼šé‡‡ç”¨åä¸º kline_cache_db çš„æ•°æ®åº“ï¼Œå†…éƒ¨åŒ…å«ä¸€ä¸ªåä¸º klines çš„å¯¹è±¡å­˜å‚¨ã€‚è¯¥å­˜å‚¨çš„ key ä¸º symbol_index æ ¼å¼ (ä¾‹å¦‚ 'BTCUSDT_0')ï¼Œvalue ä¸º K_Line å®ä¾‹çš„å®Œæ•´ ArrayBufferã€‚

æä¾›æ¸…æ™°çš„ APIï¼Œå¦‚ getKline(key) å’Œ saveKline(key, data)ã€‚

åœ¨ saveKline å†…éƒ¨å¤„ç†äº‹åŠ¡ï¼Œä¿è¯å†™å…¥çš„åŸå­æ€§ã€‚

åˆå§‹åŒ–å¤±è´¥æ—¶ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯ï¼Œç»ˆæ­¢ Workerã€‚

4. å…³é”®å·¥ä½œæµç¨‹

UI -> Worker: é¡µé¢è°ƒç”¨ addSymbolKline(['BTCUSDT'])ï¼Œkl_client å‘ SharedWorker å‘é€ { type: 'SUBSCRIBE_SYMBOLS', payload: { symbols: ['BTCUSDT'] } } æ¶ˆæ¯ã€‚

Worker å¤„ç† (å¯¹ BTCUSDT çš„æ‰€æœ‰å‘¨æœŸï¼Œä¾‹å¦‚ 1m å‘¨æœŸï¼Œç´¢å¼•ä¸º 0):
a. æ£€æŸ¥å†…å­˜ (L1): æ£€æŸ¥ klineDB ä¸­æ˜¯å¦å­˜åœ¨ 'BTCUSDT_0' çš„æ•°æ®ã€‚è‹¥å­˜åœ¨ï¼Œç›´æ¥å°† ArrayBuffer å¹¿æ’­ç»™å®¢æˆ·ç«¯ï¼Œæµç¨‹ç»“æŸã€‚è‹¥ä¸å­˜åœ¨ï¼Œè¿›å…¥ä¸‹ä¸€æ­¥ã€‚
b. æŸ¥è¯¢DB (L2):

è°ƒç”¨ klineDBManager.getKline('BTCUSDT_0')ã€‚

è‹¥DBä¸­æœ‰æ•°æ®: å°†DBä¸­çš„ ArrayBuffer åŠ è½½åˆ° Worker çš„å†…å­˜ç¼“å­˜ (klineDB) ä¸­ï¼Œç„¶åå¹¿æ’­ç»™å®¢æˆ·ç«¯ã€‚

è‹¥DBä¸­æ— æ•°æ®: å‡†å¤‡ä»ç½‘ç»œè·å–ã€‚
c. ç½‘ç»œè¯·æ±‚ (L3): Worker å‘æœ¬åœ°RustæœåŠ¡å‘èµ·è¯·æ±‚ï¼šfetch('http://127.0.0.1:3000/klines?symbol=BTCUSDT&interval=1m&limit=1500')ã€‚
d. åˆå¹¶ã€ä¿å­˜ä¸å¹¿æ’­:

å°†ç½‘ç»œè¿”å›çš„JSONæ•°æ® newData ä¸ä»DBåŠ è½½çš„ oldData (å¦‚æœ‰) è¿›è¡Œåˆå¹¶ã€‚åˆå¹¶ç­–ç•¥å¦‚ä¸‹ï¼š

è‹¥ oldData ä¸ºç©ºï¼Œç›´æ¥ä½¿ç”¨ newDataã€‚

è‹¥ oldData ä¸ä¸ºç©ºï¼Œè·å–å…¶æœ€åä¸€æ ¹Kçº¿çš„æ—¶é—´æˆ³ lastTimestampã€‚

æ‰¾åˆ° newData ä¸­ç¬¬ä¸€æ ¹æ—¶é—´æˆ³å¤§äº lastTimestamp çš„Kçº¿ï¼Œå°†åç»­æ‰€æœ‰æ–°Kçº¿ push åˆ° oldData ä¸­ã€‚

å°†åˆå¹¶åçš„æœ€ç»ˆæ•°æ®å­˜å…¥ä¸€ä¸ªæ–°çš„ K_Line å®ä¾‹ä¸­ã€‚è¿™ä¸ªå®ä¾‹çš„ underlyingBuffer åŒ…å«äº†æ‰€æœ‰æ•°æ®å’Œå…ƒæ•°æ®ã€‚

è°ƒç”¨ klineDBManager.saveKline('BTCUSDT_0', finalKline.underlyingBuffer) å°†ç»“æœåŸå­æ€§åœ°å†™å…¥ IndexedDBã€‚

æ›´æ–° Worker è‡ªå·±çš„å†…å­˜ç¼“å­˜ (klineDB)ã€‚

å°†æ­¤å‘¨æœŸæœ€ç»ˆçš„å®Œæ•´ ArrayBuffer é€šè¿‡ postMessage é›¶æ‹·è´å¹¿æ’­ç»™æ‰€æœ‰ Clientã€‚
e. è®¢é˜…å®æ—¶æ•°æ®: å°† BTCUSDT æ‰€æœ‰å‘¨æœŸçš„ stream name (ä¾‹å¦‚ btcusdt_perpetual@continuousKline_1m) æ·»åŠ åˆ°ä¸€ä¸ªå¾…è®¢é˜…é˜Ÿåˆ—ä¸­ã€‚åå°ä»»åŠ¡ä¼šç®¡ç†å•ä¸€ WebSocket è¿æ¥ï¼Œå¹¶æ‰¹é‡å¤„ç†æ­¤é˜Ÿåˆ—ã€‚

SharedWorker çš„å•ä¸€å…±äº« WebSocket æ”¶åˆ°ä¸€æ ¹æ–°çš„Kçº¿æ•°æ®ã€‚

æ ¹æ® k.x å­—æ®µåˆ¤æ–­Kçº¿æ˜¯å¦å®Œç»“ï¼š

k.x === false (æœªå®Œç»“): Worker è°ƒç”¨è‡ªèº«å†…å­˜ä¸­å¯¹åº” K_Line å®ä¾‹çš„ updateLast() æ–¹æ³•ã€‚

k.x === true (å·²å®Œç»“): Worker è°ƒç”¨ push() æ–¹æ³•ã€‚

Worker å°†è¿™æ ¹Kçº¿çš„JSONå¯¹è±¡ (ONE_K) åŒ…è£…æˆ { type: 'KLINE_UPDATE', ... } æ¶ˆæ¯ï¼Œå¹¿æ’­ç»™æ‰€æœ‰ Clientã€‚åœ¨è½¬æ¢æ—¶ï¼Œext_ ç›¸å…³å­—æ®µå…¨éƒ¨ç½®ä¸º 0ã€‚

å„ä¸ªé¡µé¢çš„ kl_client æ”¶åˆ°æ¶ˆæ¯ï¼Œè°ƒç”¨è‡ªå·±é¡µé¢å†…å­˜ä¸­å¯¹åº” K_Line å®ä¾‹çš„ updateLast() æˆ– push() æ–¹æ³•ï¼ŒUI å®æ—¶å“åº”ã€‚

å½“ WebSocket æ›´æ–° Worker å†…å­˜æ—¶ï¼Œå°†è¯¥å“ç§æ ‡è®°ä¸ºâ€œè„æ•°æ®â€ (dirtySymbols.add('BTCUSDT'))ã€‚

SharedWorker å†…éƒ¨æ¯30ç§’è§¦å‘ä¸€æ¬¡å®šæ—¶å™¨ï¼Œéå†æ‰€æœ‰â€œè„æ•°æ®â€å“ç§ï¼Œå°†å…¶åœ¨ Worker å†…å­˜ä¸­çš„æœ€æ–°Kçº¿æ•°æ® (ArrayBuffer) å›å†™å…¥ IndexedDBã€‚

5. æ•°æ®æ ¼å¼ä¸é€šä¿¡åè®®

Client -> Worker

code
TypeScript
download
content_copy
expand_less
// è¯·æ±‚/è®¢é˜…æŸäº›å“ç§çš„æ‰€æœ‰å‘¨æœŸKçº¿
interface SubscribeSymbolsMessage {
 type: 'SUBSCRIBE_SYMBOLS';
 payload: {
 symbols: string[];
 };
}

Worker -> Client

code
TypeScript
download
content_copy
expand_less
// é¦–æ¬¡å‘é€æŸä¸ªå‘¨æœŸçš„å®Œæ•´Kçº¿æ•°æ® (äºŒè¿›åˆ¶)
// æ³¨æ„ï¼šå…ƒæ•°æ®(length, head, tail)å·²åŒ…å«åœ¨bufferå¤´éƒ¨ï¼Œæ— éœ€é¢å¤–å­—æ®µ
interface InitialKlineDataMessage {
 type: 'INITIAL_KLINE_DATA';
 payload: {
 symbol: string;
 index: number; // å‘¨æœŸç´¢å¼•
 buffer: ArrayBuffer; // K_Line å®ä¾‹çš„åº•å±‚ ArrayBufferï¼Œè‡ªåŒ…å«å…ƒæ•°æ®
 };
}

// å¹¿æ’­å®æ—¶Kçº¿æ›´æ–° (JSON)
interface KlineUpdateMessage {
 type: 'KLINE_UPDATE';
 payload: {
 symbol: string;
 index: number;
 updateType: 'push' | 'updateLast';
 kline: ONE_K; // å®Œæ•´çš„Kçº¿å¯¹è±¡
 };
}
6. æ•°æ®ä¸€è‡´æ€§ä¸ç»´æŠ¤ (3000æ¡Kçº¿è§„åˆ™)

å†…å­˜å±‚é¢ (CycleArray): K_Line ç±»çš„å®¹é‡å°†è®¾ç½®ä¸º 3000ã€‚å½“é€šè¿‡ WebSocket push ä¸€æ ¹æ–°Kçº¿æ—¶ï¼Œå¦‚æœæ•°ç»„å·²æ»¡ï¼Œæœ€è€çš„ä¸€æ ¹ä¼šè‡ªåŠ¨è¢«ä¸¢å¼ƒã€‚

å­˜å‚¨å±‚é¢: ç”±äº K_Line çš„ ArrayBuffer å®¹é‡æ˜¯å›ºå®šçš„ (3000æ¡)ï¼Œå†™å…¥DBçš„æ•°æ®å¤©ç„¶å°±ä¸ä¼šè¶…è¿‡ä¸Šé™ï¼Œæ— éœ€ slice æ“ä½œã€‚

7. å®æ–½è®¡åˆ’ä¸ä»£ç ä¿®æ”¹

é‡æ„ CycleArray ä»¥åœ¨ ArrayBuffer å¤´éƒ¨åŒ…å«å…ƒæ•°æ®ï¼Œå¹¶æ·»åŠ  setBackingBuffer æ–¹æ³•ã€‚

code
TypeScript
download
content_copy
expand_less
// src/_____lib/func/CycleArray.ts
/**
 * CycleArray - é«˜æ€§èƒ½åˆ—å¼å­˜å‚¨å¾ªç¯æ•°ç»„
 * 
 * å†…å­˜å¸ƒå±€:
 * [METADATA_HEADER] [COLUMN_1_DATA] [COLUMN_2_DATA] ... [COLUMN_N_DATA]
 * 
 * METADATA_HEADER (16 bytes):
 * - head (Uint32): æŒ‡å‘ç¬¬ä¸€æ¡æ•°æ®çš„ç´¢å¼•ã€‚
 * - tail (Uint32): æŒ‡å‘ä¸‹ä¸€æ¡å¯æ’å…¥æ•°æ®çš„ç´¢å¼•ã€‚
 * - length (Uint32): æ•°ç»„ä¸­çš„å®é™…æ•°æ®é‡ã€‚
 * - capacity (Uint32): æ•°ç»„çš„æœ€å¤§å®¹é‡ã€‚
 * 
 * è¿™ç§è®¾è®¡ä½¿å¾—æ•´ä¸ªæ•°æ®ç»“æ„ï¼ˆåŒ…æ‹¬çŠ¶æ€ï¼‰å¯ä»¥è¢«ä¸€ä¸ª ArrayBuffer å®Œæ•´è¡¨ç¤ºï¼Œ
 * æ–¹ä¾¿é€šè¿‡ postMessage è¿›è¡Œé›¶æ‹·è´ä¼ è¾“å’Œé€šè¿‡ IndexedDB è¿›è¡ŒæŒä¹…åŒ–ã€‚
 */
const METADATA_HEADER_SIZE = 16; // 4 * Uint32

export function CycleArray<T extends { [key: string]: any }>(
 schema: { [K in keyof T]: new (buffer: ArrayBuffer, byteOffset: number, length: number) => T[K] },
 capacity: number
) {
 const fields = Object.keys(schema) as (keyof T)[];
 const fieldConstructors = Object.values(schema);
 const bytesPerElementForField = fieldConstructors.map(c => (c as any).BYTES_PER_ELEMENT);

 const fieldBlockSize = bytesPerElementForField.map(b => b * capacity);
 const totalDataByteLength = fieldBlockSize.reduce((sum, size) => sum + size, 0);
 const totalRecordByteLength = METADATA_HEADER_SIZE + totalDataByteLength;

 return class CycleArrayImpl {
 static readonly å­—èŠ‚æ•° = totalRecordByteLength;
 static readonly ARR_MAX_LENGTH = capacity;

 private buffer: ArrayBuffer;
 private metadata: Uint32Array; // View for head, tail, length, capacity
 public data: T;

 constructor(buffer?: ArrayBuffer, byteOffset: number = 0) {
 if (buffer) {
 this.buffer = buffer.slice(byteOffset, byteOffset + totalRecordByteLength);
 } else {
 this.buffer = new ArrayBuffer(totalRecordByteLength);
 }
 this.metadata = new Uint32Array(this.buffer, 0, 4);
 
 if (!buffer) {
 this.metadata[3] = capacity; // capacity
 }

 this.data = {} as T;
 this.initDataViews();
 }

 private initDataViews() {
 let currentOffset = METADATA_HEADER_SIZE;
 fields.forEach((key, i) => {
 const constructor = schema[key];
 // @ts-ignore
 this.data[key] = new constructor(this.buffer, currentOffset, capacity);
 currentOffset += fieldBlockSize[i];
 });
 }

 get head() { return this.metadata[0]; }
 private set head(val: number) { this.metadata[0] = val; }

 get tail() { return this.metadata[1]; }
 private set tail(val: number) { this.metadata[1] = val; }

 get length() { return this.metadata[2]; }
 private set length(val: number) { this.metadata[2] = val; }

 get capacity() { return this.metadata[3]; }

 get underlyingBuffer(): ArrayBuffer {
 return this.buffer;
 }

 push(item: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }) {
 fields.forEach(key => {
 // @ts-ignore
 this.data[key][this.tail] = item[key];
 });

 if (this.length === this.capacity) {
 this.tail = (this.tail + 1) % this.capacity;
 this.head = (this.head + 1) % this.capacity;
 } else {
 this.tail = (this.tail + 1) % this.capacity;
 this.length++;
 }
 }

 updateLast(item: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }) {
 if (this.length === 0) {
 this.push(item);
 return;
 }
 const lastIndex = (this.tail - 1 + this.capacity) % this.capacity;
 fields.forEach(key => {
 // @ts-ignore
 this.data[key][lastIndex] = item[key];
 });
 }

 set(items: { [K in keyof T]: T[K] extends BigInt64Array ? bigint : number }[]) {
 this.clear();
 const itemsToPush = items.slice(-this.capacity);
 for (const item of itemsToPush) {
 this.push(item);
 }
 }
 
 set_f64(data_f64: { [key: string]: Float64Array | BigInt64Array }) {
 this.clear();
 const len = data_f64.close.length;
 for (let i = 0; i < len; i++) {
 const item: any = {};
 fields.forEach(key => {
 item[key] = data_f64[key][i];
 });
 this.push(item);
 }
 }

 clear() {
 this.head = 0;
 this.tail = 0;
 this.length = 0;
 }

 setBackingBuffer(newBuffer: ArrayBuffer) {
 if (newBuffer.byteLength !== this.buffer.byteLength) {
 console.error(`[CycleArray] Mismatched buffer size in setBackingBuffer. Expected ${this.buffer.byteLength}, got ${newBuffer.byteLength}.`);
 return;
 }
 this.buffer = newBuffer;
 this.metadata = new Uint32Array(this.buffer, 0, 4);
 this.initDataViews();
 }

 [Symbol.iterator]() {
 let count = 0;
 let currentIndex = this.head;
 return {
 next: () => {
 if (count < this.length) {
 const item: any = {};
 fields.forEach(key => {
 item[key] = this.data[key][currentIndex];
 });
 currentIndex = (currentIndex + 1) % this.capacity;
 count++;
 return { value: item, done: false };
 }
 return { value: undefined, done: true };
 }
 };
 }
 };
}
code
TypeScript
download
content_copy
expand_less
// src/kl_server/ONE_K.ts
import { CycleArray } from "../_____lib/func/CycleArray";

export type ONE_K = {
 timestamp: number| bigint;
 open: number;
 high: number;
 low: number;
 close: number;
 æˆäº¤é¢: number;
 ext_æŒä»“é‡: number;
 ext_èµ„é‡‘è´¹ç‡: number;
 ext_å¤šç©ºæ¯”: number;
};

export class K_Line extends CycleArray({
 timestamp: BigInt64Array,
 open: Float64Array,
 high: Float64Array,
 low: Float64Array,
 close: Float64Array,
 æˆäº¤é¢: Float64Array,
 ext_æŒä»“é‡: Float64Array,
 ext_èµ„é‡‘è´¹ç‡: Float64Array,
 ext_å¤šç©ºæ¯”: Float64Array,
}, 3000) { } // <--- ä¿®æ”¹ä¸º 3000
code
TypeScript
download
content_copy
expand_less
// public/kline_db_manager.ts
const DB_NAME = 'kline_cache_db';
const DB_VERSION = 1;
const KLINE_STORE_NAME = 'klines'; // å•ä¸€å¯¹è±¡å­˜å‚¨

let dbPromise: Promise<IDBDatabase> | null = null;

export const klineDBManager = {
 async init(): Promise<void> {
 if (dbPromise) return;

 dbPromise = new Promise((resolve, reject) => {
 const request = indexedDB.open(DB_NAME, DB_VERSION);

 request.onerror = () => {
 console.error('[DBManager] IndexedDB open error:', request.error);
 reject(new Error('Failed to open IndexedDB.'));
 };

 request.onsuccess = () => {
 console.log('[DBManager] IndexedDB connection successful.');
 resolve(request.result);
 };

 request.onupgradeneeded = (event) => {
 console.log('[DBManager] Upgrading IndexedDB...');
 const db = (event.target as IDBOpenDBRequest).result;
 if (!db.objectStoreNames.contains(KLINE_STORE_NAME)) {
 db.createObjectStore(KLINE_STORE_NAME);
 console.log(`[DBManager] Object store "${KLINE_STORE_NAME}" created.`);
 }
 };
 });

 try {
 await dbPromise;
 } catch (error) {
 dbPromise = null;
 throw error;
 }
 },

 async getKline(key: string): Promise<ArrayBuffer | undefined> {
 if (!dbPromise) await this.init();
 const db = await dbPromise!;

 return new Promise((resolve, reject) => {
 const transaction = db.transaction(KLINE_STORE_NAME, 'readonly');
 const store = transaction.objectStore(KLINE_STORE_NAME);
 const request = store.get(key);

 request.onerror = () => reject(request.error);
 request.onsuccess = () => resolve(request.result as ArrayBuffer | undefined);
 });
 },

 async saveKline(key: string, data: ArrayBuffer): Promise<void> {
 if (!dbPromise) await this.init();
 const db = await dbPromise!;

 return new Promise((resolve, reject) => {
 const transaction = db.transaction(KLINE_STORE_NAME, 'readwrite');
 const store = transaction.objectStore(KLINE_STORE_NAME);
 const request = store.put(data, key);

 transaction.oncomplete = () => resolve();
 transaction.onerror = () => reject(transaction.error);
 });
 }
};
code
TypeScript
download
content_copy
expand_less
// public/kline_worker.ts
import { ALL_K } from '../src/kl_server/BA_1';
import { K_Line, ONE_K } from '../src/kl_server/ONE_K';
import { binance_kline_å‘¨æœŸ_é…ç½® } from '../src/kl_server/binance_kline_å‘¨æœŸ_é…ç½®';
import { klineDBManager } from './kline_db_manager';

// --- Worker å…¨å±€çŠ¶æ€ ---
const ports: MessagePort[] = [];
const klineDB = new ALL_K(); // Worker å†…éƒ¨çš„æƒå¨å†…å­˜æ•°æ®åº“
const dirtySymbols = new Set<string>();

// --- WebSocket ç®¡ç† ---
let ws: WebSocket | null = null;
let connectionState: 'DISCONNECTED' | 'CONNECTING' | 'CONNECTED' = 'DISCONNECTED';
const activeSubscriptions = new Set<string>();
const pendingSubscriptionQueue = new Set<string>();
let subscriptionIdCounter = 1;
const subscriptionIdToStreamsMap = new Map<number, string[]>();

// --- HTTP è¯·æ±‚ç®¡ç† ---
const RUST_BACKEND_URL = 'http://127.0.0.1:3000';

// --- åˆå§‹åŒ– ---
klineDBManager.init().catch(err => {
 console.error('[Worker] CRITICAL: Failed to initialize IndexedDB. Worker will not function.', err);
 self.close();
});

// --- WebSocket æ ¸å¿ƒåŠŸèƒ½ ---
function connectWebSocket() {
 if (connectionState !== 'DISCONNECTED') return;
 console.log('[Worker] WebSocket: Connecting...');
 connectionState = 'CONNECTING';
 ws = new WebSocket('wss://fstream.mokexapp.info/ws');
 ws.onopen = () => {
 console.log('[Worker] WebSocket: Connection OPENED.');
 connectionState = 'CONNECTED';
 activeSubscriptions.forEach(stream => pendingSubscriptionQueue.add(stream));
 activeSubscriptions.clear();
 };
 ws.onmessage = onWebSocketMessage;
 ws.onclose = () => {
 console.log('[Worker] WebSocket: Connection CLOSED. Reconnecting in 3s...');
 ws = null;
 connectionState = 'DISCONNECTED';
 setTimeout(connectWebSocket, 3000);
 };
 ws.onerror = (error) => console.error('[Worker] WebSocket: Error:', error);
}

setInterval(() => {
 if (connectionState === 'CONNECTED' && ws && pendingSubscriptionQueue.size > 0) {
 const batch = Array.from(pendingSubscriptionQueue).slice(0, 50);
 if (batch.length === 0) return;
 const id = subscriptionIdCounter++;
 const subscribeMessage = { method: "SUBSCRIBE", params: batch, id };
 ws.send(JSON.stringify(subscribeMessage));
 console.log(`[Worker] WebSocket: Sent SUBSCRIBE request for ${batch.length} streams (ID: ${id}).`);
 subscriptionIdToStreamsMap.set(id, batch);
 batch.forEach(stream => pendingSubscriptionQueue.delete(stream));
 }
}, 500);

function onWebSocketMessage(event: MessageEvent) {
 const msg = JSON.parse(event.data);
 if (msg.stream && msg.data?.e === 'continuous_kline') {
 const { ps: symbol, k } = msg.data;
 const periodConfig = binance_kline_å‘¨æœŸ_é…ç½®.find(p => p.interval === k.i);
 if (!periodConfig) return;
 const index = binance_kline_å‘¨æœŸ_é…ç½®.indexOf(periodConfig);
 const key = `${symbol}_${index}`;
 const klineInstance = klineDB.get_kline(key);
 if (klineInstance.length === 0) return;
 const oneK: ONE_K = {
 timestamp: BigInt(k.t), open: parseFloat(k.o), high: parseFloat(k.h),
 low: parseFloat(k.l), close: parseFloat(k.c), æˆäº¤é¢: parseFloat(k.q),
 ext_æŒä»“é‡: 0, ext_å¤šç©ºæ¯”: 0, ext_èµ„é‡‘è´¹ç‡: 0,
 };
 const updateType = k.x ? 'push' : 'updateLast';
 if (updateType === 'push') klineInstance.push(oneK);
 else klineInstance.updateLast(oneK);
 dirtySymbols.add(symbol);
 broadcast({ type: 'KLINE_UPDATE', payload: { symbol, index, updateType, kline: oneK } });
 return;
 }
 if (msg.id) {
 const streams = subscriptionIdToStreamsMap.get(msg.id);
 if (msg.result === null) {
 console.log(`[Worker] WebSocket: Subscription success for ID ${msg.id}`);
 streams?.forEach(stream => activeSubscriptions.add(stream));
 } else if (msg.error) {
 console.error(`[Worker] WebSocket: Subscription failed for ID ${msg.id}`, msg.error);
 setTimeout(() => {
 streams?.forEach(stream => pendingSubscriptionQueue.add(stream));
 console.log(`[Worker] WebSocket: Re-queuing ${streams?.length} failed streams for retry.`);
 }, 3000);
 }
 subscriptionIdToStreamsMap.delete(msg.id);
 }
}

// --- æ•°æ®åŠ è½½ä¸ç¼“å­˜æ ¸å¿ƒé€»è¾‘ ---
async function loadHistoricalDataForSymbol(symbol: string) {
 console.log(`[Worker] Starting data load process for ${symbol}...`);
 const periods = binance_kline_å‘¨æœŸ_é…ç½®;
 for (let i = 0; i < periods.length; i++) {
 const { interval } = periods[i];
 const key = `${symbol}_${i}`;
 if (klineDB.get_kline(key) && klineDB.get_kline(key).length > 0) {
 const klineInstance = klineDB.get_kline(key);
 const bufferToSend = klineInstance.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 continue;
 }
 const dbBuffer = await klineDBManager.getKline(key);
 const dbKline = dbBuffer ? new K_Line(dbBuffer) : null;
 const url = `${RUST_BACKEND_URL}/klines?symbol=${symbol}&interval=${interval}&limit=3000`;
 const response = await fetch(url);
 if (!response.ok) { console.error(`[Worker] Failed to fetch ${key}. Status: ${response.status}`); continue; }
 const networkData: ONE_K[] = await response.json();
 if (!networkData || networkData.length === 0) {
 if (dbKline) { // å¦‚æœDBæœ‰æ•°æ®ä½†ç½‘ç»œæ²¡è¿”å›ï¼Œä¾ç„¶ä½¿ç”¨DBæ•°æ®
 klineDB.get_kline(key).setBackingBuffer(dbKline.underlyingBuffer);
 const bufferToSend = dbKline.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 }
 continue;
 }
 const finalKline = dbKline || new K_Line();
 if (dbKline && dbKline.length > 0) {
 const lastDbTimestamp = Number(dbKline.data.timestamp[dbKline.length - 1]);
 const newBars = networkData.filter(k => Number(k.timestamp) > lastDbTimestamp);
 newBars.forEach(bar => finalKline.push({ ...bar, timestamp: BigInt(bar.timestamp) }));
 } else {
 finalKline.set(networkData.map(bar => ({ ...bar, timestamp: BigInt(bar.timestamp) })));
 }
 klineDB.get_kline(key).setBackingBuffer(finalKline.underlyingBuffer);
 await klineDBManager.saveKline(key, finalKline.underlyingBuffer);
 const bufferToSend = finalKline.underlyingBuffer.slice(0);
 broadcast({ type: 'INITIAL_KLINE_DATA', payload: { symbol, index: i, buffer: bufferToSend } }, [bufferToSend]);
 }
 periods.forEach(p => {
 const streamName = `${symbol.toLowerCase()}_perpetual@continuousKline_${p.interval}`;
 pendingSubscriptionQueue.add(streamName);
 });
}

// --- Worker é€šä¿¡ä¸ç”Ÿå‘½å‘¨æœŸ ---
onconnect = (e: SharedWorkerGlobalScopeConnectEvent) => {
 const port = e.ports[0];
 ports.push(port);
 if (ports.length === 1) connectWebSocket();
 port.onmessage = async (event: MessageEvent) => {
 const { type, payload } = event.data;
 if (type === 'SUBSCRIBE_SYMBOLS') {
 for (const symbol of payload.symbols) {
 loadHistoricalDataForSymbol(symbol);
 }
 }
 };
 port.start();
};

function broadcast(message: any, transferables?: Transferable[]) {
 ports.forEach(port => port.postMessage(message, transferables || []));
}

// --- åå°æŒä¹…åŒ– ---
setInterval(async () => {
 if (dirtySymbols.size === 0) return;
 const symbolsToSave = Array.from(dirtySymbols);
 dirtySymbols.clear();
 for (const symbol of symbolsToSave) {
 for (let i = 0; i < binance_kline_å‘¨æœŸ_é…ç½®.length; i++) {
 const key = `${symbol}_${i}`;
 const klineInstance = klineDB.get_kline(key);
 if (klineInstance && klineInstance.length > 0) {
 await klineDBManager.saveKline(key, klineInstance.underlyingBuffer);
 }
 }
 }
}, 30000);
code
TypeScript
download
content_copy
expand_less
// src/kl_server/kl_client.ts
import { K_Line } from "./ONE_K";
import { SyncClient } from "../_____lib/net/sync/SyncClient";
import { ALL_K } from "./BA_1";
import { BA_2 } from "./BA_2";
import { BA_3 } from "./BA_3";
import { binance_symbolToAssetCode } from "./binance_symbolToAssetCode";

export namespace kl_client {
 let worker: SharedWorker | null = null;
 const klineDB = new ALL_K();

 export let c3: SyncClient<typeof BA_3.realDB, typeof BA_3.funcList>;
 export let c2: SyncClient<typeof BA_2.realDB, typeof BA_2.funcList>;
 let _indexServer: any;
 export let isInitialSyncComplete = false;
 export let onDataUpdated: () => void = () => {};

 function handleWorkerMessage(event: MessageEvent) {
 const { type, payload } = event.data;
 switch (type) {
 case 'INITIAL_KLINE_DATA': {
 const { symbol, index, buffer } = payload;
 const key = `${symbol}_${index}`;
 klineDB.get_kline(key).setBackingBuffer(buffer);
 break;
 }
 case 'KLINE_UPDATE': {
 const { symbol, index, updateType, kline } = payload;
 const key = `${symbol}_${index}`;
 const klineInstance = klineDB.get_kline(key);
 const klineForUI = { ...kline, timestamp: BigInt(kline.timestamp) };
 if (updateType === 'push') {
 klineInstance.push(klineForUI);
 } else {
 klineInstance.updateLast(klineForUI);
 }
 break;
 }
 }
 onDataUpdated();
 }

 export function connect() {
 if (!worker) {
 try {
 worker = new SharedWorker('kline_worker.js', { name: 'KlineDataWorker' });
 worker.port.onmessage = handleWorkerMessage;
 worker.port.start();
 console.log('[kl_client] Successfully connected to SharedWorker.');
 } catch (error) {
 console.error('[kl_client] CRITICAL: Failed to connect to SharedWorker. K-line data will not be available.', error);
 return;
 }
 }

 if (c2 && c3) return;
 c3 = new SyncClient('kl_client_ba3', BA_3);
 c2 = new SyncClient('kl_client_ba2', BA_2);
 let c2_ok = false, c3_ok = false;
 const check_sync_ok = () => {
 if (c2_ok && c3_ok && !isInitialSyncComplete) {
 isInitialSyncComplete = true;
 console.log(`[kl_client] ğŸš€ Backend Info/Stats sync complete!`);
 onDataUpdated();
 }
 };
 c2.onStatusChange.subscribe(() => { if (c2.isConnected) { c2_ok = true; check_sync_ok(); } });
 c3.onStatusChange.subscribe(() => { if (c3.isConnected) { c3_ok = true; check_sync_ok(); } });
 c3.connect();
 c2.connect();
 }

 export function addSymbolKline(symbols: string[]) {
 if (!worker || symbols.length === 0) return;
 worker.port.postMessage({
 type: 'SUBSCRIBE_SYMBOLS',
 payload: { symbols }
 });
 }

 export const getKline = (symbol: string, index: number): K_Line => {
 return klineDB.get_kline(`${symbol}_${index}`);
 }

 // --- ä»¥ä¸‹å‡½æ•°ä¿æŒä¸å˜ ---
 export function setIndexServer(server: any) { _indexServer = server; }
 export function getIndices() {
 if (!_indexServer) return { marketCapIndex: 0, equalWeightIndex: 0, timestamp: 0 };
 return _indexServer.getIndices();
 }
 export const disconnect = () => {
 worker?.port.close();
 worker = null;
 c3?.disconnect();
 c2?.disconnect();
 }
 export const getåˆçº¦info = (symbol: string) => {
 if (!c2) return { tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1, market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0 };
 let info = c2.realDB.data.åˆçº¦_info[symbol];
 if (info === undefined) info = { tickSize: 1, stepSize: 1, limit_min: 1, limit_max: 1, market_min: 1, market_max: 1, ä¸Šçº¿æ—¶é—´: 0, å¼ºå¹³è´¹ç‡: 0, å¸‚ä»·åƒå•: 0 };
 return info;
 }
 export const getåˆçº¦__ç°è´§_info = (symbol: string) => {
 if (!c2) return { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
 let info = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol];
 if (info === undefined) info = { binanceç°è´§tags_key: [], æœ€å¤§ä¾›åº”é‡: 0, æ€»ä¾›åº”é‡: 0, æµé€šé‡: 0 };
 return info;
 }
 export const getå¤šç©ºæ¯” = (symbol: string) => {
 const v = getKline(symbol, 0);
 return v.data.ext_å¤šç©ºæ¯”.length > 0 ? v.data.ext_å¤šç©ºæ¯”[v.data.ext_å¤šç©ºæ¯”.length - 1] : 0;
 }
 export const isæ ‡è®°ä»·æ ¼è¿‘ = (symbol: string) => {
 const æœ€æ–° = get24æœ€æ–°(symbol).æœ€æ–°ä»·æ ¼;
 const æ ‡è®° = getè´¹ç‡(symbol).æ ‡è®°ä»·æ ¼;
 if (isNaN(æœ€æ–°) || isNaN(æ ‡è®°)) return false;
 return Math.max(æœ€æ–°, æ ‡è®°) / Math.min(æœ€æ–°, æ ‡è®°) < 1.001;
 };
 export const getå…¨éƒ¨å“ç§ = () => c2 ? Object.keys(c2.realDB.data.åˆçº¦_info) : [];
 export const getè´¹ç‡ = (symbol: string) => (c2 && c2.realDB.data.åˆçº¦__æ ‡è®°ä»·æ ¼[symbol]) || { æ ‡è®°ä»·æ ¼: NaN, ç°è´§æŒ‡æ•°ä»·æ ¼: NaN, èµ„é‡‘è´¹ç‡: NaN, èµ„é‡‘è´¹ç‡å€’è®¡æ—¶: NaN };
 export const get24æœ€æ–° = (symbol: string) => ({ æœ€æ–°ä»·æ ¼: getOrderBook(symbol).buy1 });
 export const getæµé€šå¸‚å€¼ = (symbol: string) => {
 if (!c2) return 0;
 const price = kl_client.getOrderBook(symbol).buy1;
 const supply = c2.realDB.data.åˆçº¦__ç°è´§_info[symbol]?.æµé€šé‡ || 0;
 return price * supply;
 }
 export const getæ‰‹åŠ¨dataSRC = (symbol: string) => (c2 && c2.realDB.data.æ‰‹åŠ¨_symbol_info_dic[symbol]) || { __: '', assetName: binance_symbolToAssetCode(symbol), tags_dic: {}, website: '', X: '' };
 export const getæ‰‹åŠ¨_é¢˜æ_æ’åº = () => c2 ? c2.realDB.data.æ‰‹åŠ¨_é¢˜æ_æ’åº : [];
 export const getOrderBook = (symbol: string) => {
 const close = getKline(symbol, 0).data.close;
 return {
 buy1: close.length > 0 ? close[close.length - 1] : NaN,
 sell1: close.length > 0 ? close[close.length - 1] : NaN,
 }
 }
 export interface TurnoverRankItem { symbol: string; turnover: number; price: number; marketCap: number; }
 export const getTurnoverTop15 = (): TurnoverRankItem[] => {
 if (!c3?.realDB.data.rankings) return [];
 return Object.entries(c3.realDB.data.rankings)
 .map(([symbol, stats]) => ({
 symbol: symbol,
 turnover: (stats?._7å¤©æˆäº¤é¢ ?? 0) / 100000000,
 price: getOrderBook(symbol)?.buy1 ?? 0,
 marketCap: getæµé€šå¸‚å€¼(symbol) ?? 0,
 }))
 .sort((a, b) => b.turnover - a.turnover)
 .slice(0, 15);
 }
}